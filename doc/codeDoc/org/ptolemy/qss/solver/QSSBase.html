<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>QSSBase</title>
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="QSSBase";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":6,"i1":9,"i2":9,"i3":9,"i4":9,"i5":6,"i6":6,"i7":6,"i8":6,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":6,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":10,"i44":10,"i45":10,"i46":10,"i47":10,"i48":10,"i49":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../org/ptolemy/qss/solver/QSS3Pts.html" title="class in org.ptolemy.qss.solver"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li>Next&nbsp;Class</li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?org/ptolemy/qss/solver/QSSBase.html" target="_top">Frames</a></li>
<li><a href="QSSBase.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.ptolemy.qss.solver</div>
<h2 title="Class QSSBase" class="title">Class QSSBase</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.ptolemy.qss.solver.QSSBase</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><a href="../../../../org/ptolemy/qss/solver/LIQSS1.html" title="class in org.ptolemy.qss.solver">LIQSS1</a>, <a href="../../../../org/ptolemy/qss/solver/LIQSS2Fd.html" title="class in org.ptolemy.qss.solver">LIQSS2Fd</a>, <a href="../../../../org/ptolemy/qss/solver/QSS1.html" title="class in org.ptolemy.qss.solver">QSS1</a>, <a href="../../../../org/ptolemy/qss/solver/QSS2Fd.html" title="class in org.ptolemy.qss.solver">QSS2Fd</a>, <a href="../../../../org/ptolemy/qss/solver/QSS2FdJac.html" title="class in org.ptolemy.qss.solver">QSS2FdJac</a>, <a href="../../../../org/ptolemy/qss/solver/QSS2Pts.html" title="class in org.ptolemy.qss.solver">QSS2Pts</a>, <a href="../../../../org/ptolemy/qss/solver/QSS2Qts.html" title="class in org.ptolemy.qss.solver">QSS2Qts</a>, <a href="../../../../org/ptolemy/qss/solver/QSS3Fd.html" title="class in org.ptolemy.qss.solver">QSS3Fd</a>, <a href="../../../../org/ptolemy/qss/solver/QSS3Pts.html" title="class in org.ptolemy.qss.solver">QSS3Pts</a></dd>
</dl>
<hr>
<br>
<pre>public abstract class <span class="typeNameLabel">QSSBase</span>
extends java.lang.Object</pre>
<div class="block">Provide a base class for QSS methods for solving ordinary differential equations.

 <p>A QSS integrator implements one of the "quantized state systems" methods
 for solving an initial-value problem (IVP) of a system of ordinary differential
 equations (ODEs).</p>

 <p>A single QSS integrator may be responsible for an entire system of ODEs.
 Alternately, it may be responsible for a subset of a larger system.
 The latter approach allows building up a system from smaller components
 that represent interacting subsystems.
 Furthermore, each of those subsystems can be integrated by a different
 variation on the QSS family of methods.</p>

 <p>The ODEs are represented using the <code>DerivativeFcn</code> interface.</p>

 <p>Class <code>QSSBase</code> provides a general framework for running a
 single QSS integrator.
 This framework must be supplemented in a number of ways:</p>
 <ul>
 <li>Implementing a specific member of the QSS family requires extending the
 base class.
 The subclass must implement the abstract methods declared here.
 Those abstract "worker" methods provide the particulars associated with
 the specific member of the QSS family.</li>
 <li>Simulating a system comprising multiple QSS integrators requires
 the supervisor to connect the integrators.
 That is, it must match the states predicted by one integrator to the
 input variables used by another integrator.</li>
 <li>Simulating a system requires some supervisory control, for example to
 regulate the time steps, and to sequence the exchange of information between
 integrators.
 See the API notes below.</li>
 </ul>


 <h2>Background</h2>

 <p>Quantized State System (QSS) methods solve a system of ordinary differential
 equations of the form</p>
 <p><i>xdot = f{t, x, u}</i></p>

 <p>where</p>
 <ul>
 <li><i>t</i>, simulation time.</li>
 <li><i>x</i>, vector of state variables, <i>x{t}</i>.</li>
 <li><i>u</i>, vector of input variables, <i>u{t}</i>.</li>
 <li><i>xdot</i>, vector of time rates of change of the state variables.
 That is, <i>xdot = dx/dt</i>.</li>
 <li><i>f</i>, vector-valued derivative function.</li>
 <li>The notation <i>g{y}</i> means that <i>g</i> is a function
 of <i>y</i>.</li>
 </ul>

 <p>To solve this system, QSS methods rewrite the system as</p>
 <p><i>xdot = f{t, q, mu}</i></p>

 <p>where</p>
 <ul>
 <li><i>q</i>, vector of quantized state variables, <i>q{t}</i>.</li>
 <li><i>mu</i>, vector of quantized input variables, <i>u{t}</i>.</li>
 </ul>

 <p>The quantized state, and the quantized input variables, are discretized
 versions of the state and input variables.
 The quantized version is a piecewise-continuous approximation, with a
 functional form chosen to simplify the integration of <i>f</i>.</p>

 <p>The implementation here uses polynomial models to quantize the state
 and input variables.
 For example, QSS1 quantizes the state using a 0th-order polynomial (that
 is, as a constant).
 This means that for purposes of the integration, the state is held constant
 over discrete intervals of time.
 The method name, QSS1, arises since an internal, continuous version of the
 state is maintained as a 1st-order polynomial (that is, as a line).</p>

 <p>The details of the methods are beyond the scope of this documentation.
 See:</p>
 <ul>
 <li>Kofman-2002</li>
 <li>Cellier-2006.</li>
 <li>Migoni-2009.</li>
 <li>Migoni-2013.</li>
 </ul>


 <h2>External vs internal state</h2>

 <p>Quantized state system methods expose a <i>quantized state</i> to users.
 Internally, however, they track a <i>continuous state</i>.
 Both are modeled using polynomials.
 The polynomial representing the internal, continuous state has one more
 coefficient than that for the external, quantized state (i.e., it is of
 order one greater).
 For example, QSS1 represents the quantized state as constant, but the
 continuous state as a linear function of time.</p>

 <p>For the most part, the user does not need to be aware of this distinction.
 In fact, for the most part the user only has access to the quantized state.
 In particular, the user can access the <code>ModelPoly</code> objects used
 to track the quantized states.
 However, the QSS integrator reserves to itself the right to change the
 parameters that define those polynomial models.</p>

 <p>In general, the API refers to an abstract "state" rather than to the
 "quantized state" or the "continuous state".
 However, some methods distinguish between the quantized and continuous
 states.
 For example:
 <ul>
 <li>Method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#evaluateStateModel-int-ptolemy.actor.util.Time-"><code>evaluateStateModel(int, Time)</code></a> evaluates the quantized state model.
 Since the user can access that model directly, this is mainly a convenience
 method.</li>
 <li>Method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#evaluateStateModelContinuous-int-ptolemy.actor.util.Time-"><code>evaluateStateModelContinuous(int, Time)</code></a> evaluates the
 internal, continuous state model.
 This is intended mainly for testing.
 However, since the internal model does represent the state as a continuous
 function of time, for some reporting purposes the internal state may be
 preferred.</li>
 </ul>


 <h2>Terminology</h2>

 <p>The API and documentation presented here use some terms in specific ways.
 Furthermore these terms do not always correspond exactly with those used in
 the QSS method literature.</p>

 <p>The QSS method literature refers to "states" and "quantized states".
 In order to avoid ambiguity, the code here refers to these as
 "continuous states" and "quantized states", respectively.</p>

 <p>Variables for continuous states have names like <code>cStateModel</code>.
 Quantized states have names like <code>qStateModel</code>.</p>

 <p>TODO: Mention terms "rate-events", "state-events", and "quantization-events".</p>


 <h2>A tour of the public API</h2>

 <p>The simplest use of this class is as follows. First, initialize the solver
 as follows:
 <ol>
 <li> Create an instance of a class that implements <a href="../../../../org/ptolemy/qss/util/DerivativeFunction.html" title="interface in org.ptolemy.qss.util"><code>DerivativeFunction</code></a>, and pass
      that into the <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#initialize-org.ptolemy.qss.util.DerivativeFunction-ptolemy.actor.util.Time-ptolemy.actor.util.Time-double-double-int-"><code>initialize(DerivativeFunction, Time, Time, double, double, int)</code></a>
      method.</li>
 <li> Then set the initial values of the state variables using
      <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setStateValue-int-double-"><code>setStateValue(int, double)</code></a>.</li>
 <li> Then set initial input values by updating the models returned by
      <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getInputVariableModel-int-"><code>getInputVariableModel(int)</code></a>.</li>
 <li> Then trigger quantization events using
      <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerQuantizationEvents-boolean-"><code>triggerQuantizationEvents(boolean)</code></a>.</li>
 <li> Finally, trigger rate events using
      <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerRateEvent--"><code>triggerRateEvent()</code></a>.</li>
 </ol>
 At this point, you can determine the first time at which a quantization event
 will occur by calling <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#predictQuantizationEventTimeEarliest--"><code>predictQuantizationEventTimeEarliest()</code></a>.
 Then, at each time step,
 <ol>
 <li> Advance to the current simulation time by calling <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#advanceToTime-ptolemy.actor.util.Time-"><code>advanceToTime(Time)</code></a>.
      This will return a list of state indexes that experience a quantization event
      at the new simulation time, and you can retrieve the new values of those
      state variables using <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getStateModel-int-"><code>getStateModel(int)</code></a>.
 <li> Then set input values by updating the models returned by
      <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getInputVariableModel-int-"><code>getInputVariableModel(int)</code></a>.</li>
 <li> Finally, trigger rate events using
      <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerRateEvent--"><code>triggerRateEvent()</code></a>.</li>
 </ol>
 At this point, you can determine the next time at which a quantization event
 will occur by calling <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#predictQuantizationEventTimeEarliest--"><code>predictQuantizationEventTimeEarliest()</code></a>.
 That should be the time of the next time step.

 <p>The following methods initialize a new integrator.
 They must be called before doing any work with the integrator:</p>
 <ul>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#initializeDerivativeFunction-org.ptolemy.qss.util.DerivativeFunction-"><code>initializeDerivativeFunction(DerivativeFunction)</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#initializeSimulationTime-ptolemy.actor.util.Time-"><code>initializeSimulationTime(Time)</code></a></li>
 </ul>

 <p>The following methods inquire about fixed integrator parameters:</p>
 <ul>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getStateCount--"><code>getStateCount()</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getInputVariableCount--"><code>getInputVariableCount()</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getStateModelOrder--"><code>getStateModelOrder()</code></a></li>
 </ul>

 <p>The following methods set up the exchange of models between an integrator
 and the rest of the simulation environment.
 In general, they should be called before starting a simulation.
 However, they may also be called during an integration:</p>
 <ul>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getStateModel-int-"><code>getStateModel(int)</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#needInputVariableModelIndex--"><code>needInputVariableModelIndex()</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setInputVariableModel-int-org.ptolemy.qss.util.ModelPolynomial-"><code>setInputVariableModel(int, ModelPolynomial)</code></a></li>
 </ul>

 <p>The following methods configure the integrator.
 In general, they should be called before its first use.
 However, they may also be called during an integration:</p>
 <ul>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setQuantizationTolerance-int-double-double-"><code>setQuantizationTolerance(int, double, double)</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setQuantizationTolerances-double-double-"><code>setQuantizationTolerances(double, double)</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setCurrentSimulationTime-ptolemy.actor.util.Time-"><code>setCurrentSimulationTime(Time)</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setStateValue-int-double-"><code>setStateValue(int, double)</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setQuantizationEventTimeMaximum-ptolemy.actor.util.Time-"><code>setQuantizationEventTimeMaximum(Time)</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#validate--"><code>validate()</code></a></li>
 </ul>

 <p>The following methods inquire about current values during a simulation:</p>
 <ul>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getCurrentSimulationTime--"><code>getCurrentSimulationTime()</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#evaluateStateModel-int-ptolemy.actor.util.Time-"><code>evaluateStateModel(int, Time)</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#evaluateStateModelContinuous-int-ptolemy.actor.util.Time-"><code>evaluateStateModelContinuous(int, Time)</code></a></li>
 </ul>

 <p>The following methods prepare the integrator to take the next time step:</p>
 <ul>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#needQuantizationEventIndex--"><code>needQuantizationEventIndex()</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#needQuantizationEventIndexes-boolean:A-"><code>needQuantizationEventIndexes(boolean[])</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerQuantizationEvent-int-"><code>triggerQuantizationEvent(int)</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerQuantizationEvents-boolean-"><code>triggerQuantizationEvents(boolean)</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#needRateEvent--"><code>needRateEvent()</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerRateEvent--"><code>triggerRateEvent()</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#predictQuantizationEventTime-int-"><code>predictQuantizationEventTime(int)</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#predictQuantizationEventTimeEarliest--"><code>predictQuantizationEventTimeEarliest()</code></a></li>
 </ul>

 <p>The following methods take a time step:</p>
 <ul>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#stepToTime-ptolemy.actor.util.Time-"><code>stepToTime(Time)</code></a></li>
 </ul>

 <p>The following methods primarily facilitate testing:</p>
 <ul>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#stringifyStateModel-int-"><code>stringifyStateModel(int)</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#stringifyStateModelContinuous-int-"><code>stringifyStateModelContinuous(int)</code></a></li>
 <li><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#findQuantum-int-"><code>findQuantum(int)</code></a></li>
 </ul>

 <p>TODO: Describe the general time-stepping model.
 Steps only accomplished via method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#stepToTime-ptolemy.actor.util.Time-"><code>stepToTime(Time)</code></a>.
 All other methods elaborate on what happens between time steps.</p>

 <p>The abstract methods that each subclass must fill in have names ending
 in <code>_work</code>.
 This is meant to help distinguish them from the general entry-points
 provided by this base class.</p>


 <h2>References</h2>
 <ol>
 <li> [Kofman-Junco-2001].
 Kofman, E. and S. Junco (2001). "Quantized-State Systems:
 A {DEVS} Approach for Continuous System Simulation."
 Trans. of The Society for Modeling and Simulation International 18(1): 2-8.</li>

 <li> [Kofman-2002].
 Ernesto Kofman,
 "A second-order approximation for DEVS simulation of continuous systems",
 Simulation, v.78, n.2, pp.76-89, 2002.</li>

 <li> [Cellier-2006].
 Francois E. Cellier and Ernesto Kofman,
 "Continuous System Simulation",
 Springer, 2006.</li>

 <li> [Migoni-2009].
 G. Migoni and E. Kofman,
 "Linearly implicit discrete event methods for stiff ODE's",
 Latin American Applied Research, v.39, pp.245-254, 2009.</li>

 <li> Floros, X., et al. (2010). "Discretizing Time or States?
 A Comparative Study between DASSL and QSS - Work in Progress Paper,"
 Workshop on Equation-Based Object-Oriented Modeling Languages and Tools (EOOLT),
 Oslo, Norway, Linkoping University.</li>

 <li> [Migoni-2013].
 Gustavo Migoni, Mario Bortolotto, Ernesto Kofman, and Francois E. Cellier,
 "Linearly implicit quantization-based integration methods for stiff ordinary
 differential equations",
 Simulation Modelling Practice and Theory, v.35, pp.118-136, 2013.</li>

 </ol></div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Ptolemy II 10.2  // FIXME: Check version number.</dd>
<dt><span class="simpleTagLabel">Version:</span></dt>
<dd>$Id$</dd>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>David M. Lorenzetti, Contributor: Thierry S. Nouidui, Edward A. Lee</dd>

<DT><B>Accepted Rating:</B><DD><table cellpadding=2 cellspacing=0><tr><td bgcolor="red">red (reviewmoderator)  // FIXME: Fill in.</td></tr></table></DD>

<DT><B>Proposed Rating:</B><DD><table cellpadding=2 cellspacing=0><tr><td bgcolor="red">red (dmlorenzetti)</td></tr></table></DD>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_cStateModels">_cStateModels</a></span></code>
<div class="block">Internal continuous state models.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_currSimTime">_currSimTime</a></span></code>
<div class="block">The simulation time of the last call.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../../../org/ptolemy/qss/util/DerivativeFunction.html" title="interface in org.ptolemy.qss.util">DerivativeFunction</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_derivFcn">_derivFcn</a></span></code>
<div class="block">Derivative function.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected double[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_dqs">_dqs</a></span></code>
<div class="block">Quanta.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_evtIndCt">_evtIndCt</a></span></code>
<div class="block">The event indicator count.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_exactInputs">_exactInputs</a></span></code>
<div class="block">Flag indicating that the solver should assume that inputs are exact,
 meaning that if derivatives are zero, then they are genuinely zero,
 not just unknown.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_ivCt">_ivCt</a></span></code>
<div class="block">The count of input variables.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_ivModels">_ivModels</a></span></code>
<div class="block">Input variables.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_qStateModels">_qStateModels</a></span></code>
<div class="block">External, quantized state models.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_quantEvtTimeMax">_quantEvtTimeMax</a></span></code>
<div class="block">Maximum Time for predicted quantization-event times.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_stateCt">_stateCt</a></span></code>
<div class="block">The state count.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#QSSBase--">QSSBase</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>protected abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_initializeWorker--">_initializeWorker</a></span>()</code>
<div class="block">Initialize object fields (QSS-specific).</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>protected static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_predictQuantizationEventDeltaTimeQSS2General-org.ptolemy.qss.util.ModelPolynomial-org.ptolemy.qss.util.ModelPolynomial-double-boolean-">_predictQuantizationEventDeltaTimeQSS2General</a></span>(<a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;qStateModel,
                                             <a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;cStateModel,
                                             double&nbsp;dq,
                                             boolean&nbsp;exactInputs)</code>
<div class="block">Get the delta-time to the predicted quantization-event for a state under QSS2.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>protected static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_predictQuantizationEventDeltaTimeQSS2QFromC-org.ptolemy.qss.util.ModelPolynomial-org.ptolemy.qss.util.ModelPolynomial-double-boolean-">_predictQuantizationEventDeltaTimeQSS2QFromC</a></span>(<a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;qStateModel,
                                            <a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;cStateModel,
                                            double&nbsp;dq,
                                            boolean&nbsp;exactInputs)</code>
<div class="block">Get the delta-time to the predicted quantization-event for a state under QSS2.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>protected static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_predictQuantizationEventDeltaTimeQSS3General-org.ptolemy.qss.util.ModelPolynomial-org.ptolemy.qss.util.ModelPolynomial-double-">_predictQuantizationEventDeltaTimeQSS3General</a></span>(<a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;qStateModel,
                                             <a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;cStateModel,
                                             double&nbsp;dq)</code>
<div class="block">Get the delta-time to the predicted quantization-event for a state under QSS3.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>protected static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_predictQuantizationEventDeltaTimeQSS3QFromC-org.ptolemy.qss.util.ModelPolynomial-org.ptolemy.qss.util.ModelPolynomial-double-boolean-">_predictQuantizationEventDeltaTimeQSS3QFromC</a></span>(<a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;qStateModel,
                                            <a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;cStateModel,
                                            double&nbsp;dq,
                                            boolean&nbsp;exactInputs)</code>
<div class="block">Get the delta-time to the predicted quantization-event for a state under QSS3.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>protected abstract <a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_predictQuantizationEventTimeWorker-int-ptolemy.actor.util.Time-">_predictQuantizationEventTimeWorker</a></span>(int&nbsp;stateIdx,
                                   <a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;quantEvtTimeMax)</code>
<div class="block">Get the predicted quantization-event time for a state (QSS-specific).</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>protected abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_triggerQuantizationEventWorker-int-">_triggerQuantizationEventWorker</a></span>(int&nbsp;stateIdx)</code>
<div class="block">Form a new external, quantized state model (QSS-specific).</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>protected abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_triggerRateEventWorker--">_triggerRateEventWorker</a></span>()</code>
<div class="block">Form new internal, continuous state models (QSS-specific).</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>protected abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_triggerRateEventWorkerEventDetection--">_triggerRateEventWorkerEventDetection</a></span>()</code>
<div class="block">Form new internal, continuous state models (QSS-specific).</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;java.lang.Integer&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#advanceToTime-ptolemy.actor.util.Time-">advanceToTime</a></span>(<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;nextSimTime)</code>
<div class="block">Advance simulation time to the specified time.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#evaluateStateModel-int-ptolemy.actor.util.Time-">evaluateStateModel</a></span>(int&nbsp;stateIdx,
                  <a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;simTime)</code>
<div class="block">Get the value of a state variable.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#evaluateStateModelContinuous-int-ptolemy.actor.util.Time-">evaluateStateModelContinuous</a></span>(int&nbsp;stateIdx,
                            <a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;simTime)</code>
<div class="block">Get the internal value of a state variable.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#findQuantum-int-">findQuantum</a></span>(int&nbsp;stateIdx)</code>
<div class="block">Find the quantum for a state.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code><a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getCurrentSimulationTime--">getCurrentSimulationTime</a></span>()</code>
<div class="block">Get the current simulation time for the QSS integrator.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getEventIndicatorCount--">getEventIndicatorCount</a></span>()</code>
<div class="block">Return the count of event indicators.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getExactInputs--">getExactInputs</a></span>()</code>
<div class="block">Return whether inputs are assumed to be exact.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getInputVariableCount--">getInputVariableCount</a></span>()</code>
<div class="block">Return the count of input variables to the integrator.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code><a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getInputVariableModel-int-">getInputVariableModel</a></span>(int&nbsp;input)</code>
<div class="block">Return the input variable model for the specified index.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getStateCount--">getStateCount</a></span>()</code>
<div class="block">Return the count of states predicted by the integrator.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code><a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getStateModel-int-">getStateModel</a></span>(int&nbsp;stateIdx)</code>
<div class="block">Get the external, quantized state model for a state predicted by the integrator.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>abstract int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getStateModelOrder--">getStateModelOrder</a></span>()</code>
<div class="block">Get the order of the external, quantized state models exposed by the integrator.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#initialize-org.ptolemy.qss.util.DerivativeFunction-ptolemy.actor.util.Time-ptolemy.actor.util.Time-double-double-int-">initialize</a></span>(<a href="../../../../org/ptolemy/qss/util/DerivativeFunction.html" title="interface in org.ptolemy.qss.util">DerivativeFunction</a>&nbsp;derivativeFunction,
          <a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;startTime,
          <a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;maximumTime,
          double&nbsp;absoluteTolerance,
          double&nbsp;relativeTolerance,
          int&nbsp;inputVariableOrder)</code>
<div class="block">Initialize this solver, associating it with the specified
  derivativeFunction object, which determines the number of state
  variables and input variables and provides a method for calculating
  the derivatives of the state variables.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#initializeDerivativeFunction-org.ptolemy.qss.util.DerivativeFunction-">initializeDerivativeFunction</a></span>(<a href="../../../../org/ptolemy/qss/util/DerivativeFunction.html" title="interface in org.ptolemy.qss.util">DerivativeFunction</a>&nbsp;derivFcn)</code>
<div class="block">Initialize a QSS integrator to use a <a href="../../../../org/ptolemy/qss/util/DerivativeFunction.html" title="interface in org.ptolemy.qss.util"><code>DerivativeFunction</code></a> object.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#initializeDerivativeFunction-org.ptolemy.qss.util.DerivativeFunction-int-">initializeDerivativeFunction</a></span>(<a href="../../../../org/ptolemy/qss/util/DerivativeFunction.html" title="interface in org.ptolemy.qss.util">DerivativeFunction</a>&nbsp;derivFcn,
                            int&nbsp;numEvtInds)</code>
<div class="block">Initialize a QSS integrator to use a <a href="../../../../org/ptolemy/qss/util/DerivativeFunction.html" title="interface in org.ptolemy.qss.util"><code>DerivativeFunction</code></a> object.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#initializeSimulationTime-ptolemy.actor.util.Time-">initializeSimulationTime</a></span>(<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;initSimTime)</code>
<div class="block">Initialize a QSS integrator with an initial time.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code><a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#minimumTime-ptolemy.actor.util.Time-ptolemy.actor.util.Time-">minimumTime</a></span>(<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;time1,
           <a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;time2)</code>
<div class="block">Compare and return the smalltest time between two time objects.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#needInputVariableModelIndex--">needInputVariableModelIndex</a></span>()</code>
<div class="block">Return the index of an input variable for which the user has yet to add a model.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#needQuantizationEventIndex--">needQuantizationEventIndex</a></span>()</code>
<div class="block">Return the first index of a state that needs a quantization-event.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#needQuantizationEventIndexes-boolean:A-">needQuantizationEventIndexes</a></span>(boolean[]&nbsp;needQuantEvtIdxs)</code>
<div class="block">Return array of booleans indicating all states that need a quantization-event.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#needRateEvent--">needRateEvent</a></span>()</code>
<div class="block">Determine whether the integrator needs a rate-event.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code><a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#predictQuantizationEventTime-int-">predictQuantizationEventTime</a></span>(int&nbsp;stateIdx)</code>
<div class="block">Get the predicted quantization-event time for a state.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code><a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#predictQuantizationEventTimeEarliest--">predictQuantizationEventTimeEarliest</a></span>()</code>
<div class="block">Get the earliest predicted quantization-event time for all states.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code><a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#predictQuantizationEventTimeEarliest-boolean:A-">predictQuantizationEventTimeEarliest</a></span>(boolean[]&nbsp;quantEvtElts)</code>
<div class="block">Get the earliest predicted quantization-event time for all states.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setCurrentSimulationTime-ptolemy.actor.util.Time-">setCurrentSimulationTime</a></span>(<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;newSimTime)</code>
<div class="block">Set or reset the integrator's current time.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setExactInputs-boolean-">setExactInputs</a></span>(boolean&nbsp;exact)</code>
<div class="block">Indicate whether inputs are exact.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setInputVariableModel-int-org.ptolemy.qss.util.ModelPolynomial-">setInputVariableModel</a></span>(int&nbsp;ivIdx,
                     <a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;ivModel)</code>
<div class="block">Set the model for an input variable to the derivative function.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setNumberOfEventIndicators-int-">setNumberOfEventIndicators</a></span>(int&nbsp;numberEventIndicators)</code>
<div class="block">Set the number of event indicators.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setQuantizationEventTimeMaximum-ptolemy.actor.util.Time-">setQuantizationEventTimeMaximum</a></span>(<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;quantEvtTimeMax)</code>
<div class="block">Reset the maximum time for predicted quantization-events.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setQuantizationTolerance-int-double-double-">setQuantizationTolerance</a></span>(int&nbsp;stateIndex,
                        double&nbsp;absoluteTolerance,
                        double&nbsp;relativeTolerance)</code>
<div class="block">Set the parameters used to determine the quantum for a state.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setQuantizationTolerances-double-double-">setQuantizationTolerances</a></span>(double&nbsp;absoluteTolerance,
                         double&nbsp;relativeTolerance)</code>
<div class="block">Set the parameters used to determine the quantum for all states.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setStateValue-int-double-">setStateValue</a></span>(int&nbsp;stateIdx,
             double&nbsp;newValue)</code>
<div class="block">Set the value of a state variable.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#stepToTime-ptolemy.actor.util.Time-">stepToTime</a></span>(<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;nextSimTime)</code>
<div class="block">Step to the next knot in the global simulation.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#stepToTime-ptolemy.actor.util.Time-int-">stepToTime</a></span>(<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;nextSimTime,
          int&nbsp;numberEventIndicators)</code>
<div class="block">Step to the next knot in the global simulation for event detection.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#stringifyStateModel-int-">stringifyStateModel</a></span>(int&nbsp;stateIdx)</code>
<div class="block">Get a string representation of the model for a state.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#stringifyStateModelContinuous-int-">stringifyStateModelContinuous</a></span>(int&nbsp;stateIdx)</code>
<div class="block">Get a string representation of the internal model for a state.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerQuantizationEvent-int-">triggerQuantizationEvent</a></span>(int&nbsp;stateIdx)</code>
<div class="block">Form a new external, quantized state model.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerQuantizationEvents-boolean-">triggerQuantizationEvents</a></span>(boolean&nbsp;forceAll)</code>
<div class="block">Form new external, quantized state models.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerRateEvent--">triggerRateEvent</a></span>()</code>
<div class="block">Form new internal, continuous state models.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerRateEvent-int-">triggerRateEvent</a></span>(int&nbsp;numberEventIndicators)</code>
<div class="block">Form new internal, continuous state models.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#validate--">validate</a></span>()</code>
<div class="block">Validate the QSS integrator has been properly set up.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="Z:Z_exactInputs">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_exactInputs</h4>
<pre>protected&nbsp;boolean _exactInputs</pre>
<div class="block">Flag indicating that the solver should assume that inputs are exact,
 meaning that if derivatives are zero, then they are genuinely zero,
 not just unknown.</div>
</li>
</ul>
<a name="Z:Z_derivFcn">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_derivFcn</h4>
<pre>protected&nbsp;<a href="../../../../org/ptolemy/qss/util/DerivativeFunction.html" title="interface in org.ptolemy.qss.util">DerivativeFunction</a> _derivFcn</pre>
<div class="block">Derivative function.</div>
</li>
</ul>
<a name="Z:Z_stateCt">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_stateCt</h4>
<pre>protected&nbsp;int _stateCt</pre>
<div class="block">The state count.</div>
</li>
</ul>
<a name="Z:Z_evtIndCt">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_evtIndCt</h4>
<pre>protected&nbsp;int _evtIndCt</pre>
<div class="block">The event indicator count.</div>
</li>
</ul>
<a name="Z:Z_ivCt">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_ivCt</h4>
<pre>protected&nbsp;int _ivCt</pre>
<div class="block">The count of input variables.</div>
</li>
</ul>
<a name="Z:Z_cStateModels">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_cStateModels</h4>
<pre>protected&nbsp;<a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>[] _cStateModels</pre>
<div class="block">Internal continuous state models.</div>
</li>
</ul>
<a name="Z:Z_qStateModels">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_qStateModels</h4>
<pre>protected&nbsp;<a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>[] _qStateModels</pre>
<div class="block">External, quantized state models.</div>
</li>
</ul>
<a name="Z:Z_ivModels">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_ivModels</h4>
<pre>protected&nbsp;<a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>[] _ivModels</pre>
<div class="block">Input variables.</div>
</li>
</ul>
<a name="Z:Z_dqs">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_dqs</h4>
<pre>protected&nbsp;double[] _dqs</pre>
<div class="block">Quanta.</div>
</li>
</ul>
<a name="Z:Z_currSimTime">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_currSimTime</h4>
<pre>protected&nbsp;<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a> _currSimTime</pre>
<div class="block">The simulation time of the last call.</div>
</li>
</ul>
<a name="Z:Z_quantEvtTimeMax">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>_quantEvtTimeMax</h4>
<pre>protected&nbsp;<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a> _quantEvtTimeMax</pre>
<div class="block">Maximum Time for predicted quantization-event times.</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="QSSBase--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>QSSBase</h4>
<pre>public&nbsp;QSSBase()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="advanceToTime-ptolemy.actor.util.Time-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>advanceToTime</h4>
<pre>public final&nbsp;java.util.List&lt;java.lang.Integer&gt;&nbsp;advanceToTime(<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;nextSimTime)
                                                      throws java.lang.Exception</pre>
<div class="block">Advance simulation time to the specified time.
  This is a convenience method that encapsulates a typical usage pattern
  of the other methods in this class and provides more error checking.
  This method will trigger rate events and quantization events if necessary.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nextSimTime</code> - Global simulation time to which to step.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A list of indexes of states for which new time matches
   a quantization event, or an empty list if there are none.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If the specified time is not
   strictly greater than the current simulation time, or if the
   specified time is past the next event time, or if
   there are states requiring a quantization event.</dd>
<dd><code>java.lang.Exception</code> - If triggering a rate event causes an error
   (this is dependent on the concrete implementation of this class).</dd>
</dl>
</li>
</ul>
<a name="evaluateStateModel-int-ptolemy.actor.util.Time-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>evaluateStateModel</h4>
<pre>public final&nbsp;double&nbsp;evaluateStateModel(int&nbsp;stateIdx,
                                       <a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;simTime)</pre>
<div class="block">Get the value of a state variable.

 <p>Evaluate the external, quantized state model at a specified time.</p>

 <p>Note this method evaluates the external, quantized state model.
 Alternately, the user could acquire the model, via
 method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getStateModel-int-"><code>getStateModel(int)</code></a>, and evaluate that model directly.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stateIdx</code> - The state index, 0 &lt;= stateIdx &lt; this.getStateCt().</dd>
<dd><code>simTime</code> - Global simulation time.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Value of the state model at <code>simTime</code>.</dd>
</dl>
</li>
</ul>
<a name="evaluateStateModelContinuous-int-ptolemy.actor.util.Time-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>evaluateStateModelContinuous</h4>
<pre>public final&nbsp;double&nbsp;evaluateStateModelContinuous(int&nbsp;stateIdx,
                                                 <a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;simTime)</pre>
<div class="block">Get the internal value of a state variable.

 <p>Evaluate the internal, continuous state model at a specified time.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stateIdx</code> - The state index, 0 &lt;= stateIdx &lt; this.getStateCt().</dd>
<dd><code>simTime</code> - Global simulation time.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Value of the state model at <code>simTime</code>.</dd>
</dl>
</li>
</ul>
<a name="findQuantum-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findQuantum</h4>
<pre>public final&nbsp;double&nbsp;findQuantum(int&nbsp;stateIdx)</pre>
<div class="block">Find the quantum for a state.

 <p>Finds the quantum, i.e., the maximum allowable difference between
 the external, quantized state model shared with the user, and the
 internal, continuous state model used by the integrator.</p>

 <p>To change the parameters used to find the quantum, use
 method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setQuantizationTolerance-int-double-double-"><code>setQuantizationTolerance(int, double, double)</code></a>
 or method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setQuantizationTolerances-double-double-"><code>setQuantizationTolerances(double, double)</code></a>.</p>

 <p>The user should never have to call this method directly.
 The QSS integrator invokes it as needed.</p>


 <h2>Implementation notes</h2>

 <p>This method does not store the quantum calculated.
 The QSS integrator is expected to take care of this.</p>

 <p>The nominal policy is to find the quantum whenever the
 external, quantized state model gets updated.
 This is because, as calculated here, the quantum depends on the constant
 coefficient of the external, quantized state model.</p>

 <p>In principle, the quantum could be based on the current value of the
 one of the state models, calculated at the time the quantum is needed.
 This differs from the policy outlined above, in that the current value
 of a state generally differs from its constant coefficient.</p>

 <p>However, this more complicated policy would induce a lot of mostly
 needless calculations.
 If the external, quantized state changes by a large amount, but still
 tracks the internal, continuous state model well, then the quantum for
 this element doesn't matter much.
 If, on the other hand, the two models don't agree, then there will be a
 quantization-event, which will trigger a new call of this method.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stateIdx</code> - The state index, 0 &lt;= stateIdx &lt; this.getStateCt().</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Quantum for the state variable.</dd>
</dl>
</li>
</ul>
<a name="getCurrentSimulationTime--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCurrentSimulationTime</h4>
<pre>public final&nbsp;<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;getCurrentSimulationTime()</pre>
<div class="block">Get the current simulation time for the QSS integrator.

 <p>This is generally the last global simulation time for which
 method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#stepToTime-ptolemy.actor.util.Time-"><code>stepToTime(Time)</code></a> was called.
 Exceptions:</p>
 <ul>
 <li>When the integrator is first instantiated, it is set to 0.</li>
 <li>Method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setCurrentSimulationTime-ptolemy.actor.util.Time-"><code>setCurrentSimulationTime(Time)</code></a> changes the value outright.</li>
 </ul></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Current simulation time for the QSS integrator.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setCurrentSimulationTime-ptolemy.actor.util.Time-"><code>setCurrentSimulationTime(Time)</code></a></dd>
</dl>
</li>
</ul>
<a name="getEventIndicatorCount--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getEventIndicatorCount</h4>
<pre>public final&nbsp;int&nbsp;getEventIndicatorCount()</pre>
<div class="block">Return the count of event indicators.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Count of event indicators.</dd>
</dl>
</li>
</ul>
<a name="getExactInputs--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExactInputs</h4>
<pre>public final&nbsp;boolean&nbsp;getExactInputs()</pre>
<div class="block">Return whether inputs are assumed to be exact. By default, they are not,
  but if you call <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setExactInputs-boolean-"><code>setExactInputs(boolean)</code></a> with argument true,
  then this will return true. A true value
  asserts that all non-zero derivatives of the input model are provided.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True to indicate that inputs are assumed exact, or false otherwise.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setExactInputs-boolean-"><code>setExactInputs(boolean)</code></a></dd>
</dl>
</li>
</ul>
<a name="getInputVariableCount--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInputVariableCount</h4>
<pre>public final&nbsp;int&nbsp;getInputVariableCount()</pre>
<div class="block">Return the count of input variables to the integrator.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Count of input variables.</dd>
</dl>
</li>
</ul>
<a name="getInputVariableModel-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInputVariableModel</h4>
<pre>public final&nbsp;<a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;getInputVariableModel(int&nbsp;input)</pre>
<div class="block">Return the input variable model for the specified index.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>input</code> - The index of the input variable.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the input variable model for the specified index.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setInputVariableModel-int-org.ptolemy.qss.util.ModelPolynomial-"><code>setInputVariableModel(int, ModelPolynomial)</code></a></dd>
</dl>
</li>
</ul>
<a name="getStateCount--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getStateCount</h4>
<pre>public final&nbsp;int&nbsp;getStateCount()</pre>
<div class="block">Return the count of states predicted by the integrator.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Count of states.</dd>
</dl>
</li>
</ul>
<a name="getStateModel-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getStateModel</h4>
<pre>public final&nbsp;<a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;getStateModel(int&nbsp;stateIdx)</pre>
<div class="block">Get the external, quantized state model for a state predicted by the integrator.

 <p>The QSS integrator uses this model to share the predicted state as a
 function of time, when integrating the derivative function.</p>

 <p>The initial state model is constant at a value of 0.
 Use method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setStateValue-int-double-"><code>setStateValue(int, double)</code></a> to change this initial value.</p>

 <p>Never change the model parameters directly.
 The QSS integrator claims exclusive write access to the model.</p>


 <h2>Details</h2>

 <p>Notes on "write access" for the state model:</p>
 <ul>
 <li>"Write access" on a model means that some object has asserted that
 it plans to change the parameters of the <code>ModelPoly</code>.
 This means it will control the trajectory of that model over time.
 See method ModelPoly.claimWriteAccess().</li>
 <li>The QSS integrator will change the model parameters as it integrates
 the derivative function.
 Therefore the integrator asserts write access on its own state models.</li>
 <li>The QSS integrator requires exclusive write access on its own
 state models.
 In order for the integrator to run, every state model must have exactly
 one claim of "write access" made against it.
 Therefore the user must not assert write access on any state model.</li>
 <li>The user should <em>never</em> write new parameters to the
 state model.</li>
 <li>The user should call method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setStateValue-int-double-"><code>setStateValue(int, double)</code></a>, in order
 to initialize the state, <em>before</em> starting the integration.</li>
 </ul>

 <p>Notes on sharing models between roles in the integration:</p>
 <ul>
 <li>It is legal to use a state model as an input variable model of one
 or more QSS integrators.
 The model can even be added as an input variable model of the same
 integrator for which it is a state model (although this should be
 unusual).</li>
 <li>It is legal to add the same model to multiple input variables.</li>
 </ul>


 <h2>Design intent</h2>

 <p>The design intention behind exposing the state models directly to the
 rest of the system is to make sharing state predictions as cheap as
 possible.</p>

 <p>From an encapsulation viewpoint, the integrator does not have to
 expose its state models to the rest of the simulation.
 It could, instead, force the user to evaluate the quantized state models
 using method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#evaluateStateModel-int-ptolemy.actor.util.Time-"><code>evaluateStateModel(int, Time)</code></a>.
 Alternately, it could copy the quantized state model to a user-supplied
 model object, thus keeping the integrator's private copy hidden.
 However, both these approaches are relatively high overhead, compared
 to simply exposing the model for the user to evaluate as needed.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stateIdx</code> - The state index, 0 &le; stateIdx &lt; this.getStateCt().</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the external, quantized state model for a state predicted by the integrator.</dd>
</dl>
</li>
</ul>
<a name="getStateModelOrder--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getStateModelOrder</h4>
<pre>public abstract&nbsp;int&nbsp;getStateModelOrder()</pre>
<div class="block">Get the order of the external, quantized state models exposed by the integrator.

 <p>This method returns the order of the <a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util"><code>ModelPolynomial</code></a> objects
 that the integrator exposes to the user.</p>

 <p>These states are the quantized state predictions (as opposed to the
 continuous state predictions the integrator uses internally).
 Therefore the order is <em>one less</em> than the nominal order of the
 QSS method.</p>

 <p>For example, QSS1 uses a first-order (linear) polynomial to model each
 state variable.
 However, it does not expose that internal representation to the user.
 The external, quantized, representation of the state is a constant (i.e.,
 a 0th-order polynomial).
 Therefore QSS1 should return <code>0</code> for this method.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Order of the external, quantized state models.</dd>
</dl>
</li>
</ul>
<a name="initialize-org.ptolemy.qss.util.DerivativeFunction-ptolemy.actor.util.Time-ptolemy.actor.util.Time-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initialize</h4>
<pre>public final&nbsp;void&nbsp;initialize(<a href="../../../../org/ptolemy/qss/util/DerivativeFunction.html" title="interface in org.ptolemy.qss.util">DerivativeFunction</a>&nbsp;derivativeFunction,
                             <a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;startTime,
                             <a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;maximumTime,
                             double&nbsp;absoluteTolerance,
                             double&nbsp;relativeTolerance,
                             int&nbsp;inputVariableOrder)</pre>
<div class="block">Initialize this solver, associating it with the specified
  derivativeFunction object, which determines the number of state
  variables and input variables and provides a method for calculating
  the derivatives of the state variables. This method also initializes
  all input and state variables to zero. These can be the initialized
  to some other value by calling <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setStateValue-int-double-"><code>setStateValue(int, double)</code></a> and
  <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setInputVariableModel-int-org.ptolemy.qss.util.ModelPolynomial-"><code>setInputVariableModel(int, ModelPolynomial)</code></a>.
  The caller of this method should then, after setting state and
  input values, call <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerQuantizationEvents-boolean-"><code>triggerQuantizationEvents(boolean)</code></a>
  with argument true.
  <p>
  This is a convenience method wrapping a sequence of calls to
  more detailed methods.
  </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>derivativeFunction</code> - The object implementing the
   function that provides the derivatives for
   state variables that this solver is responsible for integrating.
   This object also provides a method specifying the number of state
   variables and the number of input variables.</dd>
<dd><code>startTime</code> - The start time for the solver.</dd>
<dd><code>maximumTime</code> - The maximum time for predicted events (e.g. the stop
   time of the simulation). This may be infinite.</dd>
<dd><code>absoluteTolerance</code> - The absolute tolerance for all state variables
   (these can be modified later for individual states
   using <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setQuantizationTolerance-int-double-double-"><code>setQuantizationTolerance(int, double, double)</code></a>).</dd>
<dd><code>relativeTolerance</code> - The relative tolerance for all state variables
   (these can be modified later for individual states
   using <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setQuantizationTolerance-int-double-double-"><code>setQuantizationTolerance(int, double, double)</code></a>).</dd>
<dd><code>inputVariableOrder</code> - The order (the number of derivatives provided)
   for each input variable. If these differ by input variable, then the
   caller may later modify the input variable models by calling
   <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setInputVariableModel-int-org.ptolemy.qss.util.ModelPolynomial-"><code>setInputVariableModel(int, ModelPolynomial)</code></a>.</dd>
</dl>
</li>
</ul>
<a name="initializeDerivativeFunction-org.ptolemy.qss.util.DerivativeFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initializeDerivativeFunction</h4>
<pre>public final&nbsp;void&nbsp;initializeDerivativeFunction(<a href="../../../../org/ptolemy/qss/util/DerivativeFunction.html" title="interface in org.ptolemy.qss.util">DerivativeFunction</a>&nbsp;derivFcn)</pre>
<div class="block">Initialize a QSS integrator to use a <a href="../../../../org/ptolemy/qss/util/DerivativeFunction.html" title="interface in org.ptolemy.qss.util"><code>DerivativeFunction</code></a> object.

 <p>This method must be called before doing any work with the integrator.
 Furthermore, it can be called only once.</p>


 <h2>Design intent</h2>

 <p>The derivative function is central to the integrator, and could very
 well be passed to the constructor.
 However, to accommodate a wide range of downstream users, a zero-argument
 constructor was desired.
 Of course, a constructor that takes the derivative function as an
 argument could be provided; it would simply call this method.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>derivFcn</code> - Object that implements the DerivativeFcn interface.</dd>
</dl>
</li>
</ul>
<a name="initializeDerivativeFunction-org.ptolemy.qss.util.DerivativeFunction-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initializeDerivativeFunction</h4>
<pre>public final&nbsp;void&nbsp;initializeDerivativeFunction(<a href="../../../../org/ptolemy/qss/util/DerivativeFunction.html" title="interface in org.ptolemy.qss.util">DerivativeFunction</a>&nbsp;derivFcn,
                                               int&nbsp;numEvtInds)</pre>
<div class="block">Initialize a QSS integrator to use a <a href="../../../../org/ptolemy/qss/util/DerivativeFunction.html" title="interface in org.ptolemy.qss.util"><code>DerivativeFunction</code></a> object.

 <p>This method must be called before doing any work with the integrator.
 Furthermore, it can be called only once. This methods is used to determine
 when zero crossing happen.</p>


 <h2>Design intent</h2>

 <p>The derivative function is central to the integrator, and could very
 well be passed to the constructor.
 However, to accommodate a wide range of downstream users, a zero-argument
 constructor was desired.
 Of course, a constructor that takes the derivative function as an
 argument could be provided; it would simply call this method.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>derivFcn</code> - Object that implements the DerivativeFcn interface.</dd>
<dd><code>numEvtInds</code> - Number of event indicators.</dd>
</dl>
</li>
</ul>
<a name="initializeSimulationTime-ptolemy.actor.util.Time-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initializeSimulationTime</h4>
<pre>public final&nbsp;void&nbsp;initializeSimulationTime(<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;initSimTime)</pre>
<div class="block">Initialize a QSS integrator with an initial time.

 <p>This method must be called before doing any work with the integrator.
 Furthermore, it can be called only once.</p>


 <h2>Design intent</h2>

 <p>For flexibility, the integrator represents time using objects of
 class <code>Time</code> (rather than, for example, a more
 traditional double-precision variable).
 This leaves the implementation open to the user.
 However, it also means that the integrator cannot assume an exact
 form of constructor for creating <code>Time</code> objects.
 Therefore the user has to construct and provide the initial time.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>initSimTime</code> - The initial time.</dd>
</dl>
</li>
</ul>
<a name="minimumTime-ptolemy.actor.util.Time-ptolemy.actor.util.Time-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>minimumTime</h4>
<pre>public final&nbsp;<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;minimumTime(<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;time1,
                              <a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;time2)</pre>
<div class="block">Compare and return the smalltest time between two time objects.

 TODO: Get this method under unit test.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>time1</code> - Time object.</dd>
<dd><code>time2</code> - Time object.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The smallest time.</dd>
</dl>
</li>
</ul>
<a name="needInputVariableModelIndex--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>needInputVariableModelIndex</h4>
<pre>public final&nbsp;int&nbsp;needInputVariableModelIndex()</pre>
<div class="block">Return the index of an input variable for which the user has yet to add a model.

 <p>The user must call <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setInputVariableModel-int-org.ptolemy.qss.util.ModelPolynomial-"><code>setInputVariableModel(int, ModelPolynomial)</code></a> at least once for
 every input variable taken by the derivative function.
 This method checks whether that requirement has been met.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Index of an input variable for which the user has yet to add a
   model, 0 &le; idx &le; this.getArgCt().  Return -1 if all models have been
   added (or if the derivative function takes no input variables).</dd>
</dl>
</li>
</ul>
<a name="needQuantizationEventIndex--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>needQuantizationEventIndex</h4>
<pre>public final&nbsp;int&nbsp;needQuantizationEventIndex()</pre>
<div class="block">Return the first index of a state that needs a quantization-event.
 This method can be called after <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#stepToTime-ptolemy.actor.util.Time-"><code>stepToTime(Time)</code></a> repeatedly
 to iterate over the states on which <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerQuantizationEvent-int-"><code>triggerQuantizationEvent(int)</code></a>
 should be called. See <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#advanceToTime-ptolemy.actor.util.Time-"><code>advanceToTime(Time)</code></a> for a typical usage
 pattern.
 <p>
 The integrator tracks which states need a quantization-event as a
 result of a time step.
 This method returns the index, if any, of such states.
 </p><p>
 The user should trigger the quantization-event, e.g., using
 method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerQuantizationEvent-int-"><code>triggerQuantizationEvent(int)</code></a>.
 </p><p>
 TODO: Put under unit test.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Index of a state that needs a quantization-event,
   0 &lt;= idx &lt; this.getStateCt().  Return -1 if all external, quantized
   state models are valid.</dd>
</dl>
</li>
</ul>
<a name="needQuantizationEventIndexes-boolean:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>needQuantizationEventIndexes</h4>
<pre>public final&nbsp;void&nbsp;needQuantizationEventIndexes(boolean[]&nbsp;needQuantEvtIdxs)</pre>
<div class="block">Return array of booleans indicating all states that need a quantization-event.

 <p>See comments to method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#needQuantizationEventIndex--"><code>needQuantizationEventIndex()</code></a>.</p>

 <p>TODO: Put under unit test.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>needQuantEvtIdxs</code> - (output) Vector showing <code>true</code> for
   each integrator state that needs a quantization-event.</dd>
</dl>
</li>
</ul>
<a name="needRateEvent--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>needRateEvent</h4>
<pre>public final&nbsp;boolean&nbsp;needRateEvent()</pre>
<div class="block">Determine whether the integrator needs a rate-event.

 <p>This method only checks whether the integrator needs a rate-event
 due to a quantization-event.
 The integrator does not track changes in the parameters of its
 input variable models, so the integrator cannot warn of the need to
 trigger a rate-event after an input variable changes.</p>

 TODO: Statement above will change if provide ability to install listeners
 on input variables.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if the integrator needs a rate event.</dd>
</dl>
</li>
</ul>
<a name="predictQuantizationEventTime-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>predictQuantizationEventTime</h4>
<pre>public final&nbsp;<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;predictQuantizationEventTime(int&nbsp;stateIdx)</pre>
<div class="block">Get the predicted quantization-event time for a state.

 TODO: Get this method under unit test.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stateIdx</code> - The state index, 0 &lt;= stateIdx &lt; this.getStateCt().</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Next time at which, in the absence of other events, the
   external state model must be re-formed,
   0 &lt;= time &lt;= Time.POSITIVE_INFINITY.</dd>
</dl>
</li>
</ul>
<a name="predictQuantizationEventTimeEarliest--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>predictQuantizationEventTimeEarliest</h4>
<pre>public final&nbsp;<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;predictQuantizationEventTimeEarliest()</pre>
<div class="block">Get the earliest predicted quantization-event time for all states.

 TODO: Get this method under unit test.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Earliest predicted quantization-event time from among all states
   predicted by the integrator.</dd>
</dl>
</li>
</ul>
<a name="predictQuantizationEventTimeEarliest-boolean:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>predictQuantizationEventTimeEarliest</h4>
<pre>public final&nbsp;<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;predictQuantizationEventTimeEarliest(boolean[]&nbsp;quantEvtElts)</pre>
<div class="block">Get the earliest predicted quantization-event time for all states.

 TODO: Get this method under unit test.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>quantEvtElts</code> - (output) Vector showing <code>true</code> for those
   elements whose predicted quantization-event time is the minimum
   from among all elements.  At least one such element must be marked.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Earliest predicted quantization-event time from among all states
   predicted by the integrator.</dd>
</dl>
</li>
</ul>
<a name="setCurrentSimulationTime-ptolemy.actor.util.Time-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setCurrentSimulationTime</h4>
<pre>public final&nbsp;void&nbsp;setCurrentSimulationTime(<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;newSimTime)</pre>
<div class="block">Set or reset the integrator's current time.
  This method sets flags indicating that a rate event is needed
  and that quantization events are needed for all states.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>newSimTime</code> - New time for the QSS integrator.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getCurrentSimulationTime--"><code>getCurrentSimulationTime()</code></a></dd>
</dl>
</li>
</ul>
<a name="setExactInputs-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setExactInputs</h4>
<pre>public final&nbsp;void&nbsp;setExactInputs(boolean&nbsp;exact)</pre>
<div class="block">Indicate whether inputs are exact. Calling this with a true argument
  asserts that all non-zero derivatives of the input model are provided.
  By default, this solver will assume that a zero value for derivatives
  may simply mean that the derivatives are unknown.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>exact</code> - True to indicate that inputs are exact.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getExactInputs--"><code>getExactInputs()</code></a></dd>
</dl>
</li>
</ul>
<a name="setInputVariableModel-int-org.ptolemy.qss.util.ModelPolynomial-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setInputVariableModel</h4>
<pre>public final&nbsp;void&nbsp;setInputVariableModel(int&nbsp;ivIdx,
                                        <a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;ivModel)</pre>
<div class="block">Set the model for an input variable to the derivative function.

 <p>Add a <a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util"><code>ModelPolynomial</code></a> for an input variable to the
 derivative function.
 The QSS method will use this model to evaluate the input variable as a
 function of time, when integrating the derivative function.</p>

 <p>The user must call this method at least once for every input variable
 taken by the derivative function.
 This must be done before starting the integration.</p>


 <h2>Details</h2>

 <p>Notes on "write access" for the state model:</p>
 <ul>
 <li>"Write access" means that some object has asserted that it plans to
 change the parameters of the <a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util"><code>ModelPolynomial</code></a>.
 This means it will control the trajectory of that model over time.
 See <a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html#claimWriteAccess--"><code>ModelPolynomial.claimWriteAccess()</code></a>.</li>
 <li>The user of each integrator is responsible for setting the parameters
 of each input variable model (i.e., of changing the trajectory of the
 input variable over time).</li>
 <li>That said, it is OK for the user to delegate the task of changing
 the input model parameters to some other agent.
 For example, an input variable can be the state predicted by an
 integrator.</li>
 <li>In order for the integrator to run, every input variable model must
 have exactly one claim of "write access" made against it.
 If the input variable model is also a state model (for this or any other
 QSS integrator), then the QSS integrator will automatically make that
 claim.
 Otherwise, the user may have to make that claim.</li>
 <li>Note that the QSS integrator should never change the parameters of a
 model added as an input variable.
 If it does, this is a bug.</li>
 </ul>

 <p>Notes on selecting the input variable model order:</p>
 <ul>
 <li>The input variable model may have any valid order.</li>
 <li>In particular, its order does not need to match that of the
 QSS method for which it serves as an input variable.</li>
 </ul>

 <p>Notes on sharing models between roles in the integration:</p>
 <ul>
 <li>See the notes for method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getStateModel-int-"><code>getStateModel(int)</code></a>.</li>
 </ul>

 <p>Notes on providing a different model at a later time:</p>
 <ul>
 <li>It is OK to change the input variable model before starting the
 integration (e.g., to change the model's order).</li>
 <li>It is probably <em>not</em> OK to change the model after starting
 the integration.
 That is, even if the integrator appears to work, this capability is not
 a design goal, and may be lost in the future.</li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ivIdx</code> - The index of input variable, 0 &le; ivIdx &lt; this.getInputVarCt().</dd>
<dd><code>ivModel</code> - The model to use.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If the argument is null.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getInputVariableModel-int-"><code>getInputVariableModel(int)</code></a></dd>
</dl>
</li>
</ul>
<a name="setNumberOfEventIndicators-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNumberOfEventIndicators</h4>
<pre>public final&nbsp;void&nbsp;setNumberOfEventIndicators(int&nbsp;numberEventIndicators)</pre>
<div class="block">Set the number of event indicators.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>numberEventIndicators</code> - Number of event indicators.</dd>
</dl>
</li>
</ul>
<a name="setQuantizationTolerance-int-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setQuantizationTolerance</h4>
<pre>public final&nbsp;void&nbsp;setQuantizationTolerance(int&nbsp;stateIndex,
                                           double&nbsp;absoluteTolerance,
                                           double&nbsp;relativeTolerance)</pre>
<div class="block">Set the parameters used to determine the quantum for a state.
 <p>
 The quantum for each state variable gets calculated as
 </p><p>
       q[j] = max{Ta, Tr*abs{x[j]}}
 </p><p>
 <p>where</p>
 <ul>
 <li> q[j] is the quantum for element j,</li>
 <li> Ta is the absoluteTolerance,</li>
 <li> Tr is the relativeTolerance, and </li>
 <li> x[j] is the value of element j the last time a new state
      model was formed.</li>
 </ul>

 <p>This method sets the tolerances used to find the quantum.
 It also updates the quantum to reflect the new tolerances.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stateIndex</code> - The state index, 0 &le; stateIdx &lt; this.getStateCt().</dd>
<dd><code>absoluteTolerance</code> - The absolute tolerance, which is required to be &gt; 0 [units of <i>x[j]</i>].</dd>
<dd><code>relativeTolerance</code> - The relative tolerance, which is required to be &ge; 0 [1].</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If the absolute tolerance is not strictly positive, or
  if the relative tolerance is negative.</dd>
</dl>
</li>
</ul>
<a name="setQuantizationTolerances-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setQuantizationTolerances</h4>
<pre>public final&nbsp;void&nbsp;setQuantizationTolerances(double&nbsp;absoluteTolerance,
                                            double&nbsp;relativeTolerance)</pre>
<div class="block">Set the parameters used to determine the quantum for all states.

 <p>Apply the same tolerances to all the states the integrator predicts.
 For details, see method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#setQuantizationTolerance-int-double-double-"><code>setQuantizationTolerance(int, double, double)</code></a>.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>absoluteTolerance</code> - The absolute tolerance, which is required to be &gt; 0 [units of <i>x[j]</i>].</dd>
<dd><code>relativeTolerance</code> - The relative tolerance, which is required to be &ge; 0 [1].</dd>
</dl>
</li>
</ul>
<a name="setStateValue-int-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setStateValue</h4>
<pre>public final&nbsp;void&nbsp;setStateValue(int&nbsp;stateIdx,
                                double&nbsp;newValue)</pre>
<div class="block">Set the value of a state variable.

 <p>Change the value component of the model for element <i>stateIdx</i>
 of the state vector.
 Note that this re-initializes the integrator for that component.
 That is, it discards any state models that the integrator might have
 formed, and creates a jump discontinuity in the state variable.
 This has the side effect of setting flags indicating that a
 new rate event is needed and that the specified state needs
 a quantization event.</p>


 <h2>Warning</h2>

 <p>The user may be tempted to set the value of the state variable
 directly in the state model, without going through the QSS integrator.
 However, doing so prevents the integrator from making the appropriate
 internal adjustments to the change in state.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stateIdx</code> - The state index, 0 &lt;= stateIdx &lt; this.getStateCt().</dd>
<dd><code>newValue</code> - The new value of x[stateIdx].</dd>
</dl>
</li>
</ul>
<a name="setQuantizationEventTimeMaximum-ptolemy.actor.util.Time-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setQuantizationEventTimeMaximum</h4>
<pre>public final&nbsp;void&nbsp;setQuantizationEventTimeMaximum(<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;quantEvtTimeMax)</pre>
<div class="block">Reset the maximum time for predicted quantization-events.

 <p>The integrator will not predict quantization-event times past this
 time.
 Default value <code>Time.POSITIVE_INFINITY</code>.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>quantEvtTimeMax</code> - The maximum time for predicted quantization-events.</dd>
</dl>
</li>
</ul>
<a name="stepToTime-ptolemy.actor.util.Time-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stepToTime</h4>
<pre>public final&nbsp;void&nbsp;stepToTime(<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;nextSimTime)
                      throws java.lang.Exception</pre>
<div class="block">Step to the next knot in the global simulation.

 <p>Don't complain if stepping past a predicted quantization-event time.
 Just report need to trigger a quantization-event before the next step.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nextSimTime</code> - Global simulation time to which to step,
   nextSimTime &gt; this.getCurrSimTime().</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.Exception</code> - If the simulation time must advance or if
 there are state models waiting to be quantized,</dd>
</dl>
</li>
</ul>
<a name="stepToTime-ptolemy.actor.util.Time-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stepToTime</h4>
<pre>public final&nbsp;void&nbsp;stepToTime(<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;nextSimTime,
                             int&nbsp;numberEventIndicators)
                      throws java.lang.Exception</pre>
<div class="block">Step to the next knot in the global simulation for event detection.

 <p>Don't complain if stepping past a predicted quantization-event time.
 Just report need to trigger a quantization-event before the next step.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nextSimTime</code> - Global simulation time to which to step,
   nextSimTime &gt; this.getCurrSimTime().</dd>
<dd><code>numberEventIndicators</code> - The number of event indicators.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.Exception</code> - If the simulation time must advance or if
 there are state models waiting to be quantized,</dd>
</dl>
</li>
</ul>
<a name="stringifyStateModel-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stringifyStateModel</h4>
<pre>public final&nbsp;java.lang.String&nbsp;stringifyStateModel(int&nbsp;stateIdx)</pre>
<div class="block">Get a string representation of the model for a state.

 <p>Invoke method ModelPoly.toString() on the
 external, quantized state model.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stateIdx</code> - The state index, 0 &lt;= stateIdx &lt; this.getStateCt().</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a string representation of the model for a state.</dd>
</dl>
</li>
</ul>
<a name="stringifyStateModelContinuous-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stringifyStateModelContinuous</h4>
<pre>public final&nbsp;java.lang.String&nbsp;stringifyStateModelContinuous(int&nbsp;stateIdx)</pre>
<div class="block">Get a string representation of the internal model for a state.

 <p>Invoke method ModelPoly.toString() on the
 internal, continuous state model.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stateIdx</code> - The state index, 0 &lt;= stateIdx &lt; this.getStateCt().</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a string representation of the internal model for a state.</dd>
</dl>
</li>
</ul>
<a name="triggerQuantizationEvent-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>triggerQuantizationEvent</h4>
<pre>public final&nbsp;void&nbsp;triggerQuantizationEvent(int&nbsp;stateIdx)</pre>
<div class="block">Form a new external, quantized state model.

 <p>Force the QSS integrator to form a new external, quantized state model
 (i.e., to experience a quantization-event).
 The new model will be available to the user immediately.</p>

 <p>Note method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerQuantizationEvents-boolean-"><code>triggerQuantizationEvents(boolean)</code></a> can requantize multiple
 state models at once, and can requantize only those states that need it.</p>

 <p>Form the model about the current simulation time, as returned by
 method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getCurrentSimulationTime--"><code>getCurrentSimulationTime()</code></a>.</p>

 <p>Note this method can be invoked even if the external, quantized state model
 is still within quantum of the internal, continuous state model.
 The integrator will still update the quantized state model about the
 current time.
 Doing so can only improve the accuracy of the simulation (at the cost
 of some extra processing).</p>

 <p>Note the state model of interest here is the
 external, quantized state model.
 In order to re-form the internal, continuous state model, use
 method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerRateEvent--"><code>triggerRateEvent()</code></a>.</p>

 <p>The proper sequence in which to call method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerRateEvent--"><code>triggerRateEvent()</code></a>
 and method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerQuantizationEvent-int-"><code>triggerQuantizationEvent(int)</code></a> is a fraught topic.
 In general, should requantize all states first, then trigger rate events.
 Also, after triggering a rate event, get the new predicted quantization time.
 TODO: Write up a higher-level description of the problem.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stateIdx</code> - The state index, 0 &lt;= stateIdx &lt; this.getStateCt().</dd>
</dl>
</li>
</ul>
<a name="triggerQuantizationEvents-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>triggerQuantizationEvents</h4>
<pre>public final&nbsp;void&nbsp;triggerQuantizationEvents(boolean&nbsp;forceAll)</pre>
<div class="block">Form new external, quantized state models.

 <p>Convenience method to call method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerQuantizationEvent-int-"><code>triggerQuantizationEvent(int)</code></a> on
 all states predicted by this integrator.</p>

 <p>Can apply only to those states that are marked for requantization,
 or can apply to all states.</p>

 <p>Note that a state gets marked for requantization:</p>
 <ul>
 <li>At initialization.</li>
 <li>When a time step carries the integrator up to, or past, its predicted
 quantization-event time.
 See method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#predictQuantizationEventTime-int-"><code>predictQuantizationEventTime(int)</code></a>.</li>
 <li>TODO: Provide, probably in top-level comments, an overview of when
 an integrator state needs to have a quantization-event.
 Following this list.
 Then just cross-reference that discussion here, and in places like
 description of method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerRateEvent--"><code>triggerRateEvent()</code></a>.</li>
 </ul>

 <p>To determine state(s) that need to be requantized, use either
 method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#needQuantizationEventIndex--"><code>needQuantizationEventIndex()</code></a> or
 method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#needQuantizationEventIndexes-boolean:A-"><code>needQuantizationEventIndexes(boolean[])</code></a>.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>forceAll</code> - If true, requantize all state models.</dd>
</dl>
</li>
</ul>
<a name="triggerRateEvent--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>triggerRateEvent</h4>
<pre>public final&nbsp;void&nbsp;triggerRateEvent()
                            throws java.lang.Exception</pre>
<div class="block">Form new internal, continuous state models.

 <p>Force the QSS integrator to form new internal, continuous state models
 (i.e., to experience a rate-event).
 The rate models also get updated.</p>

 <p>In general, this needs to be done whenever an argument to the
 derivative function has changed.
 A "change" in an argument to the derivative function means a change in
 any of the parameters to an argument's model.
 This may happen, for example, due to a quantization-event in the
 integrator that predicts an argument to this integrator.
 It may also happen due to a change in a boundary condition, for example
 provided by an external file.</p>

 <p>Form the model about the current simulation time, as returned by
 method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#getCurrentSimulationTime--"><code>getCurrentSimulationTime()</code></a>.</p>

 <p>Note this method can be invoked even if no argument to the
 derivative function has had a change in its parameters.
 The integrator will still update the rate and state models about the
 current time.
 Doing so can only improve the accuracy of the simulation (at the cost
 of some extra processing).</p>

 <p>Note the state model of interest here is the
 internal, continuous state model.
 In order to re-form the external, quantized state model, use
 method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerQuantizationEvent-int-"><code>triggerQuantizationEvent(int)</code></a>.</p>

 <p>The proper sequence in which to call method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerRateEvent--"><code>triggerRateEvent()</code></a>
 and method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerQuantizationEvent-int-"><code>triggerQuantizationEvent(int)</code></a> is a fraught topic.
 In general, should requantize all states first, then trigger rate-events.
 Also, after trigger a rate-event, get new predicted quantization-time.
 TODO: Write up a higher-level description of the problem.</p>


 <h2>Implementation notes</h2>

 <p>The way to handle a rate-event varies depending on the particular
 QSS method.
 Therefore this is an abstract method.
 Subclasses are expected take care of the following:</p>
 <ul>
 <li>Reset flags.</li>
 <li>Make consistent with the quantized state model, if there was also
 a quantization-event.
 Assuming that's possible.
 Probably better to phrase this in the inverse-- that method quantize()
 should be sure to refresh the state model, since in this implementation
 a quantization-event implies a rate-event.</li>
 <li>TODO: Finish out this list.</li>
 </ul>

 <p>Note it's tempting to say should that handling a rate-event should
 force a quantization-event if one is needed, before handle any rate-event.
 The logic being that the quantization-event will then induce another
 rate-event that needs to be handled, anyway.
 The problem with that logic is that it imposes a policy on how to deal
 with potential loops in updating cycles.
 Thus it removes the user's ability to control when quantization happens,
 which might be important.
 Of course, if there are no loops, then it is certainly best to requantize
 before finding new rate and state models.
 That's because requantizing, always creates a rate-event (since quantized
 outputs are always arguments to the derivative function).

 TODO: Consider returning integer status, equal to return status of
 the derivative function (which should be zero if successful).  Then get
 rid of the exception.

 TODO: Add a "force" flag so only triggers if needed.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.Exception</code> - If thrown while performing the work defined by
 a specific member of the QSS family.</dd>
</dl>
</li>
</ul>
<a name="triggerRateEvent-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>triggerRateEvent</h4>
<pre>public final&nbsp;void&nbsp;triggerRateEvent(int&nbsp;numberEventIndicators)
                            throws java.lang.Exception</pre>
<div class="block">Form new internal, continuous state models.

 <p>Force the QSS integrator to form new internal, continuous state models
 (i.e., to experience a rate-event).
 The rate models also get updated.</p>

 <p>This method is similar to method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerRateEvent--"><code>triggerRateEvent()</code></a>.
 The only difference is that it calls
 method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_triggerRateEventWorkerEventDetection--"><code>_triggerRateEventWorkerEventDetection()</code></a>
 to detect and handle state events.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>numberEventIndicators</code> - The number of event indicators.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.Exception</code> - If thrown while triggering the rate event.</dd>
</dl>
</li>
</ul>
<a name="validate--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>validate</h4>
<pre>public final&nbsp;java.lang.String&nbsp;validate()</pre>
<div class="block">Validate the QSS integrator has been properly set up.

 <p>This method diagnoses setup problems with the integrator.
 For example, if running the integrator causes a <code>NullPointerException</code>,
 then this method can pinpoint problems originating with the integrator.</p>

 <p>It is <em>not</em> necessary to run this method in order to run the
 integrator.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>`null` if the integrator is ready to be used in a simulation, or
   an error message diagnosing the problem.</dd>
</dl>
</li>
</ul>
<a name="Z:Z_initializeWorker--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_initializeWorker</h4>
<pre>protected abstract&nbsp;void&nbsp;_initializeWorker()</pre>
<div class="block">Initialize object fields (QSS-specific).

 <p>Perform one-time initializations at the beginning of the object
 lifetime.</p>

 <p>The implementation of this "worker" method depends on the
 specific member of the QSS family.</p></div>
</li>
</ul>
<a name="Z:Z_predictQuantizationEventTimeWorker-int-ptolemy.actor.util.Time-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_predictQuantizationEventTimeWorker</h4>
<pre>protected abstract&nbsp;<a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;_predictQuantizationEventTimeWorker(int&nbsp;stateIdx,
                                                            <a href="../../../../ptolemy/actor/util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;quantEvtTimeMax)</pre>
<div class="block">Get the predicted quantization-event time for a state (QSS-specific).

 <p>See comments to method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#predictQuantizationEventTime-int-"><code>predictQuantizationEventTime(int)</code></a>.</p>

 <p>The implementation of this "worker" method depends on the
 specific member of the QSS family.</p>


 <h2>Implementation notes</h2>

 <p>The method should not alter any instance variables.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stateIdx</code> - The state index, 0 &lt;= stateIdx &lt; this.getStateCt().</dd>
<dd><code>quantEvtTimeMax</code> - The maximum time for the return value.  May be
   Time.POSITIVE_INFINITY.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The predicted quantization-event time for a state (QSS-specific).</dd>
</dl>
</li>
</ul>
<a name="Z:Z_predictQuantizationEventDeltaTimeQSS2QFromC-org.ptolemy.qss.util.ModelPolynomial-org.ptolemy.qss.util.ModelPolynomial-double-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_predictQuantizationEventDeltaTimeQSS2QFromC</h4>
<pre>protected static final&nbsp;double&nbsp;_predictQuantizationEventDeltaTimeQSS2QFromC(<a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;qStateModel,
                                                                           <a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;cStateModel,
                                                                           double&nbsp;dq,
                                                                           boolean&nbsp;exactInputs)</pre>
<div class="block">Get the delta-time to the predicted quantization-event for a state under QSS2.

 <p>Utility method for use by <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_predictQuantizationEventTimeWorker-int-ptolemy.actor.util.Time-"><code>_predictQuantizationEventTimeWorker(int, Time)</code></a>.</p>

 <p>Find the time step, from the most recent quantization-event time, of the
 predicted quantization-event for a state under QSS2.
 Assume the quantized state model was derived from the
 continuous state model, and therefore has the same value and slope at
 the quantization-event time.</p>

 <p>TODO: Put this method under direct unit test.
 Currently tested indirectly, through method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_predictQuantizationEventTimeWorker-int-ptolemy.actor.util.Time-"><code>_predictQuantizationEventTimeWorker(int, Time)</code></a>
 of each solver.
 Testing directly will make it easier to check results, and will make it
 easier to add testing for slope-aware quant-evt predictions.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>qStateModel</code> - The model of external, quantized state.</dd>
<dd><code>cStateModel</code> - The model of internal, continuous state.</dd>
<dd><code>dq</code> - The quantum, i.e., the critical difference between the models, at
   which the external state model must be re-formed.</dd>
<dd><code>exactInputs</code> - If true, then the inputs are known to be exact.
 If true, then do not fall back to QSS1.</dd>
<dd><code>exactInputs</code> - True if exact inputs are expected.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>dt The delta-time at which, in the absence of other events, the
   external state model must be re-formed.
   Note 0 &lt;= dt &lt;= Double.POSITIVE_INFINITY.
   A value of 0 means need a quantization-event as soon as possible.</dd>
</dl>
</li>
</ul>
<a name="Z:Z_predictQuantizationEventDeltaTimeQSS2General-org.ptolemy.qss.util.ModelPolynomial-org.ptolemy.qss.util.ModelPolynomial-double-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_predictQuantizationEventDeltaTimeQSS2General</h4>
<pre>protected static final&nbsp;double&nbsp;_predictQuantizationEventDeltaTimeQSS2General(<a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;qStateModel,
                                                                            <a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;cStateModel,
                                                                            double&nbsp;dq,
                                                                            boolean&nbsp;exactInputs)</pre>
<div class="block">Get the delta-time to the predicted quantization-event for a state under QSS2.

 <p>Utility method for use by <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_predictQuantizationEventTimeWorker-int-ptolemy.actor.util.Time-"><code>_predictQuantizationEventTimeWorker(int, Time)</code></a>.</p>

 <p>Find the time step, from the most recent state-event time, of the
 predicted quantization-event for a state under QSS2.
 Do not assume the quantized state model bears any particular relationship
 to the continuous state model.</p>

 <p>TODO: Put this method under direct unit test.
 Currently tested indirectly, through method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_predictQuantizationEventTimeWorker-int-ptolemy.actor.util.Time-"><code>_predictQuantizationEventTimeWorker(int, Time)</code></a>
 of each solver.
 Testing directly will make it easier to check results, and will make it
 easier to add testing for slope-aware quant-evt predictions.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>qStateModel</code> - The model of external, quantized state.</dd>
<dd><code>cStateModel</code> - The model of internal, continuous state.</dd>
<dd><code>dq</code> - The quantum, i.e., the critical difference between the models, at
   which the external state model must be re-formed.</dd>
<dd><code>exactInputs</code> - True if exact inputs are expected.</dd>
</dl>
</li>
</ul>
<a name="Z:Z_predictQuantizationEventDeltaTimeQSS3QFromC-org.ptolemy.qss.util.ModelPolynomial-org.ptolemy.qss.util.ModelPolynomial-double-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_predictQuantizationEventDeltaTimeQSS3QFromC</h4>
<pre>protected static final&nbsp;double&nbsp;_predictQuantizationEventDeltaTimeQSS3QFromC(<a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;qStateModel,
                                                                           <a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;cStateModel,
                                                                           double&nbsp;dq,
                                                                           boolean&nbsp;exactInputs)</pre>
<div class="block">Get the delta-time to the predicted quantization-event for a state under QSS3.

 <p>Utility method for use by <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_predictQuantizationEventTimeWorker-int-ptolemy.actor.util.Time-"><code>_predictQuantizationEventTimeWorker(int, Time)</code></a>.</p>

 <p>Find the time step, from the most recent quantization-event time, of the
 predicted quantization-event for a state under QSS3.
 Assume the quantized state model was derived from the
 continuous state model, and therefore has the same value slope, and
 second derivative at the quantization-event time.</p>

 <p>TODO: Put this method under direct unit test.
 Currently tested indirectly, through method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_predictQuantizationEventTimeWorker-int-ptolemy.actor.util.Time-"><code>_predictQuantizationEventTimeWorker(int, Time)</code></a>
 of each solver.
 Testing directly will make it easier to check results, and will make it
 easier to add testing for slope-aware quant-evt predictions.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cStateModel</code> - The model of internal, continuous state.</dd>
<dd><code>qStateModel</code> - The model of external, quantized state.</dd>
<dd><code>dq</code> - The quantum, i.e., the critical difference between the models, at
   which the external state model must be re-formed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>dt The delta-time at which, in the absence of other events, the
   external state model must be re-formed.
   Note 0 &lt;= dt &lt;= Double.POSITIVE_INFINITY.
   A value of 0 means need a quantization-event as soon as possible.</dd>
</dl>
</li>
</ul>
<a name="Z:Z_predictQuantizationEventDeltaTimeQSS3General-org.ptolemy.qss.util.ModelPolynomial-org.ptolemy.qss.util.ModelPolynomial-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_predictQuantizationEventDeltaTimeQSS3General</h4>
<pre>protected static final&nbsp;double&nbsp;_predictQuantizationEventDeltaTimeQSS3General(<a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;qStateModel,
                                                                            <a href="../../../../org/ptolemy/qss/util/ModelPolynomial.html" title="class in org.ptolemy.qss.util">ModelPolynomial</a>&nbsp;cStateModel,
                                                                            double&nbsp;dq)</pre>
<div class="block">Get the delta-time to the predicted quantization-event for a state under QSS3.

 <p>Utility method for use by <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_predictQuantizationEventTimeWorker-int-ptolemy.actor.util.Time-"><code>_predictQuantizationEventTimeWorker(int, Time)</code></a>.</p>

 <p>Find the time step, from the most recent state-event time, of the
 predicted quantization-event for a state under QSS3.
 Do not assume the quantized state model bears any particular relationship
 to the continuous state model.</p>

 <p>TODO: Put this method under direct unit test.
 Currently tested indirectly, through method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#Z:Z_predictQuantizationEventTimeWorker-int-ptolemy.actor.util.Time-"><code>_predictQuantizationEventTimeWorker(int, Time)</code></a>
 of each solver.
 Testing directly will make it easier to check results, and will make it
 easier to add testing for slope-aware quant-evt predictions.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cStateModel</code> - The model of internal, continuous state.</dd>
<dd><code>qStateModel</code> - The model of external, quantized state.</dd>
<dd><code>dq</code> - The quantum, i.e., the critical difference between the models, at
   which the external state model must be re-formed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>dt The delta-time at which, in the absence of other events, the
   external state model must be re-formed.
   Note 0 &lt;= dt &lt;= Double.POSITIVE_INFINITY.
   A value of 0 means need a quantization-event as soon as possible.</dd>
</dl>
</li>
</ul>
<a name="Z:Z_triggerQuantizationEventWorker-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_triggerQuantizationEventWorker</h4>
<pre>protected abstract&nbsp;void&nbsp;_triggerQuantizationEventWorker(int&nbsp;stateIdx)</pre>
<div class="block">Form a new external, quantized state model (QSS-specific).

 <p>See comments to method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerQuantizationEvent-int-"><code>triggerQuantizationEvent(int)</code></a>.</p>

 <p>The implementation of this "worker" method depends on the
 specific member of the QSS family.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stateIdx</code> - The state index, 0 &lt;= stateIdx &lt; this.getStateCount().</dd>
</dl>
</li>
</ul>
<a name="Z:Z_triggerRateEventWorker--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_triggerRateEventWorker</h4>
<pre>protected abstract&nbsp;void&nbsp;_triggerRateEventWorker()
                                         throws java.lang.Exception</pre>
<div class="block">Form new internal, continuous state models (QSS-specific).

 <p>See comments to method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerRateEvent--"><code>triggerRateEvent()</code></a>.</p>

 <p>The implementation of this "worker" method depends on the
 specific member of the QSS family.</p></div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.Exception</code> - If the rate event worker fails.</dd>
</dl>
</li>
</ul>
<a name="Z:Z_triggerRateEventWorkerEventDetection--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>_triggerRateEventWorkerEventDetection</h4>
<pre>protected abstract&nbsp;void&nbsp;_triggerRateEventWorkerEventDetection()
                                                       throws java.lang.Exception</pre>
<div class="block">Form new internal, continuous state models (QSS-specific).

 <p>See comments to method <a href="../../../../org/ptolemy/qss/solver/QSSBase.html#triggerRateEvent--"><code>triggerRateEvent()</code></a>.</p>

 <p>The implementation of this "worker" method depends on the
 specific member of the QSS family.</p></div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.Exception</code> - If the rate event worker event detection fails.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../org/ptolemy/qss/solver/QSS3Pts.html" title="class in org.ptolemy.qss.solver"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li>Next&nbsp;Class</li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?org/ptolemy/qss/solver/QSSBase.html" target="_top">Frames</a></li>
<li><a href="QSSBase.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
