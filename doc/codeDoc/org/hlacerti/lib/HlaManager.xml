<?xml version="1.0" standalone="yes"?>
<!DOCTYPE doc PUBLIC "-//UC Berkeley//DTD DocML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/DocML_1.dtd">
<doc name="HlaManager" class="org.hlacerti.lib.HlaManager">
  <description>
The Ptolemy-HLA co-simulation framework leverages two open source tools: &#10; Ptolemy II and HLA/CERTI to enable construction in Ptolemy II of an HLA&#10; federate. &#10; &lt;/p&gt;&#10; &lt;h2&gt;About HLA&lt;/h2&gt;&#10; &lt;p&gt;&#10; The High Level Architecture (HLA) [1][2] is a standard for distributed&#10; discrete-event simulation. A simulation in HLA is called an HLA&#10; federation. A federation is a collection of federates, typically modeling&#10; components in a system, interconnected by a Run Time Infrastructure (RTI).&#10; Each federate may be running on a different machine, and the RTI enables&#10; them to send each other time-stamped events and ensures that the time&#10; stamps respect DE semantics. The coordination between federates is handled&#10; by a process called the RTIG, for RTI Gateway, which may be running&#10; on a remote machine. Specifically, time advance in each of the&#10; federates is coordinated by the RTIG so that events never arrive with time stamps&#10; that are in the past with respect to the current time of the federate.&#10; In Ptolemy II, a federate is a DE model with an instance of this HlaManager.&#10; The model can contain composite actors with other models of computation, using&#10; the ContinuousDirector for example.&#10; &lt;/p&gt;&lt;p&gt;&#10; This framework has been tested with an open-source RTI implementation&#10; called CERTI [4]. In principle, it should work with other RTI implementations.&#10; CERTI is implemented in C++, and an API called JCERTI is provided for Java.&#10; Ptolemy II uses JCERTI.  CERTI also provides a Python API, so in principle,&#10; a Ptolemy II federate should be able to interact with a federate written&#10; in Python. For more about CERTI, see:&#10; &lt;a href=&quot;http://savannah.nongnu.org/projects/certi&quot; target=&quot;_top&quot;&gt;http://savannah.nongnu.org/projects/certi&lt;/a&gt;.&#10; &lt;/p&gt;&#10; &lt;h2&gt;Creating a Federate&lt;/h2&gt;&#10; &lt;p&gt;&#10; To create a federate, in a Ptolemy model with a DE director, instantiate&#10; an instance of this HLAManager. You will need to set the federationName&#10; parameter to the name of the federation and&#10; the &lt;i&gt;federateName&lt;/i&gt; parameter to a unique name for the federate (unique&#10; to the federation).&#10; If, when running the model, there is no federation with the specified&#10; name, then a federation with that name will be automatically created.&#10; Otherwise, the federate will join the pre-existing federation.&#10; &lt;/p&gt;&lt;p&gt;&#10; Federates can exchange information using actors that implement&#10; the &lt;a href=&quot;../../../org/hlacerti/lib/HlaUpdatable.xml&quot;&gt;org.hlacerti.lib.HlaUpdatable&lt;/a&gt; and &lt;a href=&quot;../../../org/hlacerti/lib/HlaReflectable.xml&quot;&gt;org.hlacerti.lib.HlaReflectable&lt;/a&gt; interfaces,&#10; such as &lt;a href=&quot;../../../org/hlacerti/lib/HlaAttributeUpdater.xml&quot;&gt;org.hlacerti.lib.HlaAttributeUpdater&lt;/a&gt; and &lt;a href=&quot;../../../org/hlacerti/lib/HlaAttributeReflector.xml&quot;&gt;org.hlacerti.lib.HlaAttributeReflector&lt;/a&gt;,&#10; respectively. When a time-stamped event in one&#10; federate is fed into an HlaUpdatable, then a corresponding time-stamped&#10; event will pop out of any HlaReflectable elsewhere in the federation&#10; if the parameters of that HlaReflectable match those of the&#10; HlaUpdatable. These parameters conform to a&#10; Federation Object Model (FOM) that is an important part of the&#10; definition of a federation and is described in a file called a&#10; Federation Execution Data (FED) file that needs to be&#10; available to this HlaManager. More about this later.&#10; &lt;/p&gt;&#10; &lt;h2&gt;Time-Stamped Communication&lt;/h2&gt;&#10; &lt;p&gt;&#10; When a time-stamped event is sent from one federate to another&#10; through the RTI,&#10; the relationship of the received time stamp compared to the sent&#10; time stamp depends on the parameters of the two HlaManagers at&#10; each end of the communication.&#10; First, the parameter &lt;i&gt;timeManagementService&lt;/i&gt; selects between two&#10; styles called &quot;Next Event Request (NER)&quot; and&#10; &quot;Time Advancement Request (TAR)&quot;.&#10; We explain these in order.&#10; &lt;/p&gt;&lt;p&gt;&#10; The NER style is the default, and it is the most natural for use&#10; with DE models. When &lt;i&gt;timeManagementService&lt;/i&gt; specifies NER at both&#10; the sending and receiving federate, then&#10; the received time stamp is simply equal to the sent time stamp&#10; plus the value of the &lt;i&gt;hlaLookahead&lt;/i&gt; parameter of the sending&#10; federate. So logically, there&#10; is a &quot;model-time delay&quot; equal to &lt;i&gt;hlaLookahead&lt;/i&gt; in each&#10; communication.  The &lt;i&gt;hlaLookahead&lt;/i&gt; is required to be strictly&#10; greater than zero (this significantly simplifies distributed&#10; coordination).&#10; &lt;/p&gt;&lt;p&gt;&#10; It rarely makes sense in a DE federate to use the TAR style,&#10; and the result of using it is much more complicated.&#10; The easiest way to understand the effect is to consider that&#10; the time stamp may be modified first at the sending federate&#10; and then again at the receiving federate. If the sending&#10; federate is NER, then it simply increments the time stamp&#10; by its &lt;i&gt;hlaLookahead&lt;/i&gt;. If the receiving federate is NER, then&#10; it makes no modification to the received time stamp. It uses whatever&#10; it receives. Hence, if both ends are NER, the total modification&#10; to the time stamp is to increment it by the &lt;i&gt;hlaLookahead&lt;/i&gt; value at the sender.&#10; But the situation is much more complicated if either end&#10; uses TAR.&#10; &lt;/p&gt;&lt;p&gt;&#10; Suppose a sending federate is using TAR. In this case,&#10; both &lt;i&gt;hlaLookahead&lt;/i&gt; and the &lt;i&gt;hlaTimeStep&lt;/i&gt; parameter may affect&#10; the time stamp. Specifically, if the sender has an event&#10; with time stamp equal to or greater than&#10; &lt;i&gt;N&lt;/i&gt; times &lt;i&gt;hlaTimeStep&lt;/i&gt; and less than&#10; &lt;i&gt;N&lt;/i&gt; times &lt;i&gt;hlaTimeStep&lt;/i&gt; plus &lt;i&gt;hlaLookahead&lt;/i&gt;, &#10; for any integer &lt;i&gt;N&lt;/i&gt;, then the&#10; time stamp will be modified by the sender to equal&#10; &lt;i&gt;N&lt;/i&gt; times &lt;i&gt;hlaTimeStep&lt;/i&gt; plus &lt;i&gt;hlaLookahead&lt;/i&gt;.&#10; Otherwise, the time stamp is unmodified by the sender.&#10; &lt;/p&gt;&lt;p&gt;&#10; For example, if the sender has &lt;i&gt;hlaTimeStep&lt;/i&gt; = 10 and&#10; &lt;i&gt;hlaLookahead&lt;/i&gt; = 2 and it wishes to send an event with&#10; time stamp 1, the time stamp will be modified to 2,&#10; introducing a delay of 1.&#10; If it wants to send an event with time stamp 11,&#10; the time stamp will be modified to 12.&#10; &lt;/p&gt;&lt;p&gt;&#10; Suppose a receiving federate is using TAR. In this&#10; case, the time stamp of any incoming event will be&#10; modified to equal the next largest (or equal)&#10; multiple of the receiver's &lt;i&gt;hlaTimeStep&lt;/i&gt;, i.e.&#10; &lt;i&gt;M&lt;/i&gt; times &lt;i&gt;hlaTimeStep&lt;/i&gt; for some integer &lt;i&gt;M&lt;/i&gt;.&#10; &lt;/p&gt;&lt;p&gt;&#10; For example, if a receiving federate of the previous message&#10; whose time stamp was modified to 2 uses TAR with&#10; &lt;i&gt;hlaTimeStep&lt;/i&gt; = 5, then the time stamp will be modified&#10; from 2 to 5, thereby getting a total delay of 4.&#10; If the receiving federate uses NER, on the other&#10; hand, the time stamp will not be modified by the receiver.&#10; It will be received with time stamp 2.&#10; &lt;/p&gt;&lt;p&gt;&#10; If the sending federate is using NER and the receiving federate&#10; is using TAR, then the sending federate will first modify the&#10; time stamp by adding its &lt;i&gt;hlaLookahead&lt;/i&gt; to the time stamp,&#10; and then the receiving federate will further modify the time&#10; stamp to make it equal to the least larger multiple of its&#10; &lt;i&gt;hlaTimeStep&lt;/i&gt;.&#10; &lt;/p&gt;&#10; &lt;h2&gt;Exchanging Data&lt;/h2&gt;&#10; &lt;p&gt;&#10; In HLA, the data that is sent from one federate to another through&#10; the RTI is viewed&#10; as an update to an attribute of an instance of a class.&#10; Actors implementing the&#10; &lt;a href=&quot;../../../org/hlacerti/lib/HlaUpdatable.xml&quot;&gt;org.hlacerti.lib.HlaUpdatable&lt;/a&gt; and &lt;a href=&quot;../../../org/hlacerti/lib/HlaReflectable.xml&quot;&gt;org.hlacerti.lib.HlaReflectable&lt;/a&gt; interfaces specify&#10; which attribute of which instance of which class they update&#10; or are notified of updates.&#10; See the documentation for &lt;a href=&quot;../../../org/hlacerti/lib/HlaAttributeUpdater.xml&quot;&gt;org.hlacerti.lib.HlaAttributeUpdater&lt;/a&gt; and&#10; &lt;a href=&quot;../../../org/hlacerti/lib/HlaAttributeReflector.xml&quot;&gt;org.hlacerti.lib.HlaAttributeReflector&lt;/a&gt;.&#10; &lt;/p&gt;&lt;p&gt;&#10; A Federation requires a Federation Execution Data (FED) file [7],&#10; which defines classes and specifies which attributes a class contains.&#10; The location of the FED file is given by two parameters of&#10; this HlaManager, &lt;i&gt;fedFile&lt;/i&gt; and &lt;i&gt;fedFileOnRTIG&lt;/i&gt;.&#10; Unfortunately, in HLA, the FED file is not a networked resource,&#10; and it is needed by both the Ptolemy II federate and the RTIG,&#10; and these may not be running on the same machine. So the locations&#10; of the two files may be different.&#10; By default, &lt;i&gt;fedFileOnRTIG&lt;/i&gt; is set to &quot;$fedFile&quot;, which&#10; makes it the same as whatever you specify in the &lt;i&gt;fedFile&lt;/i&gt;&#10; parameter. This will usually work if the RTIG is being run&#10; on the same machine as the federate, and will always work if&#10; the federate itself launches the RTIG by setting the&#10; &lt;i&gt;launchRTIG&lt;/i&gt; parameter.&#10; &lt;/p&gt;&#10; &lt;h2&gt;Environment Variables&lt;/h2&gt;&#10; &lt;p&gt;&#10; CERTI, which is the implementation of HLA that Ptolemy II uses,&#10; relies on some environment variables in order to execute:&#10; &lt;ul&gt;&#10; &lt;li&gt; CERTI_HOST, which provides the IP address of the machine that hosts the RTIG, &#10; &lt;li&gt; CERTI_HOME, which provides the path to your installation of CERTI,&#10; &lt;li&gt; CERTI_FOM_PATH which provides the default directory where the FED files are.&#10;   This variable is needed if the FED file is not in the directory where the&#10;   RTIG is launched. &#10; &lt;li&gt; PATH must be updated with $CERTI_HOME/bin, so the binaries can be found,&#10;   e.g., rtig and rtia.&#10; &lt;li&gt; LD_LIBRARY_PATH and DYLD_LIBRARY_PATH must be updated with $CERTI_HOME/lib, &#10;   the directory where the libRTI, libFedTime, libCERTId libraries are&#10;   implemented.&#10; &lt;/ul&gt;&#10; CERTI provides a script &lt;i&gt;myCERTI_env.sh&lt;/i&gt; that set all the above&#10; environment variables. The script is located in $CERTI_HOME/share/scripts and&#10; must be run before a federation simulation.&#10; &#10; By default, the script &lt;i&gt;myCERTI_env.sh&lt;/i&gt; set CERTI_HOST=localhost. This &#10; specifies that the RTIG host is the local machine. If you are connecting to&#10; a remote RTIG, you need to specify the IP address or domain name of that machine.&#10; To set it, before launching Ptolemy II, you can execute a command like:&#10; &lt;pre&gt;&#10;    export CERTI_HOST=IP_address&#10; &lt;/pre&gt;&#10; &lt;/p&gt;&lt;p&gt;&#10; The environment variable CERTI_HOME is required&#10; only if you wish the federate to launch an RTIG, something you specify&#10; with the &lt;i&gt;launchRTIG&lt;/i&gt; parameter.  If you wish the federate to launch&#10; an RTIG, then you must set CERTI_HOME equal to the path to your&#10; installation of CERTI, and you must set your PATH environment variable&#10; to include the share/scripts and bin directories of your CERTI installation.&#10; &lt;/p&gt;&lt;p&gt;&#10; Notice that if the script &lt;i&gt;myCERTI_env.sh&lt;/i&gt; is executed, all environment&#10; variables are set and the RTIG can be launched executing a command line&#10; (like &lt;i&gt;rtig&lt;/i&gt;) or by the Ptolemy federate as explained above.&#10; &lt;/p&gt;&lt;p&gt;&#10; Sometime in the future, these environment variables may be replaced&#10; or supplemented by parameters added to this HlaManager.&#10; See also the &lt;a href=&quot;../../../org/hlacerti/lib/CertiRtig.xml&quot;&gt;org.hlacerti.lib.CertiRtig&lt;/a&gt; class.&#10; &lt;/p&gt;&#10; &lt;h2&gt;Lifecycle of Execution of a Federate&lt;/h2&gt;&#10; &lt;p&gt;&#10; When a Ptolemy II federate starts executing, this HlaManager attempts&#10; to connect to an RTIG running on the host specified by CERTI_HOST.&#10; If this fails, and if &lt;i&gt;launchRTIG&lt;/i&gt;&#10; is set to true, and CERTI_HOST is either &quot;localhost&quot; or &quot;127.0.0.1&quot;,&#10; then this HlaManager will attempt to launch an RTIG on the local&#10; machine.  This will require that the rtig executable be in your&#10; PATH and that CERTI_HOME be specified, as explained above.&#10; &lt;/p&gt;&lt;p&gt;&#10; Once the federate has connected to the RTIG, it will attempt to&#10; join the federation whose name is given by &lt;i&gt;federationName&lt;/i&gt;.&#10; If there is no such federation, then it will create it and then&#10; join it.&#10; &lt;/p&gt;&lt;p&gt;&#10; After joining the federation, if &lt;i&gt;synchronizeStartTo&lt;/i&gt; is&#10; not empty, then it will stall the execution until the&#10; synchronization point named in &lt;i&gt;synchronizeStartTo&lt;/i&gt; is&#10; reached by all federates in the federation.&#10; If &lt;i&gt;synchronizeStartTo&lt;/i&gt; is the same as &lt;i&gt;federateName&lt;/i&gt;,&#10; then it is &lt;i&gt;this&lt;/i&gt; federate that registers the synchronization&#10; point with the HLA. In that case, this federate should be last one launched.&#10; All other federates that name this federate in their&#10; &lt;i&gt;synchronizeStartTo&lt;/i&gt; parameters will be waiting for&#10; a message from the RTIG when all federates have reached this point, &#10; and now the coordinated simulation can begin.&#10; &lt;b&gt;NOTE:&lt;/b&gt; If any federate fails to reach this synchronization point,&#10; then the entire federation will be frozen in its initialization.&#10; Consequently, &lt;i&gt;every&lt;/i&gt; federate must have the same value for&#10; &lt;i&gt;synchronizeStartTo&lt;/i&gt;.&#10; &lt;/p&gt;&lt;p&gt;&#10; The simulation then executes like a normal DE simulation, except&#10; that it may be stalled waiting for the RTI to permit time to advance.&#10; This HlaManager implements the Ptolemy II TimeRegulator interface,&#10; which enables it to regulate the advancement of time in the DEDirector.&#10; The parameters &lt;i&gt;isTimeConstrained&lt;/i&gt; and &lt;i&gt;isTimeRegulator&lt;/i&gt; can be used&#10; to decouple the advancement of time of the DEDirector from that of the RTI,&#10; but this is rarely a good idea. For more details about time management&#10; during execution, see [8].&#10; &lt;/p&gt;&lt;p&gt;&#10; The DEDirector in the model is required to have a finite &lt;i&gt;stopTime&lt;/i&gt;&#10; parameter set. It is usually also a good idea to set its&#10; &lt;i&gt;stopWhenQueueIsEmpty&lt;/i&gt; parameter to false, particularly if it&#10; is relying on an HlaReflectable actor to provide it with events to process.&#10; Otherwise, the federate may prematurely finish its simulation.&#10; &lt;/p&gt;&lt;p&gt;&#10; When the simulation ends, the federate resigns from the federation.&#10; When all federates have resigned, the last federate destroys the federation.&#10; In addition, if one of the federates launched the RTIG, and if&#10; that federate's &lt;i&gt;killRTIG&lt;/i&gt; parameter is set to true, then&#10; that federate will also kill the RTIG.&#10; &lt;/p&gt;&lt;p&gt;&#10; This HlaManager provides extensive debug output. Listen to the attribute to get&#10; the details. Some of these messages, primarily those related to the lifecycle of&#10; the interaction with the RTI, are also printed to standard out, even if you are&#10; listening to the attribute.&#10; &lt;/p&gt;&#10; &lt;p&gt;NOTE FOR DEVELOPERS:&#10; A federate needs to instruct the RTI that it is prepared to receive one or more&#10; callbacks. The way to do it was not in the HLA 1.3 standard and was introduced &#10; in the HLA IEEE 1516 standard. JCERTI, the Java API, is compliant only with DoD HLA 1.3&#10; even though CERTI (coded with C++) is compliant with both standards. JCERTI&#10; provides three different methods for receiving a callback: tick(), &#10; tick(min,max) and tick2(). When a federate calls the tick() method, any&#10; callbacks that are pending are invoked, and then the tick() returns.&#10; If there are no pending callbacks, then it returns immediately.&#10; This HLAManager, uses tick(min, max), which is not documented and we can't&#10; be sure what it does, but it seems that the min argument specifies the&#10; maximum real time to block waiting for a callback&#10; before returning, and the second argument is not used. But we really can't&#10; be sure without carefully evaluating all the C++ code.&#10; The alternative, tick2(), is not an attractive alternative because it&#10; blocks until a callback occurs, and a callback may never occur.&#10; This results in the HLAManager freezing, which freezes the Ptolemy model&#10; and Vergil, the user interface.&#10; &lt;/p&gt;&#10; &lt;p&gt;&lt;b&gt;References&lt;/b&gt;:&lt;/p&gt;&#10;&#10; &lt;p&gt;[1] Dpt. of Defense (DoD) Specifications, &quot;High Level Architecture Interface&#10;     Specification, Version 1.3&quot;, DOD/DMSO HLA IF 1.3, Tech. Rep., Apr 1998.&lt;/p&gt;&#10; &lt;p&gt;[2] IEEE, &quot;IEEE standard for modeling and simulation High Level Architecture&#10;     (HLA)&quot;, IEEE Std 1516-2010, vol. 18, pp. 1-38, 2010.&lt;/p&gt;&#10; &lt;p&gt;[3] D. of Defense (DoD) Specifications, &quot;High Level Architecture Object Model&#10;     Template, Version 1.3&quot;, DOD/DMSO OMT 1.3, Tech. Rep., Feb 1998.&lt;/p&gt;&#10; &lt;p&gt;[4] E. Noulard, J.-Y. Rousselot, and P. Siron, &quot;CERTI, an open source RTI,&#10;     why and how ?&quot;, Spring Simulation Interoperability Workshop, pp. 23-27,&#10;     Mar 2009.&lt;/p&gt;&#10; &lt;p&gt;[5] Y. Li, J. Cardoso, and P. Siron, &quot;A distributed Simulation Environment for&#10;     Cyber-Physical Systems&quot;, Sept 2015.&lt;/p&gt;&#10; &lt;p&gt;[6] J. Cardoso, and P. Siron, &quot;Ptolemy-HLA: a Cyber-Physical System Distributed&#10;     Simulation Framework&quot;, In: Principles of Modeling. Springer International &#10;     Publishing Switzerland, 122-142. ISBN 978-3-319-95245-1. &lt;/p&gt;&#10; &lt;p&gt;[7] Dpt. of Defense. High Level Architecture Run-Time Infrastructure &#10;     Programmer’s Guide RTI 1.3 Version 6, March 1999&lt;/p&gt;&#10; &lt;p&gt;[8] R. Fujimoto, &quot;Time Management in The High Level Architecture&quot;,&#10;     https://doi.org/10.1177/003754979807100604&lt;/p&gt;&#10; &lt;p&gt;[9] IEEE Standard for Modeling and Simulation HLA: Federate Interface Specification,&#10;     IEEE Std 1516.1-2010, 18 August 2010. &lt;/p&gt;&#10; &lt;p&gt;[10] Chaudron, Jean-Baptiste and Siron, Pierre and Adelantado, Martin. Analysis and&#10;     Optimization of time-management services in CERTI 4.0. (2018) In: 2018 Fall&#10;     Simulation Innovation Workshop (SIW), 10-14 September 2018 (Orlando, United &#10;     States). &lt;/p&gt;  </description>
  <author>Gilles Lasnier, Janette Cardoso, and Edward A. Lee. Contributors: Patricia Derler, David Come, Yanxuan LI</author>
  <version>$Id: HlaManager.java 214 2018-04-01 13:32:02Z j.cardoso $</version>
  <since>Ptolemy II 11.0</since>
  <Pt.ProposedRating>Yellow (glasnier)</Pt.ProposedRating>
  <Pt.AcceptedRating>Red (glasnier)</Pt.AcceptedRating>
    <!--ptolemy.data.expr.StringParameter-->
    <property name="federateName">Name of the Ptolemy Federate. This is a string that defaults&#10;  to &quot;Federate&quot;. Note that it is required that every federate in&#10;  a federation has to have a unique name.</property>
    <!--ptolemy.data.expr.StringParameter-->
    <property name="federationName">Name of the federation. This is a string that default to&#10;  &quot;HLAFederation&quot;.</property>
    <!--ptolemy.data.expr.FileParameter-->
    <property name="fedFile">Path and name of the Federation Execution Data (FED) file (which should have&#10;  extension .fed) on the local machine. This is not necessarily the file that&#10;  is used by the RTIG because the RTIG may not be running on the local machine.&#10;  It is expected that if these two files are on different machines, they are&#10;  nevertheless the same.</property>
    <!--ptolemy.data.expr.StringParameter-->
    <property name="fedFileOnRTIG">Name or path and name of the FED file on the machine that is running the&#10;  RTIG. Unfortunately, that file may not be the same as the FED file&#10;  on the local machine, pointed to by the fedFile parameter. By&#10;  default, this string is set to &quot;$fedFile&quot;, indicating that the default&#10;  value should match the value of the fedFile parameter. But note that&#10;  if the RTIG is running on a remote machine, this may need to be different&#10;  from the value of fedFile. Note also that the remote FED file and the&#10;  local FED file need to be the same, but there is no way to enforce that.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="hlaTimeUnit">Double value representing how many HLA time units there are in one&#10;  second. An HLA federation runs in arbitrary time units, where each&#10;  unit can represent any amount of time. This parameter gives an interpretation&#10;  of those time units and has units of HLA time units per second.&#10;  For example, if the HLA time unit is 1 millisecond, then the value of&#10;  this parameter should be 1,000. Ptolemy uses units of seconds, so&#10;  the value of this parameter affects the mapping from HLA time units to&#10;  time stamps in Ptolemy.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="isTimeConstrained">A boolean indicating that time advance in this federate is regulated&#10;  by other federates in the federation. This defaults to true.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="isTimeRegulator">A boolean indicating that this federate regulates the time advance of&#10;  other federates in the federation. This defaults to true.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="hlaTimeStep">Value of the time step of this Federate. This is a double that&#10;  defaults to 1.0. This is used only if you select TAR in the&#10;  timeManagementService parameter. The units here are HLA logical&#10;  time, not seconds. See the hlaTimeUnit parameter.&#10;  Normally, hlaTimeStep is larger than or equal to hlaLookAHead&#10;  when using TAR.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="hlaLookAHead">Value of the lookahead of this federate. This is a double that&#10;  default to 0.1. The units here are HLA logical logical&#10;  time, not seconds. See the hlaTimeUnit parameter.&#10;  Normally, hlaLookAhead is smaller than or equal to hlaTimeStep&#10;  when using TAR.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="killRTIG">If true, kill the HLA runtime infrastructure gateway (RTIG)&#10;  in wrapup() that was created in preinitialize. If no RTIG was created&#10;  in preinitialize, then ignore this.  This is a boolean that&#10;  defaults to the value of launchRTIG.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="launchRTIG">If true, launch an HLA runtime infrastructure gateway (RTIG) in preinitialize.&#10;  This is a boolean that defaults to false.</property>
    <!--ptolemy.data.expr.ChoiceParameter-->
    <property name="timeManagementService">Choice of time advancement service. This is a string that is one of&#10;  &quot;Next Event Request (NER)&quot; or &quot;Time Advancement Request (TAR)&quot;.&#10;  If TAR is selected, then you need to also provide a time step&#10;  in the hlaTimeStep parameter.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="enableHlaReporter">A boolean indicating whether a log file should be written to the&#10;  location defined by the hlaReportPath parameter. This defaults to&#10;  false.</property>
    <!--ptolemy.data.expr.FileParameter-->
    <property name="hlaReportPath">Path and name of the folder to store log files that are generated&#10;  if the enableHlaReporter parameter is true. This is a string that&#10;  defaults to &quot;$HOME/HLATestResults&quot;.</property>
    <!--ptolemy.data.expr.StringParameter-->
    <property name="synchronizeStartTo">The name of a synchronization point to which this federate should&#10;  synchronize its start. If the name given here is the name of this&#10;  federate, then this federate registers itself as a&#10;  synchronization point to which other federates can synchronize&#10;  their start. The name of this federate will be the name of the&#10;  synchronization point, and this federate needs to be the last one&#10;  launched. If this parameter contains an empty string,&#10;  then this federate starts right away without waiting for any other&#10;  federate.  This parameter defaults to an empty string, indicating&#10;  that there is no synchronization.&#10;  &#10;  NOTE: All federates in a federation must use the same name here.&#10;  If two federates use two different names, then both will block&#10;  on initialization. If any one federate uses a blank here, then it&#10;  will block the execution of all other federates until it resigns&#10;  the federation after completing its execution.</property>
</doc>
