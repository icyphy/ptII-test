<?xml version="1.0" standalone="yes"?>
<!DOCTYPE doc PUBLIC "-//UC Berkeley//DTD DocML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/DocML_1.dtd">
<doc name="ThreadedComposite" class="ptolemy.actor.lib.hoc.ThreadedComposite">
  <description>
A container for another actor that executes that other actor&#10; in a separate thread called the &lt;i&gt;inside thread&lt;/i&gt;.&#10; This actor starts that thread in its initialize()&#10; method, which is invoked by its executive director (the director&#10; in charge of firing this actor). The thread that invokes the&#10; action methods of this actor&#10; (initialize(), prefire(), fire(), postfire(), and wrapup())&#10; is called the &lt;i&gt;director thread&lt;/i&gt;.&#10;&#10; &lt;p&gt; A paper describing the use of this actor is found at&#10; &lt;a href=&quot;http://www.eecs.berkeley.edu/Pubs/TechRpts/2008/EECS-2008-151.html#in_browser&quot;&gt;http://www.eecs.berkeley.edu/Pubs/TechRpts/2008/EECS-2008-151.html&lt;/a&gt;.&lt;/p&gt;&#10;&#10; &lt;p&gt; To use this actor in Vergil, drag a ThreadedComposite on to the&#10; canvas and then drag the actor to be contained on to the&#10; ThreadedComposite actor.&lt;/p&gt;&#10;&#10; &lt;p&gt; This actor automatically creates input and output ports to&#10; match those of the inside actor. Input events provided at those&#10; input ports are provided as input events to the contained actor.&#10; Outputs provided by the contained actor become output events&#10; of this actor. The time stamp of the input events is provided&#10; by the container of this actor. The time stamp of the output events&#10; depends on the &lt;i&gt;delay&lt;/i&gt; parameter, as explained below.&lt;/p&gt;&#10;&#10; &lt;p&gt;&#10; The inside thread blocks waiting for inputs or pure events.&#10; Inputs are provided to that thread when the fire() method of&#10; this actor is invoked by the director thread.&#10; Pure events are provided after fireAt(),&#10; fireAtCurrentTime(), or fireAtFirstValidTimeAfter() are called&#10; by either the inside thread or the director thread.&#10; When the time of those firing requests becomes current time,&#10; the container will (presumably) fire this actor, and&#10; this actor will provide a pure event to the inside thread,&#10; causing it to fire the contained actor.&#10; &lt;p&gt;&#10; If the &lt;i&gt;synchronizeToRealTime&lt;/i&gt; parameter is true, then&#10; when the inside thread encounters an input or pure event&#10; with time stamp &lt;i&gt;t&lt;/i&gt;, it stalls until real time matches&#10; or exceeds &lt;i&gt;t&lt;/i&gt; (measured in seconds since the start of&#10; execution of the inside thread). In contrast for example&#10; to the &lt;i&gt;synchronizeToRealTime&lt;/i&gt; parameter of the DEDirector,&#10; this enables construction of models where only a portion of the&#10; model synchronizes to real time.&#10; &lt;p&gt;&#10; When the wrapup() method of this actor is called, the inside thread is&#10; provided with signal to terminate rather than to process additional&#10; inputs. The inside thread will also exit if stop() is called on this&#10; actor; however, in this case, which iterations are completed&#10; is nondeterminate (there may be inputs left unprocessed).&#10; If any inside actor return false from postfire(), then the&#10; inside thread will also terminate and this actor will return false&#10; from postfire.&#10; &lt;p&gt;&#10; The parameters of this actor include all the parameters of the&#10; contained actor, and setting those parameters automatically&#10; sets the parameters of the contained actor.&#10; &lt;p&gt;&#10; In addition to the parameters of the contained actor, this actor&#10; has a &lt;i&gt;delay&lt;/i&gt; parameter. This parameter is a double that&#10; be any nonnegative value or the special value &lt;i&gt;UNDEFINED&lt;/i&gt;.&#10; If it is given a nonnegative value, then the value specifies&#10; the model-time delay between input events and the output&#10; events that result from reacting to those input events.&#10; That is, if this actor is given an input event with time&#10; stamp &lt;i&gt;t&lt;/i&gt;, then if the contained actor produces any output&#10; events in reaction to that event, those output events will be&#10; produced by this actor with time stamp &lt;i&gt;t&lt;/i&gt; + &lt;i&gt;delay&lt;/i&gt;.&#10; &lt;p&gt;&#10; If &lt;i&gt;delay&lt;/i&gt; has value &lt;i&gt;UNDEFINED&lt;/i&gt;, then&#10; outputs are produced at the current model time of the executive&#10; director when the inside thread happens to produce those events,&#10; or if &lt;i&gt;synchronizeToRealTime&lt;/i&gt;, at the greater of current&#10; model time and current real time (measured in seconds since&#10; the start of execution).&#10; This is accomplished by the inside thread calling&#10; fireAtFirstValidTimeAfter() of the enclosing director, and&#10; then producing the outputs when the requested firing occurs&#10; in the director thread. Note that with this value of the&#10; &lt;i&gt;delay&lt;/i&gt;, it is possible for the inside thread to&#10; continue to execute and respond to input events after&#10; the wrapup phase of the director thread has been entered.&#10; The wrapup phase will stall until the inside thread has&#10; completed its processing of its inputs, but any outputs&#10; it produces after the wrapup phase has started will be&#10; discarded.&#10; &lt;p&gt;&#10; The most common use of this actor is in the DE domain,&#10; although it can also be used in CT, SR, SDF, and other domains,&#10; with some care. See the above referenced memo.&#10; Regardless of the value of &lt;i&gt;delay&lt;/i&gt;, this actor is treated&#10; by DE as introducing a delay, much like the TimedDelay actor.&#10; In fact, if &lt;i&gt;delay&lt;/i&gt; is 0.0, there will be a one tick delay&#10; in superdense time, just as with the TimedDelay actor.&#10; If the inside model also has a time delay (e.g. if you&#10; put a TimedDelay actor inside a ThreadedComposite), then&#10; the total delay is the sum of the two delays.&#10; &lt;p&gt;&#10; &lt;b&gt;Discussion:&lt;/b&gt;&#10; &lt;p&gt;&#10; There are several useful things you can do with this model.&#10; We describe some use cases here:&#10; &lt;p&gt;&#10; &lt;i&gt;Background execution.&lt;/i&gt; When &lt;i&gt;delay&lt;/i&gt; is greater than&#10; or equal to 0.0,&#10; then when this actor is fired in response to input events&#10; with time stamp &lt;i&gt;t&lt;/i&gt;, the actual&#10; processing of those events occurs later in a separate thread. The&#10; director thread is not blocked, and can continue to process events&#10; with time stamps less than or equal to &lt;i&gt;t&lt;/i&gt; + &lt;i&gt;delay&lt;/i&gt;.&#10; The director thread is blocked from processing events with larger&#10; time stamps than that because this is necessary to preserve DE&#10; semantics. To implement this, this actor uses fireAt() to&#10; request a firing at time  &lt;i&gt;t&lt;/i&gt; + &lt;i&gt;delay&lt;/i&gt;, and when that&#10; firing occurs, it blocks the director thread until the reaction&#10; is complete.&#10; &lt;p&gt;&#10; &lt;i&gt;Parallel firing.&lt;/i&gt; Note that if &lt;i&gt;delay&lt;/i&gt; is set to 0.0,&#10; it may seem that there is no point in using this actor, since&#10; model time will not be allowed to increase past &lt;i&gt;t&lt;/i&gt; until&#10; the contained actor has reacted to events with time stamp &lt;i&gt;t&lt;/i&gt;.&#10; However, there is actually exploitable concurrency if there&#10; are other actors in the model that also have pending input&#10; events with time stamp &lt;i&gt;t&lt;/i&gt;. Those event can be processed&#10; concurrently with this actor reacting to its input event.&#10; A typical use case will broadcast an event to several instances&#10; of ThreadedComposite, in which case each of those several&#10; inside threads can execute concurrently in reaction to those&#10; input events.&#10; &lt;p&gt;&#10; &lt;i&gt;Real-time source.&lt;/i&gt; If the contained actor (and hence this&#10; actor) has no inputs and &lt;i&gt;synchronizeToRealTime&lt;/i&gt; is true, then&#10; the contained actor must call fireAt() or one of its variants so that&#10; the inside thread will be provided with pure events.&#10; The behavior depends on which variant of the fireAt() methods is used&#10; by the inside actor.  There are three cases:&#10; FIXME: Described these. In particular, delay needs to specify the&#10; minimum increment between these or fireAt() could result in an&#10; exception.  Do we want a parameter to relax that?&#10; &lt;p&gt;&#10; On subtlety of this actor is that it cannot expose instances of ParameterPort&#10; without introducing nondeterminacy in the execution. A ParameterPort&#10; is an input port that sets the value of a parameter with the same name. Upon receiving&#10; a token at such a port, if this actor were to set a parameter visible by the&#10; inside thread, there is no assurance that the inside thread is not still&#10; executing an earlier iteration. Thus, it could appear to be sending a message&#10; backward in time, which would be truly bizarre. To prevent this error,&#10; this actor does not mirror such ports, and hence they appear on the outside&#10; only as parameters.  </description>
  <author>Edward A. Lee</author>
  <version>$Id$</version>
  <since>Ptolemy II 8.0</since>
  <Pt.ProposedRating>Yellow (eal)</Pt.ProposedRating>
  <Pt.AcceptedRating>Red (eal)</Pt.AcceptedRating>
    <!--ptolemy.data.expr.Parameter-->
    <property name="delay">The model-time delay between the input events and the&#10;  output events. This is a double that defaults to 0.0,&#10;  indicating that outputs should have the same time stamps&#10;  as the inputs that trigger them. If it has a value greater&#10;  than zero, then the outputs will have larger time stamps&#10;  by that amount. If it has the value &lt;i&gt;UNDEFINED&lt;/i&gt;&#10;  (or any negative number), then the output time stamp&#10;  will be nondeterminate, and will depend on the current&#10;  model time of the outside director when the output is&#10;  produced or on current real time.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="synchronizeToRealTime">If set to true, the inside thread stalls until real time matches&#10;  the time stamps of input events or pure events for each firing.&#10;  In addition, if &lt;i&gt;delay&lt;/i&gt; is set to undefined and this is set&#10;  to true, then output events are assigned a time stamp that is the&#10;  greater of current model time and real time.&#10;  Time is measured since the start of the execution of the inside&#10;  thread.  This is a boolean that defaults to false. Changing&#10;  the value of this parameter has no effect until the next&#10;  execution of the model.</property>
</doc>
