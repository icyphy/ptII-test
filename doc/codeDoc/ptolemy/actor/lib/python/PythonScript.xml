<?xml version="1.0" standalone="yes"?>
<!DOCTYPE doc PUBLIC "-//UC Berkeley//DTD DocML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/DocML_1.dtd">
<doc name="PythonScript" class="ptolemy.actor.lib.python.PythonScript">
  <description>
An actor of this class executes a Python script.  There are two versions&#10; of this actor provided in the Vergil libraries.  The one called&#10; &quot;PythonActor&quot; has an input port and an output port; to view or edit&#10; its Python script, look inside the actor.  The second version is&#10; called &quot;PythonScript&quot; and has no ports; to view or edit its Python&#10; script, select Configure (or double click on the icon).&#10;&#10; &lt;p&gt; Upon creation, this actor has no ports, and no parameters other than&#10; &lt;a href=&quot;../../../../ptolemy/actor/lib/python/PythonScript.xml#script&quot;&gt;script&lt;/a&gt;; The &lt;i&gt;script&lt;/i&gt; parameter has visibility&#10; EXPERT, and therefore does not normally show up in a configure dialog&#10; for the actor.  To make the script visible and editable, you have two&#10; options. Including an instance of an attribute of class&#10; TextEditorConfigureFactory (with its &lt;i&gt;attributeName&lt;/i&gt; parameter&#10; set to &lt;i&gt;script&lt;/i&gt;) results in behavior like that of the Vergil&#10; &quot;PythonScript.&quot; That is, to edit the script, you Configure the actor.&#10; If instead you include an instance of TextEditorTableauFactory,&#10; then to edit the script you look inside the actor.  Use the latter&#10; if you wish to add additional attributes to the actor and hide the&#10; script from the users.  Use the former if the script is the main&#10; means by which users interact with the actor.&lt;/p&gt;&#10;&#10; &lt;p&gt; The functionality of an actor of this type is given by a Python script.&#10; As an example, a simplified version of the&#10; &lt;a href=&quot;../../../../ptolemy/actor/lib/Scale.xml&quot;&gt;Scale&lt;/a&gt;&#10; actor can be implemented by the following script:&lt;/p&gt;&#10; &lt;pre&gt;&#10; 1.  class Main :&#10; 2.    &quot;scale&quot;&#10; 3.    def fire(self) :&#10; 4.      if not self.input.hasToken(0) :&#10; 5.        return&#10; 6.      s = self.scale.getToken()&#10; 7.      t = self.input.get(0)&#10; 8.      self.output.broadcast(s.multiply(t))&#10; &lt;/pre&gt;&#10;&#10; &lt;p&gt;Line 1 defines a Python class Main, which matches the value of the&#10; &lt;i&gt;jythonClassName&lt;/i&gt; parameter. An instance of this class is created when the&#10; actor is initialized. Line 2 is a description of the purpose of the&#10; script. Lines 3-8 define the fire() method, which is called by the&#10; &lt;a href=&quot;../../../../ptolemy/actor/lib/python/PythonScript.html#fire&quot;&gt;fire()&lt;/a&gt; method of this actor. In the method body,&#10; &lt;i&gt;input&lt;/i&gt; and &lt;i&gt;output&lt;/i&gt; are ports that have to have been added&#10; to the actor, and &lt;i&gt;scale&lt;/i&gt; is a parameter that has to have been&#10; added to the actor (these can be added in the XML that defines the&#10; actor instance in an actor library). The Main class can provide other&#10; methods in the &lt;a href=&quot;../../../../ptolemy/actor/Executable.xml&quot;&gt;Executable&lt;/a&gt; interface&#10; as needed.&lt;/p&gt;&#10;&#10; &lt;p&gt;In the script, use &lt;code&gt;self.actor&lt;/code&gt; to access the actor. For example,&#10; &lt;code&gt;self.actor.getDirector()&lt;/code&gt; returns the current director of the&#10; actor. For debugging, use &lt;code&gt;self.actor.debug(someMessage)&lt;/code&gt;. The&#10; final message sent to the debug listeners of the actor will have the string&#10; &quot;From script: &quot; inserted at the beginning. To avoid generating the debug&#10; message when there are no listeners, use:&lt;/p&gt;&#10; &lt;pre&gt;&#10; if self.actor.isDebugging() :&#10; self.actor.debug(someMessage)&#10; &lt;/pre&gt;&#10;&#10; &lt;p&gt;To use a Jython module, it is necessary to create a .py file&#10; located in a location where Jython can find it.  The Jython&#10; &lt;code&gt;sys.path&lt;/code&gt; variable contains the Jython path.  One way to&#10; get the value of the sys.path variable is to enable debugging on the&#10; actor by right clicking and selecting &quot;Listen to Actor&quot;, which will&#10; cause the preinitialize() method to print the contents of sys.path to&#10; standard out.  Another way to get the value of &lt;code&gt;sys.path&lt;/code&gt;&#10; is to run the Ptolemy model at&#10; &lt;code&gt;ptolemy/actor/lib/python/test/PythonSysPath&lt;/code&gt;.  For&#10; example, under Mac OS X for the ptII user, sys.path includes&#10; &lt;code&gt;/Users/ptII/lib/Lib&lt;/code&gt;.  So, create that directory if&#10; necessary and place the .py file in that directory, for example&#10; &lt;code&gt;/Users/ptII/lib/Lib/PtPythonSquare.py&lt;/code&gt;&lt;/p&gt;&#10;&#10; &lt;pre&gt;&#10;class Main :&#10;  &quot;Read the input and send the square to the output&quot;&#10;  def fire(self) :&#10;    token = self.input.get(0)&#10;    self.output.broadcast(token.multiply(token))&#10;    return&#10; &lt;/pre&gt;&#10;&#10; &lt;p&gt;Then set &lt;i&gt;jythonClassName&lt;/i&gt; to the name of the &lt;b&gt;Jython&lt;/b&gt;&#10; class, for example &lt;code&gt;PtPythonSquare.Main&lt;/code&gt;.  (Note that the&#10; &lt;i&gt;jythonClassName&lt;/i&gt; parameter should be set to the value of the&#10; Jython class name before changing the &lt;i&gt;script&lt;/i&gt; parameter to&#10; import a Jython module.)&lt;/p&gt;&#10;&#10; &lt;p&gt;Then set &lt;i&gt;script&lt;/i&gt; to  to:&lt;/p&gt;&#10; &lt;pre&gt;&#10; import PtPythonSquare&#10; PtPythonSquare = reload(PtPythonSquare)&#10; &lt;/pre&gt;&#10;&#10;&#10; &lt;p&gt;This class relies on &lt;a href=&quot;http://jython.org&quot;&gt;Jython&lt;/a&gt;, which&#10; is a Java implementation of Python.&#10;&#10; &lt;p&gt;As of November, 2011 $PTII/lib/jython.jar was based on Jython 2.5.2.&lt;/p&gt;&#10;&#10; &lt;p&gt;See &lt;a href=&quot;https://kepler-project.org/developers/reference/python-and-kepler#in_browser&quot;&gt;Python and Kepler notes&lt;/a&gt;.&lt;/p&gt;  </description>
  <author>Xiaojun Liu</author>
  <version>$Id$</version>
  <since>Ptolemy II 2.3</since>
  <Pt.ProposedRating>Yellow (liuxj)</Pt.ProposedRating>
  <Pt.AcceptedRating>Red (reviewmoderator)</Pt.AcceptedRating>
    <!--ptolemy.kernel.util.StringAttribute-->
    <property name="jythonClassName">The Jython class name to be invoked.  The default value is&#10;  &quot;Main&quot;, which indicates that the &lt;i&gt;script&lt;/i&gt; parameter&#10;  should define a class named &quot;Main&quot;.  If the &lt;i&gt;script&lt;/i&gt;&#10;  parameter imports a Jython module, for example: &quot;import Foo&quot;,&#10;  then Foo.py should define a class named &quot;Main&quot; and this&#10;  parameter should have the value &quot;Foo.Main&quot;.  If the value of&#10;  this parameter is anything other than &quot;Main&quot;, then&#10;  preinitialize() will reread the script.  This is how Jython&#10;  modules can be used.  Note that the &lt;i&gt;jythonClassName&lt;/i&gt;&#10;  parameter should be set to the value of the Jython class name&#10;  before changing the &lt;i&gt;script&lt;/i&gt; parameter to import a Jython&#10;  module.</property>
    <!--ptolemy.kernel.util.StringAttribute-->
    <property name="script">The script that specifies the function of this actor.&#10;  The default value is a script that copies the input to the output.</property>
</doc>
