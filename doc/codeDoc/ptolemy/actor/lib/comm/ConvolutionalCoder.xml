<?xml version="1.0" standalone="yes"?>
<!DOCTYPE doc PUBLIC "-//UC Berkeley//DTD DocML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/DocML_1.dtd">
<doc name="ConvolutionalCoder" class="ptolemy.actor.lib.comm.ConvolutionalCoder">
  <description>
Encode an input sequence with a convolutional code. The inputs and&#10; outputs are booleans.&#10;&#10; &lt;p&gt;The input sequence&#10; enters a shift register, and the contents of the shift register are&#10; combined using boolean functions given by the &lt;i&gt;polynomialArray&lt;/i&gt;&#10; parameter. The initial state of the shift register is given by the&#10; &lt;i&gt;initialState&lt;/i&gt; parameter, which should be a non-negative integer.&#10; The &lt;i&gt;uncodedRate&lt;/i&gt; parameter, often denoted by &lt;i&gt;k&lt;/i&gt; in the&#10; coding literature, is the number of bits per firing that are shifted&#10; into the shift register. The &lt;i&gt;polynomialArray&lt;/i&gt; parameter is an&#10; array of positive integers. Each integer indicates one polynomial&#10; used for computing output bits. To get a &lt;i&gt;k&lt;/i&gt;/&lt;i&gt;n&lt;/i&gt;&#10; convolutional code, set &lt;i&gt;uncodedRate&lt;/i&gt; to &lt;i&gt;k&lt;/i&gt; and provide&#10; &lt;i&gt;n&lt;/i&gt; integers in &lt;i&gt;polynomialArray&lt;/i&gt;.&lt;/p&gt;&#10;&#10; &lt;p&gt; The integers in &lt;i&gt;polynomialArray&lt;/i&gt; are usually most conveniently&#10; given as octal numbers. A leading zero indicates an octal&#10; number. The &lt;i&gt;i&lt;/i&gt;-th bit of the integer indicates whether the&#10; &lt;i&gt;i&lt;/i&gt;-th tap of the delay line should be used.  All bits that&#10; are used are exclusive-ored, thus yielding the parity of the selected&#10; bits. See more details in Scrambler actor on using an integer to&#10; define a polynomial. The &lt;i&gt;n&lt;/i&gt; parity results are produced on&#10; the output in a sequence.&lt;/p&gt;&#10;&#10; &lt;p&gt; A good convolutional code should have large Hamming distance between&#10; any two of its codewords. This is not easily checked, but there are some&#10; simple rules that all &quot;good&quot; codes should satisfy:&lt;/p&gt;&#10; &lt;ol&gt;&#10; &lt;li&gt; &lt;i&gt;k&lt;/i&gt; should be strictly smaller than &lt;i&gt;n&lt;/i&gt;, otherwise&#10; the code is not uniquely decodable.  Thus, &lt;i&gt;uncodedRate&lt;/i&gt;&#10; should be less than the length of &lt;i&gt;polynomialArray&lt;/i&gt;.&lt;/li&gt;&#10; &lt;li&gt; &lt;i&gt;k&lt;/i&gt; should not be higher than the highest order of&#10; all polynomials, otherwise, some input bits never get&#10; involved in computing parities.&lt;/li&gt;&#10; &lt;/ol&gt;&#10;&#10; &lt;p&gt;If these rules are violated, the actor will throw an exception.&#10; However, these rules do not guarantee the codeword can be decoded&#10; successfully, and it is not always true that larger polynomials&#10; yield better codes. Users should check tables for convolutional&#10; codes from professional references. For convenience, we list here&#10; some convolutional codes that have large distance property.&lt;/p&gt;&#10; &lt;pre&gt;&#10; Rate = 1/2&#10; polynomialArray&#10; {05, 07}&#10; {013, 017}&#10; {031, 027}&#10; {065, 057}&#10; {0155, 0117}&#10;&#10; Rate = 1/3&#10; polynomialArray&#10; {05, 07, 07}&#10; {015, 013, 017}&#10; {025, 033, 037}&#10; {071, 065, 057}&#10; {0155, 0123, 0137}&#10;&#10; Rate = 1/4&#10; polynomialArray&#10; {05, 07, 07, 07}&#10; {015, 013, 013, 017}&#10; {025, 035, 033, 037}&#10; {065, 073, 047, 057}&#10; {0135, 0135, 0163, 0147}&#10;&#10; Rate = 1/5&#10; polynomialArray&#10; {07, 07, 07, 05, 05}&#10; {017, 017, 015, 013, 013}&#10; {037, 035, 033, 025, 027}&#10; {057, 047, 067, 053, 075}&#10;&#10; Rate = 1/6&#10; polynomialArray&#10; {07, 07, 07, 07, 05, 05}&#10; {017, 017, 015, 015, 013, 013}&#10; {037, 027, 035, 033, 025, 027}&#10; {067, 057, 055, 053, 071, 075}&#10;&#10; Rate = 2/3&#10; polynomialArray&#10; {017, 06, 013}&#10; {072, 057, 027}&#10; {0171, 0166, 0273}&#10;&#10; Rate = k/5&#10; k     polynomialArray&#10; 2     {017, 016, 011, 05, 02}&#10; 2     {072, 047, 025, 053, 075}&#10; 3     {056, 062, 057, 043, 071}&#10;&#10; Rate = k/7&#10; k     polynomialArray&#10; 2     {012, 06, 05, 013, 013, 015, 017}&#10; 2     {066, 055, 027, 071, 052, 056, 057}&#10; 3     {051, 042, 036, 023, 075, 061, 047}&#10;&#10; Rate  polynomialArray&#10; 3/4   {064, 052, 043, 071}&#10; 3/8   {054, 021, 062, 043, 045, 036, 057, 071}&#10; &lt;/pre&gt;&#10;&#10; &lt;p&gt; Note that this implementation is limited to a shift register&#10; length of 32 because of the specification of the polynomials and&#10; initial shift register state as 32-bit integers.&lt;/p&gt;&#10;&#10; &lt;p&gt;For more information on convolutional codes, see Proakis, Digital&#10; Communications, Fourth Edition, McGraw-Hill, 2001, pp. 471-477,&#10; or Barry, Lee and Messerschmitt, &lt;i&gt;Digital Communication&lt;/i&gt;, Third Edition,&#10; Kluwer, 2004.&lt;/p&gt;  </description>
  <author>Ye Zhou, contributor: Edward A. Lee</author>
  <version>$Id$</version>
  <since>Ptolemy II 3.0</since>
  <Pt.ProposedRating>Yellow (eal)</Pt.ProposedRating>
  <Pt.AcceptedRating>Red (cxh)</Pt.AcceptedRating>
    <!--ptolemy.data.expr.Parameter-->
    <property name="polynomialArray">An array of integers defining an array of polynomials with&#10;  binary coefficients. The coefficients indicate the presence (1)&#10;  or absence (0) of a tap in the shift register. Each element&#10;  of this array parameter should be a positive integer.&#10;  The default value is {05, 07}.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="initialState">Integer defining the initial state of the shift register.&#10;  The i-th bit of the integer indicates the value of the&#10;  i-th register. This parameter should be a non-negative&#10;  integer. Its default value is the integer 0.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="uncodedRate">Integer defining the number of bits that the shift register&#10;  takes in each firing. It should be a positive integer. Its&#10;  default value is the integer 1.</property>
</doc>
