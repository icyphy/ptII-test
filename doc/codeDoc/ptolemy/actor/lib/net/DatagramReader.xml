<?xml version="1.0" standalone="yes"?>
<!DOCTYPE doc PUBLIC "-//UC Berkeley//DTD DocML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/DocML_1.dtd">
<doc name="DatagramReader" class="ptolemy.actor.lib.net.DatagramReader">
  <description>
This actor reads datagram packets via a separate thread.  The thread&#10; responds to datagrams whenever they arrive, giving the actor the ability&#10; to read the datagrams asynchronously.&#10;&#10;&#10; Datagrams are connectionless, open-loop internet communications.  Each&#10; datagram packet contains data plus a return address.  The return&#10; address consists of an IP address and a socket number.  Datagrams use&#10; the UDP protocol under which no reply or confirmation is expected.&#10; This is in contrast to TCP which expects confirmations and attempts to&#10; deliver packets in order to the layer above TCP.  This can result in&#10; long delays in the delivery of information across the network.  Because&#10; UDP makes no such attempts, it never hangs and does not need to be timed out.&#10;&#10; &lt;p&gt;NOTE: This actor has been developed to work in the Discrete Event&#10; (DE) and Synchronous Data Flow (SDF) domains.  Use elsewhere with&#10; caution.&#10;&#10; &lt;p&gt;NOTE: This actor has problems, the tests do not reliably pass.&#10; For details, see &lt;a href=&quot;https://chess.eecs.berkeley.edu/bugzilla/show_bug.cgi?id=54&quot;&gt;&lt;code&gt;https://chess.eecs.berkeley.edu/bugzilla/show_bug.cgi?id=54&lt;/code&gt;&lt;/a&gt;.&#10;&#10; &lt;p&gt; &lt;p&gt;The simplest scenario has the thread constantly stalled&#10; awaiting a packet.  When a packet arrives, the thread quickly queues&#10; it in one of the buffers of the actor, calls the&#10; getDirector().fireAtCurrentTime(), and then stalls again awaiting the&#10; next packet.  By stalling again and again, the thread keeps the actor&#10; aware at all times of incoming packets.  This is particularly&#10; important if packets come in more quickly than the model can process&#10; them.  Depending on the domain (e.g. DE) in which this actor is used,&#10; the director may respond to the fireAtCurrentTime() call of the thread by&#10; calling the fire() method of the actor.  In this case, fire() then&#10; broadcasts the data received, along with the return address and return&#10; socket number from which the datagram originated.&#10;&#10; &lt;p&gt;The data portion of the packet is broadcast at the &lt;i&gt;output&lt;/i&gt; port.&#10; The type of the output is always an array of bytes.&#10;&#10; &lt;p&gt;The return address and socket number are broadcast as String and int&#10; respectively.  These tell where the received datagram originated from.&#10;&#10; &lt;p&gt;The behavior of the actor under less simple scenarios is governed by&#10; parameters of this actor.  Additional packet(s) can arrive while the&#10; director is getting around to calling fire().  Conversely, the&#10; director may make extra calls to fire(), even before any datagrams&#10; have come in.  I call these the eager packet and eager director&#10; scenarios respectively.&#10;&#10; &lt;p&gt;Background: There are two packet buffers.  The thread and the fire()&#10; method share these buffers and maintain consistency via synchronization&#10; on the object &lt;i&gt;_syncFireAndThread&lt;/i&gt;.  This synchronization prevents&#10; conflicts when accessing the shared buffers and when accessing the&#10; count of queued packets.&#10;&#10; &lt;p&gt;The &lt;i&gt;overwrite&lt;/i&gt; parameter applies to the eager packet&#10; scenario.  Setting this parameter to true is useful in cases where it&#10; is possible for data to come in too fast for the model to process.&#10; This setting alleviates data gluts without undue loss of data when the&#10; model is able to keep up.  When &lt;i&gt;overwrite&lt;/i&gt; is set to true (the&#10; default), the actor discards the packet already received in&#10; favor of the new packet.  If false, the new packet is queued behind the&#10; existing one.  In the latter case, both buffers are now full.  The&#10; thread then waits for fire() to consume a queued packet before it&#10; stalls again awaiting the next.  In all other cases (&lt;i&gt;overwrite&lt;/i&gt;&#10; true or no queued packets) the thread immediately stalls to await the&#10; next packet.&#10;&#10; &lt;p&gt;The &lt;i&gt;blockAwaitingDatagram&lt;/i&gt; parameter applies to the eager&#10; director case.  This case comes up most often in SDF, where an actor&#10; is expected to block in fire until an output can be produced.  If&#10; true, a call to fire() will block unless or until a datagram has&#10; arrived.  If false, then fire() returns without waiting, using the&#10; &lt;i&gt;defaultOutput&lt;/i&gt; parameter in place of real data.  The&#10; &lt;i&gt;returnAddress&lt;/i&gt; and &lt;i&gt;returnSocketNumber&lt;/i&gt; ports have default&#10; outputs as well, but they are not parameter-programmable.&#10;&#10; &lt;p&gt;&#10; &lt;p&gt;NOTE: This actor has a parameter &lt;i&gt;localSocketNumber&lt;/i&gt; for the port&#10; number assigned to its local datagram socket.  Initially, the local&#10; socket number is set to 4004.  There is no particular reason for choosing&#10; this number, except that is noticeable in the code and in Vergil, thus&#10; encouraging you to change it to any desired value in the range 0..65535.&#10; Note that socket numbers 0..1023 are generally reserved and numbers 1024 and&#10; above are generally available.&#10;&#10; &lt;p&gt;Some commonly used port numbers (a.k.a. socket numbers) are shown below:&#10; &lt;pre&gt;&#10; Well-known Ports&#10; (Commonly Used Ports)&#10; 7        (Echo)&#10; 21        (FTP)&#10; 23        (TELNET)&#10; 25        (SMTP)&#10; 53        (DNS)&#10; 79        (finger)&#10; 80        (HTTP)&#10; 110        (POP3)&#10; 119        (NNTP)&#10; 161        (SNMP)&#10; 162        (SNMP Trap)&#10; &lt;/pre&gt;&#10; Reference:  http://192.168.1.1/Forward.htm&#10; (A webpage hosted from within the Linksys BEFSR41 Cable/DSL Router)&#10;&#10; &lt;p&gt;NOTE: This actor can also be configured to handle multicase datagram&#10; socket. A MulticastSocket is a DatagramSocket with additional capabilities&#10; to join groups of other multicast hosts on the internet. A multicast group&#10; is specified by a class D IP address and a standard UDP port number.&#10; When one member sends a packet to a multicast group, all recipients&#10; subscribing to that host and port receive the packet.&#10; Currently, The parameter &lt;i&gt;defaultReturnAddress&lt;/i&gt; is overloaded to specify&#10; a multicast datagram IP address. When the return address is a multicast IP&#10; address, The parameter &lt;i&gt;localSocketNumber&lt;/i&gt; is used to specify the&#10; UDP port number for the multicast group. A multicast IP address&#10; ranges from 224.0.0.0 to 239.255.255.255, inclusive. To send a packet to the&#10; group, the sender can be either a DatagramSocket or a MulticastSocket. The&#10; only difference is that MulticastSocket allows you to control the time-to-live&#10; of the datagram. Don't use 224.0.0.1 ~ 224.255.255.255 when the live time of&#10; is specified larger than 1.&#10;&#10; &lt;p&gt;FIXME: we might not want to overload the &lt;i&gt;defaultReturnAddress&lt;/i&gt; and&#10; the &lt;i&gt;localSocketNumber&lt;/i&gt; parameter...&#10;&#10; &lt;p&gt;Another useful tidbit is the command 'netstat'.  This works in a&#10; DOS prompt and also in the UNIX-like Bash shell.  In either shell,&#10; enter 'netstat -an'.  This command shows current port allocations!  Ports&#10; allocated to Ptolemy models are shown along with other port allocations.&#10; Other useful network commands include 'ping' and 'tracert'.&#10; Both TCP and UDP (datagram) ports are shown by netstat.&#10; FIXME: Find out whether a TCP port using a specific number blocks a&#10; UDP port from using that same number.  </description>
  <author>Winthrop Williams, Joern Janneck, Xiaojun Liu, Edward Lee&#10; (Based on TiltSensor actor written&#10; by Chamberlain Fong, Xiaojun Liu, Edward Lee)</author>
  <version>$Id$</version>
  <since>Ptolemy II 2.0</since>
  <Pt.ProposedRating>Yellow (winthrop)</Pt.ProposedRating>
  <Pt.AcceptedRating>Yellow (winthrop)</Pt.AcceptedRating>
    <!--ptolemy.actor.TypedIOPort-->
    <port name="returnAddress">This port outputs the IP address portion of the received&#10;  datagram packet.  The type of this output is String.  This is&#10;  the IP address of the remote datagram socket which sent the&#10;  packet to the socket of this actor.  Under IPv4, this string has&#10;  the familiar form &quot;128.32.1.1&quot;.  This output defaults (when no&#10;  datagram has been received and blocking is false) to the IP&#10;  address of the socket.</port>
    <!--ptolemy.actor.TypedIOPort-->
    <port name="returnSocketNumber">This port outputs the socket (a.k.a port) number portion of the&#10;  received datagram packet.  The type of this output is int.&#10;  This is the socket number of the remote datagram socket which&#10;  sent the packet to this actor's socket.  This is an integer in&#10;  the range 0 through 65535.  This output defaults (when no&#10;  datagram has been received and blocking is false) to this&#10;  actor's local socket number.</port>
    <!--ptolemy.actor.TypedIOPort-->
    <port name="output">This port outputs the data portion of the received datagram&#10;  packet.  The type of &lt;i&gt;output&lt;/i&gt; may depend on the datagram&#10;  received, which may vary even during a single run of a model.&#10;  &lt;b&gt;The user is encouraged to play with the configuration of&#10;  this port&lt;/b&gt; to best suit the need at hand.</port>
    <!--ptolemy.actor.TypedIOPort-->
    <port name="trigger">The trigger input port reads and discards a token from each&#10;  channel that has a token.  The type of this port has been set&#10;  to GENERAL, permitting any token type to be accepted.  The&#10;  hasToken() and get(int) methods are called on this input, but&#10;  their contents are discarded.  The presence of a connection to&#10;  this input serves a purpose by causing the director to&#10;  schedule the firing of this actor at an appropriate place in&#10;  the sequence of firings of actors.  This is particularly&#10;  useful in the SDF domain.  Without a trigger input, the SDF&#10;  scheduler would be unable to schedule a firing of this actor&#10;  unless it can be scheduled as the first actor to be fired.&#10;  Thus, without this input, configurations in SDF would be&#10;  limited.  (@See ptolemy.actor.lib.Source for an archetypal&#10;  trigger input.)</port>
    <!--ptolemy.data.expr.Parameter-->
    <property name="localSocketNumber">This actor's local socket (a.k.a. port) number.  &lt;b&gt;This is a&#10;  system resource allocated to this actor.&lt;/b&gt; No other actor&#10;  with the same local socket number may run at the same time.&#10;  Currently, When the return address is a multicast IP address,&#10;  this parameter is also used to specify the UDP port number&#10;  for the multicast group.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="actorBufferLength">Length (in bytes) of each of the actor's two packet buffers for&#10;  receiving a datagram.  This length does not include the bytes&#10;  needed for storing the datagram's return address and other&#10;  housekeeping information.  This buffer need only be big enough&#10;  to hold the payload (a.k.a. data portion) of the datagram.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="platformBufferLength">Length (in bytes) of the buffer within java and/or the&#10;  platform layers below java.  Java documents refers to all this&#10;  collectively as the platform.  The size of this buffer is&#10;  controlled via the getReceiveBufferSize() and&#10;  setReceiveBufferSize() methods.  @see java.net.DatagramSocket.&#10;  Caution #1 - The platform treats setReceiveBufferSize() as a&#10;  suggestion only.  It supposedly reports the actual buffer size&#10;  granted in subsequent calls to getReceiveBufferSize().&#10;  However, my experiments with this showed it granting buffers&#10;  as large as 2 gigabytes, with no apparent limit except the&#10;  maximum representable integer value.  Thus, I suggest taking&#10;  this with a grain of salt.  Caution #2 - the&#10;  get/setReceiveBufferSize() calls block when called as long as&#10;  another thread is in a receive() call on that same socket.&#10;  This is undocumented in Java's documentation.  Also note that&#10;  the setReceiveBufferSize() method is not available in early&#10;  JDK's, which makes it important to have&#10;  setPlatformBufferLength set to false when generating code.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="setPlatformBufferLength">Determine whether the platformBufferLength parameter will be&#10;  used to set the platform's receive buffer size.  This&#10;  parameter must contain a boolean token, and has a default of&#10;  false.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="overwrite">Whether to overwrite when inundated with datagrams or let&#10;  them pile up.  Default is true.  If false, datagrams will&#10;  queue up (mostly in the platform, some in the actor).  The&#10;  datagram used at each invocation of fire will be the oldest in&#10;  the queue.  On the other hand, if &lt;i&gt;overwrite&lt;/i&gt; is true,&#10;  then minimal queuing will occur and the most recent data will&#10;  be used when fire() is called.  Older data will be discarded.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="blockAwaitingDatagram">Whether to block in fire().  If fire() is called before the&#10;  datagram has arrived, the actor must either block awaiting the&#10;  datagram or use its &lt;i&gt;defaultOutput&lt;/i&gt;.  This blocking&#10;  parameter controls which choice fire() will make.  This&#10;  parameter is useful for SDF models, where it is generally set&#10;  to true.  It has no effect in DE models unless the trigger&#10;  input has been connected.  Type is Boolean.  Default value is&#10;  true.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="defaultReturnAddress">The default for the &lt;i&gt;returnAddress&lt;/i&gt; output.  This token is&#10;  broadcast when the actor is fired, but no actual datagram&#10;  is available to broadcast and &lt;i&gt;blockAwaitingDatagram&lt;/i&gt; is&#10;  false.  If blocking were true, the actor would simply stall in&#10;  fire() until a datagram arrives.  Type is string.  Default value&#10;  is &quot;localhost&quot;.&#10;  Currently, this parameter can be overloaded to specify a multicast&#10;  datagram IP address. A multicast IP address ranges from&#10;  224.0.0.0 to 239.255.255.255, inclusive.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="defaultReturnSocketNumber">The default the &lt;i&gt;returnSocketNumber&lt;/i&gt; output.  This token is&#10;  broadcast when the actor is fired, but no actual datagram&#10;  is available to broadcast and &lt;i&gt;blockAwaitingDatagram&lt;/i&gt; is&#10;  false.  If blocking were true, the actor would simply stall in&#10;  fire() until a datagram arrives.  Type is integer.  Default&#10;  value is 0.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="defaultOutput">The default for the &lt;i&gt;output&lt;/i&gt; output.  This default token&#10;  is broadcast when the actor is fired, but no actual datagram&#10;  data is available to broadcast and&#10;  &lt;i&gt;blockAwaitingDatagram&lt;/i&gt; is false.  If blocking were true,&#10;  the actor would simply stall in fire() until a datagram&#10;  arrives.  Type is defined by the expression entered.  Default&#10;  type and value is the integer 0.</property>
</doc>
