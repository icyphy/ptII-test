<?xml version="1.0" standalone="yes"?>
<!DOCTYPE doc PUBLIC "-//UC Berkeley//DTD DocML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/DocML_1.dtd">
<doc name="Manager" class="ptolemy.actor.Manager">
  <description>
A Manager governs the execution of a model in a domain-independent way.&#10; Its methods are designed to be called by a GUI, an applet, a command-line&#10; interface, or the top-level code of an application.  The manager can&#10; execute the model in the calling thread or in a separate thread.&#10; The latter is useful when the caller wishes to remain live during&#10; the execution of the model.&#10;&#10; &lt;p&gt; There are three methods that can be used to start execution of a&#10; system attached to the manager.  The execute() method is the most&#10; basic way to execute a model.  The model will be executed&#10; &lt;i&gt;synchronously&lt;/i&gt;, meaning that the execute() method will return&#10; when execution has completed.  Any exceptions that occur will be&#10; thrown by the execute method to the calling thread, and will not be&#10; reported to any execution listeners.  The run() method also initiates&#10; synchronous execution of a model, but additionally catches all&#10; exceptions and passes them to the notifyListenersOfException() method&#10; &lt;i&gt;without throwing them to the calling thread&lt;/i&gt;.  The startRun()&#10; method, unlike the previous two techniques, begins &lt;i&gt;asynchronous&lt;/i&gt;&#10; execution of a model.  This method starts a new thread for execution&#10; of the model and then returns immediately.  Exceptions are reported&#10; using the notifyListenersOfException() method.&#10;&#10; &lt;p&gt; In addition, execution can be manually driven, one phase at a&#10; time, using the methods initialize(), iterate() and wrapup().  This is&#10; most useful for testing purposes.  For example, a type system check&#10; only needs to get the resolved types, which are found during&#10; initialize, so the test can avoid actually executing the system.&#10; Also, when testing mutations, the model can be examined after each&#10; toplevel iteration to ensure the proper behavior.&#10;&#10; &lt;p&gt; A manager provides services for cleanly handling changes to the&#10; topology.  These include such changes as adding or removing an entity,&#10; port, or relation, creating or destroying a link, and changing the&#10; value or type of a parameter.  Collectively, such changes are called&#10; &lt;i&gt;mutations&lt;/i&gt;. Usually, mutations cannot safely occur at arbitrary&#10; points in the execution of a model.  Models can queue mutations with&#10; any object in the hierarchy or with the manager using the&#10; requestChange() method.  An object in the hierarchy simply delegates&#10; the request to its container, so the request propagates up the&#10; hierarchy until it gets to the top level composite actor, which&#10; delegates to the manager, which performs the change at the earliest&#10; opportunity.  In this implementation of Manager, the changes are&#10; executed between iterations.&#10;&#10; &lt;p&gt; A service is also provided whereby an object can be registered&#10; with the composite actor as a change listener.  A change listener is&#10; informed when mutations that are requested via requestChange() are&#10; executed successfully, or when they fail with an exception.&#10;&#10; &lt;p&gt; Manager can optimize the performance of an execution by making the&#10; workspace &lt;i&gt;write protected&lt;/i&gt; during an iteration, if all relevant&#10; directors permit this.  This removes some of the overhead of obtaining&#10; read and write permission on the workspace.  By default, directors do&#10; not permit this, but many directors explicitly relinquish write access&#10; to allow faster execution.  Such directors are declaring that they&#10; will not make changes to the topology during execution.  Instead, any&#10; desired mutations are delegated to the manager via the requestChange()&#10; method.&#10;&#10; &lt;p&gt; Many domains make use of static analyses for performing, e.g.,&#10; static scheduling of actor firings.  In some cases, these analyses&#10; must make use of global information.  The class provides a centralized&#10; mechanism for managing such global analyses.  During preinitialize,&#10; domains can invoke the getAnalysis and addAnalysis methods to create a&#10; global analysis.  It is up to the users of this mechanism to ensure&#10; that a particular type of analysis is only created once, if that is&#10; what is required.  After preinitialize, the manager clears the list of&#10; analyses, to avoid unnecessary memory usage, and to ensure that the&#10; analyses are performed again on the next invocation of the model.&#10; This is somewhat preferable to tying a cache of analysis information&#10; to the version of the workspace, since the version number of the&#10; workspace itself may change during preinitialize as domains add&#10; annotation to the model.  </description>
  <author>Steve Neuendorffer, Lukito Muliadi, Edward A. Lee, Elaine Cheong, Contributor: Mudit Goel, John S. Davis II, Bert Rodiers, Daniel Crawl</author>
  <version>$Id$</version>
  <since>Ptolemy II 0.2</since>
  <Pt.ProposedRating>Green (neuendor)</Pt.ProposedRating>
  <Pt.AcceptedRating>Yellow (cxh)</Pt.AcceptedRating>
</doc>
