<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>IOPort</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../jquery/jquery-3.3.1.js"></script>
<script type="text/javascript" src="../../jquery/jquery-migrate-3.0.1.js"></script>
<script type="text/javascript" src="../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="IOPort";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":42,"i27":10,"i28":42,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":42,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":10,"i44":9,"i45":10,"i46":10,"i47":10,"i48":10,"i49":10,"i50":10,"i51":10,"i52":10,"i53":10,"i54":10,"i55":10,"i56":10,"i57":10,"i58":10,"i59":10,"i60":10,"i61":10,"i62":10,"i63":10,"i64":10,"i65":10,"i66":10,"i67":10,"i68":10,"i69":10,"i70":10,"i71":10,"i72":10,"i73":10,"i74":10,"i75":10,"i76":10,"i77":10,"i78":10,"i79":10,"i80":10,"i81":10,"i82":10,"i83":10,"i84":10,"i85":10,"i86":10,"i87":10,"i88":10,"i89":10,"i90":42,"i91":42,"i92":10,"i93":10,"i94":10,"i95":10,"i96":10,"i97":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">ptolemy.actor</a></div>
<h2 title="Class IOPort" class="title">Class IOPort</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li><a href="../kernel/util/NamedObj.html" title="class in ptolemy.kernel.util">ptolemy.kernel.util.NamedObj</a></li>
<li>
<ul class="inheritance">
<li><a href="../kernel/Port.html" title="class in ptolemy.kernel">ptolemy.kernel.Port</a></li>
<li>
<ul class="inheritance">
<li><a href="../kernel/ComponentPort.html" title="class in ptolemy.kernel">ptolemy.kernel.ComponentPort</a></li>
<li>
<ul class="inheritance">
<li>ptolemy.actor.IOPort</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><code>java.lang.Cloneable</code>, <code><a href="../kernel/util/Changeable.html" title="interface in ptolemy.kernel.util">Changeable</a></code>, <code><a href="../kernel/util/Debuggable.html" title="interface in ptolemy.kernel.util">Debuggable</a></code>, <code><a href="../kernel/util/DebugListener.html" title="interface in ptolemy.kernel.util">DebugListener</a></code>, <code><a href="../kernel/util/Derivable.html" title="interface in ptolemy.kernel.util">Derivable</a></code>, <code><a href="../kernel/util/ModelErrorHandler.html" title="interface in ptolemy.kernel.util">ModelErrorHandler</a></code>, <code><a href="../kernel/util/MoMLExportable.html" title="interface in ptolemy.kernel.util">MoMLExportable</a></code>, <code><a href="../kernel/util/Moveable.html" title="interface in ptolemy.kernel.util">Moveable</a></code>, <code><a href="../kernel/util/Nameable.html" title="interface in ptolemy.kernel.util">Nameable</a></code></dd>
</dl>
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="TypedIOPort.html" title="class in ptolemy.actor">TypedIOPort</a></code></dd>
</dl>
<hr>
<pre>public class <span class="typeNameLabel">IOPort</span>
extends <a href="../kernel/ComponentPort.html" title="class in ptolemy.kernel">ComponentPort</a></pre>
<div class="block">This class supports exchanging data between entities via message passing.
 It can serve as an input port, an output port, or both. If it is an
 input port, then it contains some number of receivers, which are
 responsible for receiving data from remote entities. If it is an
 output port, then it can send data to remote receivers.

 <p>
 Its receivers are created by a director.  It must therefore be
 contained by an actor that has a director.  If it is not, then
 any attempt to read data or list the receivers will trigger
 an exception.

 <p>
 If this port is at the boundary of an composite actor, then it
 can have both inside and outside links, with corresponding inside
 and outside receivers if it opaque. The inside links are to
 relations inside the opaque composite actor, whereas the outside
 links are to relations outside. If it is not specified, then a link
 is an outside link.

 <p>
 The port has a <i>defaultValue</i> parameter that, by default, is
 empty. If this parameter is not empty, the port always has a token.
 The value of the port is initially specified by the defaultValue.
 Afterwards, the previous token of the port is remembered.
 The defaultValue may optionally be an array, in which case a different
 default value can be different for each channel.
 If the port is wider than the array, then only the first <i>n</i>
 channels will have default values, where <i>n</i> is the length of
 the array.

 <p>
 The port has a <i>width</i>, which by default is constrained to
 be either zero or one.
 The width is the sum of the widths of the linked relations.
 A port with a width greater than one behaves as a bus interface,
 so if the width is <i>w</i>, then the port can simultaneously
 handle <i>w</i> distinct input or output channels of data.

 <p>
 In general, an input port might have more than one receiver for
 each channel.  This occurs particularly for transparent input ports,
 which treat the receivers of the ports linked on the inside as its own.
 This might also occur for opaque ports in some derived classes.
 Each receiver in the group is sent the same data. Thus, an input port in
 general will have <i>w</i> distinct groups of receivers, and can receive
 <i>w</i> distinct channels.

 <p>
 By default, the maximum width of the port is one, so only one
 channel is handled. A port that allows a width greater than one
 is called a <i>multiport</i>. Calling setMultiport() with a
 <i>true</i> argument converts the port to a multiport.

 <p>
 The width of the port is not set directly. It is the sum of the
 widths of the relations that the port is linked to on the outside.
 The sum of the widths of the relations linked on the inside can be
 more or less than the width.  If it is more, then the excess inside
 relations will be treated as if they are unconnected.  If it is
 less, then the excess outside relations will be treated as if they
 are unconnected.

 <p>
 An IOPort can only link to instances of IORelation. Derived classes
 may further constrain links to a subclass of IORelation.  To do
 this, they should override the protected methods _checkLink() and
 _checkLiberalLink() to throw an exception if their arguments are
 not of the appropriate type.  Similarly, an IOPort can only be
 contained by a class derived from ComponentEntity and implementing
 the Actor interface.  Subclasses may further constrain the
 containers by overriding the protected method _checkContainer().</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Ptolemy II 0.2</dd>
<dt><span class="simpleTagLabel">Version:</span></dt>
<dd>$Id$</dd>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>Edward A. Lee, Jie Liu, Neil Smyth, Lukito Muliadi, Contributor: Bert Rodiers</dd>
<dt><span class="simpleTagLabel">Pt.AcceptedRating:</span></dt>
<dd>Red (neuendor)</dd>
<dt><span class="simpleTagLabel">Pt.ProposedRating:</span></dt>
<dd>Green (eal)</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<ul class="blockList">
<li class="blockList"><a id="nested.classes.inherited.from.class.ptolemy.kernel.util.NamedObj">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from class&nbsp;ptolemy.kernel.util.<a href="../kernel/util/NamedObj.html" title="class in ptolemy.kernel.util">NamedObj</a></h3>
<code><a href="../kernel/util/NamedObj.ContainedObjectsIterator.html" title="class in ptolemy.kernel.util">NamedObj.ContainedObjectsIterator</a></code></li>
</ul>
</li>
</ul>
</section>
<!-- =========== FIELD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_constantLimit">_constantLimit</a></span></code></th>
<td class="colLast">
<div class="block">The limit of the number of constant values to return instead
 of the received tokens.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../data/Token.html" title="class in ptolemy.data">Token</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_constantToken">_constantToken</a></span></code></th>
<td class="colLast">
<div class="block">The constant value to return instead of the received tokens.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_constantTokensSent">_constantTokensSent</a></span></code></th>
<td class="colLast">
<div class="block">The number of constant tokens that have been sent since the last
  call to _setConstant().</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_hasPortEventListeners">_hasPortEventListeners</a></span></code></th>
<td class="colLast">
<div class="block">Flag that is true if there are port event listeners.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.util.List&lt;<a href="IOPortEventListener.html" title="interface in ptolemy.actor">IOPortEventListener</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_portEventListeners">_portEventListeners</a></span></code></th>
<td class="colLast">
<div class="block">The list of IOPortEventListeners registered with this object.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#CONFIGURATION">CONFIGURATION</a></span></code></th>
<td class="colLast">
<div class="block">Indicate that the description(int) method should include information
  about whether the port is an input, output, or multiport, whether it
  is opaque, and what is its width.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../data/expr/Parameter.html" title="class in ptolemy.data.expr">Parameter</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#defaultValue">defaultValue</a></span></code></th>
<td class="colLast">
<div class="block">The default value of the port.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#RECEIVERS">RECEIVERS</a></span></code></th>
<td class="colLast">
<div class="block">Indicate that the description(int) method should include receivers
  contained by this port (if any).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#REMOTERECEIVERS">REMOTERECEIVERS</a></span></code></th>
<td class="colLast">
<div class="block">Indicate that the description(int) method should include receivers
  remotely connected to this port (if any).</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="fields.inherited.from.class.ptolemy.kernel.Port">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;ptolemy.kernel.<a href="../kernel/Port.html" title="class in ptolemy.kernel">Port</a></h3>
<code><a href="../kernel/Port.html#_insideLinks">_insideLinks</a>, <a href="../kernel/Port.html#_relationsList">_relationsList</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="fields.inherited.from.class.ptolemy.kernel.util.NamedObj">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;ptolemy.kernel.util.<a href="../kernel/util/NamedObj.html" title="class in ptolemy.kernel.util">NamedObj</a></h3>
<code><a href="../kernel/util/NamedObj.html#_changeListeners">_changeListeners</a>, <a href="../kernel/util/NamedObj.html#_changeLock">_changeLock</a>, <a href="../kernel/util/NamedObj.html#_changeRequests">_changeRequests</a>, <a href="../kernel/util/NamedObj.html#_debugging">_debugging</a>, <a href="../kernel/util/NamedObj.html#_debugListeners">_debugListeners</a>, <a href="../kernel/util/NamedObj.html#_deferChangeRequests">_deferChangeRequests</a>, <a href="../kernel/util/NamedObj.html#_elementName">_elementName</a>, <a href="../kernel/util/NamedObj.html#_isPersistent">_isPersistent</a>, <a href="../kernel/util/NamedObj.html#_verbose">_verbose</a>, <a href="../kernel/util/NamedObj.html#_workspace">_workspace</a>, <a href="../kernel/util/NamedObj.html#ATTRIBUTES">ATTRIBUTES</a>, <a href="../kernel/util/NamedObj.html#CLASSNAME">CLASSNAME</a>, <a href="../kernel/util/NamedObj.html#COMPLETE">COMPLETE</a>, <a href="../kernel/util/NamedObj.html#CONTENTS">CONTENTS</a>, <a href="../kernel/util/NamedObj.html#DEEP">DEEP</a>, <a href="../kernel/util/NamedObj.html#FULLNAME">FULLNAME</a>, <a href="../kernel/util/NamedObj.html#LINKS">LINKS</a></code></li>
</ul>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">IOPort</a></span>()</code></th>
<td class="colLast">
<div class="block">Construct an IOPort with no container and no name that is
  neither an input nor an output.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(ptolemy.kernel.ComponentEntity,java.lang.String)">IOPort</a></span>&#8203;(<a href="../kernel/ComponentEntity.html" title="class in ptolemy.kernel">ComponentEntity</a>&nbsp;container,
      java.lang.String&nbsp;name)</code></th>
<td class="colLast">
<div class="block">Construct an IOPort with a containing actor and a name
  that is neither an input nor an output.</div>
</td>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(ptolemy.kernel.ComponentEntity,java.lang.String,boolean,boolean)">IOPort</a></span>&#8203;(<a href="../kernel/ComponentEntity.html" title="class in ptolemy.kernel">ComponentEntity</a>&nbsp;container,
      java.lang.String&nbsp;name,
      boolean&nbsp;isInput,
      boolean&nbsp;isOutput)</code></th>
<td class="colLast">
<div class="block">Construct an IOPort with a container and a name that is
  either an input, an output, or both, depending on the third
  and fourth arguments.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(ptolemy.kernel.util.Workspace)">IOPort</a></span>&#8203;(<a href="../kernel/util/Workspace.html" title="class in ptolemy.kernel.util">Workspace</a>&nbsp;workspace)</code></th>
<td class="colLast">
<div class="block">Construct a port in the specified workspace with an empty
  string as a name.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_checkContainer(ptolemy.kernel.Entity)">_checkContainer</a></span>&#8203;(<a href="../kernel/Entity.html" title="class in ptolemy.kernel">Entity</a>&nbsp;container)</code></th>
<td class="colLast">
<div class="block">Check that the specified container implements the Actor interface
  (or is null).</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_checkLiberalLink(ptolemy.kernel.Relation)">_checkLiberalLink</a></span>&#8203;(<a href="../kernel/Relation.html" title="class in ptolemy.kernel">Relation</a>&nbsp;relation)</code></th>
<td class="colLast">
<div class="block">Override parent method to ensure compatibility of the relation
  and validity of the width of the port.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_checkLink(ptolemy.kernel.Relation)">_checkLink</a></span>&#8203;(<a href="../kernel/Relation.html" title="class in ptolemy.kernel">Relation</a>&nbsp;relation)</code></th>
<td class="colLast">
<div class="block">Override parent method to ensure compatibility of the relation
  and validity of the width of the port.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>protected java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_description(int,int,int)">_description</a></span>&#8203;(int&nbsp;detail,
            int&nbsp;indent,
            int&nbsp;bracket)</code></th>
<td class="colLast">
<div class="block">Return a description of the object.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_exportMoMLContents(java.io.Writer,int)">_exportMoMLContents</a></span>&#8203;(java.io.Writer&nbsp;output,
                   int&nbsp;depth)</code></th>
<td class="colLast">
<div class="block">Write a MoML description of the contents of this object, which
  in this class is the attributes plus possibly a special attribute
  to indicate whether the port is a multiport.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_getInsideWidth(ptolemy.actor.IORelation)">_getInsideWidth</a></span>&#8203;(<a href="IORelation.html" title="class in ptolemy.actor">IORelation</a>&nbsp;except)</code></th>
<td class="colLast">
<div class="block">Return the sums of the widths of the relations linked on the
  inside, except the specified relation.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_getOutsideWidth(ptolemy.actor.IORelation)">_getOutsideWidth</a></span>&#8203;(<a href="IORelation.html" title="class in ptolemy.actor">IORelation</a>&nbsp;except)</code></th>
<td class="colLast">
<div class="block">Return the sums of the widths of the relations linked on the
  outside, except the specified relation.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>protected <a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_getReceiversLinkedToGroup(ptolemy.actor.IORelation,int)">_getReceiversLinkedToGroup</a></span>&#8203;(<a href="IORelation.html" title="class in ptolemy.actor">IORelation</a>&nbsp;relation,
                          int&nbsp;occurrence)</code></th>
<td class="colLast">
<div class="block">If the port is an input, return receivers that handle incoming
  channels from the specified relation or any relation in its
  relation group.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>protected <a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_newInsideReceiver()">_newInsideReceiver</a></span>()</code></th>
<td class="colLast">
<div class="block">Create a new receiver compatible with the local director.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>protected <a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_newInsideReceiver(int)">_newInsideReceiver</a></span>&#8203;(int&nbsp;channel)</code></th>
<td class="colLast">
<div class="block">Create a new receiver compatible with the local director.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>protected <a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_newReceiver()">_newReceiver</a></span>()</code></th>
<td class="colLast">
<div class="block">Create a new receiver compatible with the executive director.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>protected <a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_newReceiver(int)">_newReceiver</a></span>&#8203;(int&nbsp;channel)</code></th>
<td class="colLast">
<div class="block">Create a new receiver compatible with the executive director.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_notifyPortEventListeners(ptolemy.actor.IOPortEvent)">_notifyPortEventListeners</a></span>&#8203;(<a href="IOPortEvent.html" title="class in ptolemy.actor">IOPortEvent</a>&nbsp;event)</code></th>
<td class="colLast">
<div class="block">Send a PortEvent to all port event listeners that
  have registered with this IOPort.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_removeReceivers(ptolemy.kernel.Relation)">_removeReceivers</a></span>&#8203;(<a href="../kernel/Relation.html" title="class in ptolemy.kernel">Relation</a>&nbsp;relation)</code></th>
<td class="colLast">
<div class="block">Remove the receivers associated with the specified
  relation, if there are any.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_setConstant(ptolemy.data.Token,int)">_setConstant</a></span>&#8203;(<a href="../data/Token.html" title="class in ptolemy.data">Token</a>&nbsp;token,
            int&nbsp;limit)</code></th>
<td class="colLast">
<div class="block">Set a constant token so that every call to <a href="#get(int)"><code>get(int)</code></a>
  or <a href="#get(int,int)"><code>get(int,int)</code></a> replaces the returned token(s) with
  this specified token.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>protected <a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#_wrapReceiver(ptolemy.actor.Receiver,int)">_wrapReceiver</a></span>&#8203;(<a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>&nbsp;receiver,
             int&nbsp;channel)</code></th>
<td class="colLast">
<div class="block">If this port has parameters whose values are tokens that contain
  an object implementing <a href="CommunicationAspect.html" title="interface in ptolemy.actor"><code>CommunicationAspect</code></a>, then wrap the
  receiver specified in the argument using those communication aspects.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addIOPortEventListener(ptolemy.actor.IOPortEventListener)">addIOPortEventListener</a></span>&#8203;(<a href="IOPortEventListener.html" title="interface in ptolemy.actor">IOPortEventListener</a>&nbsp;listener)</code></th>
<td class="colLast">
<div class="block">Append a listener to the current set of port event listeners.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#attributeChanged(ptolemy.kernel.util.Attribute)">attributeChanged</a></span>&#8203;(<a href="../kernel/util/Attribute.html" title="class in ptolemy.kernel.util">Attribute</a>&nbsp;attribute)</code></th>
<td class="colLast">
<div class="block">If a communication aspect is added, removed or modified,
  invalidate the list of communication aspects which is read again
  in the preinitialize phase.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#broadcast(ptolemy.data.Token)">broadcast</a></span>&#8203;(<a href="../data/Token.html" title="class in ptolemy.data">Token</a>&nbsp;token)</code></th>
<td class="colLast">
<div class="block">Send a token to all connected receivers.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#broadcast(ptolemy.data.Token%5B%5D,int)">broadcast</a></span>&#8203;(<a href="../data/Token.html" title="class in ptolemy.data">Token</a>[]&nbsp;tokenArray,
         int&nbsp;vectorLength)</code></th>
<td class="colLast">
<div class="block">Send the specified portion of a token array to all receivers connected
  to this port.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#broadcastClear()">broadcastClear</a></span>()</code></th>
<td class="colLast">
<div class="block">Set all receivers connected on the outside to have no
  tokens.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#checkWidthConstraints()">checkWidthConstraints</a></span>()</code></th>
<td class="colLast">
<div class="block">Check whether the widths constraints are met.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clone(ptolemy.kernel.util.Workspace)">clone</a></span>&#8203;(<a href="../kernel/util/Workspace.html" title="class in ptolemy.kernel.util">Workspace</a>&nbsp;workspace)</code></th>
<td class="colLast">
<div class="block">Clone this port into the specified workspace.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code><a href="../data/Token.html" title="class in ptolemy.data">Token</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#convert(ptolemy.data.Token)">convert</a></span>&#8203;(<a href="../data/Token.html" title="class in ptolemy.data">Token</a>&nbsp;token)</code></th>
<td class="colLast">
<div class="block">Convert the specified token into a token acceptable to
  this port.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createReceivers()">createReceivers</a></span>()</code></th>
<td class="colLast">
<div class="block">Create new receivers for this port, replacing any that may
  previously exist, and validate any instances of Settable that
  this port may contain.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;<a href="IOPort.html" title="class in ptolemy.actor">IOPort</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#deepConnectedInPortList()">deepConnectedInPortList</a></span>()</code></th>
<td class="colLast">
<div class="block">Return a list of input ports connected to this port on the
  outside.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>java.util.Enumeration</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#deepConnectedInPorts()">deepConnectedInPorts</a></span>()</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use deepConnectedInPortList() instead.</div>
</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;<a href="IOPort.html" title="class in ptolemy.actor">IOPort</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#deepConnectedOutPortList()">deepConnectedOutPortList</a></span>()</code></th>
<td class="colLast">
<div class="block">Return a list of output ports connected to this port on the
  outside.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>java.util.Enumeration</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#deepConnectedOutPorts()">deepConnectedOutPorts</a></span>()</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use deepConnectedInPortList() instead.</div>
</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code><a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#deepGetReceivers()">deepGetReceivers</a></span>()</code></th>
<td class="colLast">
<div class="block">If the port is an input, return the receivers deeply linked on
  the inside.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code><a href="../data/Token.html" title="class in ptolemy.data">Token</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#get(int)">get</a></span>&#8203;(int&nbsp;channelIndex)</code></th>
<td class="colLast">
<div class="block">Get a token from the specified channel.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code><a href="../data/Token.html" title="class in ptolemy.data">Token</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#get(int,int)">get</a></span>&#8203;(int&nbsp;channelIndex,
   int&nbsp;vectorLength)</code></th>
<td class="colLast">
<div class="block">Get an array of tokens from the specified channel.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getChannelForReceiver(ptolemy.actor.Receiver)">getChannelForReceiver</a></span>&#8203;(<a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>&nbsp;receiver)</code></th>
<td class="colLast">
<div class="block">Return the corresponding channel in this port for the given receiver.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;<a href="CommunicationAspect.html" title="interface in ptolemy.actor">CommunicationAspect</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getCommunicationAspects()">getCommunicationAspects</a></span>()</code></th>
<td class="colLast">
<div class="block">Return the list of communication aspects in this port.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getCurrentTime(int)">getCurrentTime</a></span>&#8203;(int&nbsp;channelIndex)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">As Ptolemy II 4.1,
  replaced by <a href="#getModelTime(int)"><code>getModelTime(int)</code></a>.</div>
</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getDefaultWidth()">getDefaultWidth</a></span>()</code></th>
<td class="colLast">
<div class="block">Get the default width.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code><a href="../data/Token.html" title="class in ptolemy.data">Token</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getInside(int)">getInside</a></span>&#8203;(int&nbsp;channelIndex)</code></th>
<td class="colLast">
<div class="block">Get a token from the specified inside channel of this port.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code><a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getInsideReceivers()">getInsideReceivers</a></span>()</code></th>
<td class="colLast">
<div class="block">If the port is an opaque output port, return the receivers that
  receive data from all inside linked relations.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>java.util.List&lt;<a href="IOPortEventListener.html" title="interface in ptolemy.actor">IOPortEventListener</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getIOPortEventListeners()">getIOPortEventListeners</a></span>()</code></th>
<td class="colLast">
<div class="block">Get the listeners for IOPortEvents.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code><a href="util/Time.html" title="class in ptolemy.actor.util">Time</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getModelTime(int)">getModelTime</a></span>&#8203;(int&nbsp;channelIndex)</code></th>
<td class="colLast">
<div class="block">Return the current time associated with a certain channel.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code><a href="util/Time.html" title="class in ptolemy.actor.util">Time</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getModelTime(int,boolean)">getModelTime</a></span>&#8203;(int&nbsp;channelIndex,
            boolean&nbsp;inside)</code></th>
<td class="colLast">
<div class="block">Return the current time associated with a certain channel.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code><a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getReceivers()">getReceivers</a></span>()</code></th>
<td class="colLast">
<div class="block">If the port is an input, return the receivers that receive data
  from all linked relations.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code><a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getReceivers(ptolemy.actor.IORelation)">getReceivers</a></span>&#8203;(<a href="IORelation.html" title="class in ptolemy.actor">IORelation</a>&nbsp;relation)</code></th>
<td class="colLast">
<div class="block">If the port is an input, return receivers that handle incoming
  channels from the specified relation.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code><a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getReceivers(ptolemy.actor.IORelation,int)">getReceivers</a></span>&#8203;(<a href="IORelation.html" title="class in ptolemy.actor">IORelation</a>&nbsp;relation,
            int&nbsp;occurrence)</code></th>
<td class="colLast">
<div class="block">If the port is an input, return receivers that handle incoming
  channels from the specified relation.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRelationIndex(ptolemy.actor.IOPort,ptolemy.kernel.Relation,boolean)">getRelationIndex</a></span>&#8203;(<a href="IOPort.html" title="class in ptolemy.actor">IOPort</a>&nbsp;port,
                <a href="../kernel/Relation.html" title="class in ptolemy.kernel">Relation</a>&nbsp;relation,
                boolean&nbsp;isOutsideRelation)</code></th>
<td class="colLast">
<div class="block">Retrieve the index of the relation at the port.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code><a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRemoteReceivers()">getRemoteReceivers</a></span>()</code></th>
<td class="colLast">
<div class="block">If the port is an output, return the remote receivers that can
  receive from the port.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code><a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRemoteReceivers(ptolemy.actor.IORelation)">getRemoteReceivers</a></span>&#8203;(<a href="IORelation.html" title="class in ptolemy.actor">IORelation</a>&nbsp;relation)</code></th>
<td class="colLast">
<div class="block">If this port is an output, return the remote receivers that can
  receive data from this port through the specified relation or
  any relation in its relation group.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getWidth()">getWidth</a></span>()</code></th>
<td class="colLast">
<div class="block">Return the width of the port.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getWidthFromConstraints()">getWidthFromConstraints</a></span>()</code></th>
<td class="colLast">
<div class="block">Get the width from the constraints put on the width
  of this port if the width is fully determined.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getWidthInside()">getWidthInside</a></span>()</code></th>
<td class="colLast">
<div class="block">Return the inside width of this port.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasNewToken(int)">hasNewToken</a></span>&#8203;(int&nbsp;channelIndex)</code></th>
<td class="colLast">
<div class="block">Return true if the specified channel has a new token to deliver
  via the get() method.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasNewTokenInside(int)">hasNewTokenInside</a></span>&#8203;(int&nbsp;channelIndex)</code></th>
<td class="colLast">
<div class="block">Return true if the specified channel has a token to deliver
  via the getInside() method.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasRoom(int)">hasRoom</a></span>&#8203;(int&nbsp;channelIndex)</code></th>
<td class="colLast">
<div class="block">Return true if the specified channel can accept a token via the
  put() method.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasRoomInside(int)">hasRoomInside</a></span>&#8203;(int&nbsp;channelIndex)</code></th>
<td class="colLast">
<div class="block">Return true if the specified channel can accept a token via
  the putInside() method.</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasToken(int)">hasToken</a></span>&#8203;(int&nbsp;channelIndex)</code></th>
<td class="colLast">
<div class="block">Return true if the port is persistent (see <a href="#defaultValue"><code>defaultValue</code></a>),
  or if the most recent input was an <a href="../data/SmoothToken.html" title="class in ptolemy.data"><code>SmoothToken</code></a>, or
  if the specified channel has a token to deliver
  via the get() method.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasToken(int,int)">hasToken</a></span>&#8203;(int&nbsp;channelIndex,
        int&nbsp;tokens)</code></th>
<td class="colLast">
<div class="block">Return true if the specified channel has the specified number
  of tokens to deliver via the get() method.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasTokenInside(int)">hasTokenInside</a></span>&#8203;(int&nbsp;channelIndex)</code></th>
<td class="colLast">
<div class="block">Return true if the port is persisent or the specified channel
  has a token to deliver
  via the getInside() method.</div>
</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasWidthConstraints()">hasWidthConstraints</a></span>()</code></th>
<td class="colLast">
<div class="block">Return whether there are constraints on the width of
  this port.</div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#insertLink(int,ptolemy.kernel.Relation)">insertLink</a></span>&#8203;(int&nbsp;index,
          <a href="../kernel/Relation.html" title="class in ptolemy.kernel">Relation</a>&nbsp;relation)</code></th>
<td class="colLast">
<div class="block">Override the base class to invalidate the schedule and resolved
  types of the director of the container, if there is one, in addition
  to what the base class does.</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;<a href="IOPort.html" title="class in ptolemy.actor">IOPort</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#insideSinkPortList()">insideSinkPortList</a></span>()</code></th>
<td class="colLast">
<div class="block">Return a list of the ports that may accept data from this port
  when it sends on the inside.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code>java.util.List&lt;<a href="IOPort.html" title="class in ptolemy.actor">IOPort</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#insideSourcePortList()">insideSourcePortList</a></span>()</code></th>
<td class="colLast">
<div class="block">Return a list of the ports that can send data to this port
  from the inside.</div>
</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#invalidateCommunicationAspects()">invalidateCommunicationAspects</a></span>()</code></th>
<td class="colLast">
<div class="block">Invalidate the communication aspect list.</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isInput()">isInput</a></span>()</code></th>
<td class="colLast">
<div class="block">Return true if the port is an input.</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isInsideConnected()">isInsideConnected</a></span>()</code></th>
<td class="colLast">
<div class="block">Return whether the port has relations connected on the inside.</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isKnown()">isKnown</a></span>()</code></th>
<td class="colLast">
<div class="block">Return true if all channels of this port have known state; that is,
  the tokens on each channel are known, or each channel is known not to
  have any tokens.</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isKnown(int)">isKnown</a></span>&#8203;(int&nbsp;channelIndex)</code></th>
<td class="colLast">
<div class="block">Return <i>true</i> if the specified channel has known state;
  that is, the tokens on this channel are known, or this channel
  is known not to have any tokens.</div>
</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isKnownInside(int)">isKnownInside</a></span>&#8203;(int&nbsp;channelIndex)</code></th>
<td class="colLast">
<div class="block">Return <i>true</i> if the specified inside channel has known state;
  that is, the tokens on this channel are known, or this channel
  is known not to have any tokens.</div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isMultiport()">isMultiport</a></span>()</code></th>
<td class="colLast">
<div class="block">Return true if the port is a multiport.</div>
</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isOutput()">isOutput</a></span>()</code></th>
<td class="colLast">
<div class="block">Return true if the port is an output.</div>
</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isOutsideConnected()">isOutsideConnected</a></span>()</code></th>
<td class="colLast">
<div class="block">Return whether the port has relations connected on the outside.</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#liberalLink(ptolemy.kernel.ComponentRelation)">liberalLink</a></span>&#8203;(<a href="../kernel/ComponentRelation.html" title="class in ptolemy.kernel">ComponentRelation</a>&nbsp;relation)</code></th>
<td class="colLast">
<div class="block">Override the base class to invalidate the schedule and resolved
  types of the director of the container, if there is one, in addition
  to what the base class does.</div>
</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#link(ptolemy.kernel.Relation)">link</a></span>&#8203;(<a href="../kernel/Relation.html" title="class in ptolemy.kernel">Relation</a>&nbsp;relation)</code></th>
<td class="colLast">
<div class="block">Override the base class to invalidate the schedule and resolved
  types of the director of the container, if there is one, in addition
  to what the base class does.</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#numberOfSinks()">numberOfSinks</a></span>()</code></th>
<td class="colLast">
<div class="block">Return the number of sink ports that may receive data from this one.</div>
</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#numberOfSources()">numberOfSources</a></span>()</code></th>
<td class="colLast">
<div class="block">Return the number of source ports that may send data to this one.</div>
</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removeIOPortEventListener(ptolemy.actor.IOPortEventListener)">removeIOPortEventListener</a></span>&#8203;(<a href="IOPortEventListener.html" title="interface in ptolemy.actor">IOPortEventListener</a>&nbsp;listener)</code></th>
<td class="colLast">
<div class="block">Unregister a token sent listener.</div>
</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reset()">reset</a></span>()</code></th>
<td class="colLast">
<div class="block">If port has default value reset the saved persistent value.</div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#send(int,ptolemy.data.Token)">send</a></span>&#8203;(int&nbsp;channelIndex,
    <a href="../data/Token.html" title="class in ptolemy.data">Token</a>&nbsp;token)</code></th>
<td class="colLast">
<div class="block">Send the specified token to all receivers connected to the
  specified channel.</div>
</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#send(int,ptolemy.data.Token%5B%5D,int)">send</a></span>&#8203;(int&nbsp;channelIndex,
    <a href="../data/Token.html" title="class in ptolemy.data">Token</a>[]&nbsp;tokenArray,
    int&nbsp;vectorLength)</code></th>
<td class="colLast">
<div class="block">Send the specified portion of a token array to all receivers connected
  to the specified channel.</div>
</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sendClear(int)">sendClear</a></span>&#8203;(int&nbsp;channelIndex)</code></th>
<td class="colLast">
<div class="block">Set all destination receivers connected via the specified to channel
  to have no token.</div>
</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sendClearInside(int)">sendClearInside</a></span>&#8203;(int&nbsp;channelIndex)</code></th>
<td class="colLast">
<div class="block">Set all destination receivers connected on the inside via the specified
  to channel to have no token.</div>
</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sendInside(int,ptolemy.data.Token)">sendInside</a></span>&#8203;(int&nbsp;channelIndex,
          <a href="../data/Token.html" title="class in ptolemy.data">Token</a>&nbsp;token)</code></th>
<td class="colLast">
<div class="block">Send the specified token to all receivers connected to the
  specified inside channel of this port.</div>
</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setContainer(ptolemy.kernel.Entity)">setContainer</a></span>&#8203;(<a href="../kernel/Entity.html" title="class in ptolemy.kernel">Entity</a>&nbsp;container)</code></th>
<td class="colLast">
<div class="block">Override the base class to ensure that the proposed container
  implements the Actor interface (the base class ensures that the
  container is an instance of ComponentEntity) or null.</div>
</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setDefaultWidth(int)">setDefaultWidth</a></span>&#8203;(int&nbsp;defaultWidth)</code></th>
<td class="colLast">
<div class="block">Set the default width.</div>
</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setInput(boolean)">setInput</a></span>&#8203;(boolean&nbsp;isInput)</code></th>
<td class="colLast">
<div class="block">If the argument is true, make the port an input port.</div>
</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setMultiport(boolean)">setMultiport</a></span>&#8203;(boolean&nbsp;isMultiport)</code></th>
<td class="colLast">
<div class="block">If the argument is true, make the port a multiport.</div>
</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setOutput(boolean)">setOutput</a></span>&#8203;(boolean&nbsp;isOutput)</code></th>
<td class="colLast">
<div class="block">If the argument is true, make the port an output port.</div>
</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setWidthEquals(ptolemy.actor.IOPort,boolean)">setWidthEquals</a></span>&#8203;(<a href="IOPort.html" title="class in ptolemy.actor">IOPort</a>&nbsp;port,
              boolean&nbsp;bidirectional)</code></th>
<td class="colLast">
<div class="block">Constrain the width of this port to be equal to the width of
  the IOPort port.</div>
</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setWidthEquals(ptolemy.data.expr.Parameter)">setWidthEquals</a></span>&#8203;(<a href="../data/expr/Parameter.html" title="class in ptolemy.data.expr">Parameter</a>&nbsp;parameter)</code></th>
<td class="colLast">
<div class="block">Constrain the width of this port to be equal to the parameter.</div>
</td>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code>java.util.List&lt;<a href="IOPort.html" title="class in ptolemy.actor">IOPort</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sinkPortList()">sinkPortList</a></span>()</code></th>
<td class="colLast">
<div class="block">Return a list of the ports that may accept data from this port when
  it sends on the outside.</div>
</td>
</tr>
<tr id="i89" class="rowColor">
<td class="colFirst"><code>java.util.List&lt;<a href="IOPort.html" title="class in ptolemy.actor">IOPort</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sourcePortList()">sourcePortList</a></span>()</code></th>
<td class="colLast">
<div class="block">Return a list of ports that may send data to this port from the
  outside.</div>
</td>
</tr>
<tr id="i90" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#transferInputs()">transferInputs</a></span>()</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Domains should use sendInside directly to
  implement their transferInputs method.</div>
</div>
</td>
</tr>
<tr id="i91" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#transferOutputs()">transferOutputs</a></span>()</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">domains should use getInside directly to implement their
  transferOutputs method.</div>
</div>
</td>
</tr>
<tr id="i92" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unlink(int)">unlink</a></span>&#8203;(int&nbsp;index)</code></th>
<td class="colLast">
<div class="block">Unlink whatever relation is currently linked at the specified index
  number.</div>
</td>
</tr>
<tr id="i93" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unlink(ptolemy.kernel.Relation)">unlink</a></span>&#8203;(<a href="../kernel/Relation.html" title="class in ptolemy.kernel">Relation</a>&nbsp;relation)</code></th>
<td class="colLast">
<div class="block">Unlink the specified Relation.</div>
</td>
</tr>
<tr id="i94" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unlinkAll()">unlinkAll</a></span>()</code></th>
<td class="colLast">
<div class="block">Unlink all relations that are linked on the outside.</div>
</td>
</tr>
<tr id="i95" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unlinkAllInside()">unlinkAllInside</a></span>()</code></th>
<td class="colLast">
<div class="block">Unlink all relations that are linked on the inside.</div>
</td>
</tr>
<tr id="i96" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unlinkInside(int)">unlinkInside</a></span>&#8203;(int&nbsp;index)</code></th>
<td class="colLast">
<div class="block">Unlink whatever relation is currently linked on the inside
  with the specified index number.</div>
</td>
</tr>
<tr id="i97" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unlinkInside(ptolemy.kernel.Relation)">unlinkInside</a></span>&#8203;(<a href="../kernel/Relation.html" title="class in ptolemy.kernel">Relation</a>&nbsp;relation)</code></th>
<td class="colLast">
<div class="block">Unlink the specified Relation on the inside.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.ptolemy.kernel.ComponentPort">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;ptolemy.kernel.<a href="../kernel/ComponentPort.html" title="class in ptolemy.kernel">ComponentPort</a></h3>
<code><a href="../kernel/ComponentPort.html#_deepConnectedPortList(java.util.LinkedList)">_deepConnectedPortList</a>, <a href="../kernel/ComponentPort.html#_deepConnectedPorts(java.util.LinkedList)">_deepConnectedPorts</a>, <a href="../kernel/ComponentPort.html#_deepInsidePortList(java.util.LinkedList)">_deepInsidePortList</a>, <a href="../kernel/ComponentPort.html#_deepInsidePorts(java.util.LinkedList)">_deepInsidePorts</a>, <a href="../kernel/ComponentPort.html#_isInsideLinkable(ptolemy.kernel.util.Nameable)">_isInsideLinkable</a>, <a href="../kernel/ComponentPort.html#deepConnectedPortList()">deepConnectedPortList</a>, <a href="../kernel/ComponentPort.html#deepConnectedPorts()">deepConnectedPorts</a>, <a href="../kernel/ComponentPort.html#deepInsidePortList()">deepInsidePortList</a>, <a href="../kernel/ComponentPort.html#deepInsidePorts()">deepInsidePorts</a>, <a href="../kernel/ComponentPort.html#insertInsideLink(int,ptolemy.kernel.Relation)">insertInsideLink</a>, <a href="../kernel/ComponentPort.html#insidePortList()">insidePortList</a>, <a href="../kernel/ComponentPort.html#insidePorts()">insidePorts</a>, <a href="../kernel/ComponentPort.html#insideRelationList()">insideRelationList</a>, <a href="../kernel/ComponentPort.html#insideRelations()">insideRelations</a>, <a href="../kernel/ComponentPort.html#isDeeplyConnected(ptolemy.kernel.ComponentPort)">isDeeplyConnected</a>, <a href="../kernel/ComponentPort.html#isInsideGroupLinked(ptolemy.kernel.Relation)">isInsideGroupLinked</a>, <a href="../kernel/ComponentPort.html#isInsideLinked(ptolemy.kernel.Relation)">isInsideLinked</a>, <a href="../kernel/ComponentPort.html#isOpaque()">isOpaque</a>, <a href="../kernel/ComponentPort.html#numInsideLinks()">numInsideLinks</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.ptolemy.kernel.Port">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;ptolemy.kernel.<a href="../kernel/Port.html" title="class in ptolemy.kernel">Port</a></h3>
<code><a href="../kernel/Port.html#_getContainedObject(ptolemy.kernel.util.NamedObj,java.lang.String)">_getContainedObject</a>, <a href="../kernel/Port.html#_propagateExistence(ptolemy.kernel.util.NamedObj)">_propagateExistence</a>, <a href="../kernel/Port.html#connectedPortList()">connectedPortList</a>, <a href="../kernel/Port.html#connectedPorts()">connectedPorts</a>, <a href="../kernel/Port.html#getContainer()">getContainer</a>, <a href="../kernel/Port.html#isGroupLinked(ptolemy.kernel.Relation)">isGroupLinked</a>, <a href="../kernel/Port.html#isLinked(ptolemy.kernel.Relation)">isLinked</a>, <a href="../kernel/Port.html#linkedRelationList()">linkedRelationList</a>, <a href="../kernel/Port.html#linkedRelations()">linkedRelations</a>, <a href="../kernel/Port.html#moveDown()">moveDown</a>, <a href="../kernel/Port.html#moveToFirst()">moveToFirst</a>, <a href="../kernel/Port.html#moveToIndex(int)">moveToIndex</a>, <a href="../kernel/Port.html#moveToLast()">moveToLast</a>, <a href="../kernel/Port.html#moveUp()">moveUp</a>, <a href="../kernel/Port.html#numLinks()">numLinks</a>, <a href="../kernel/Port.html#setName(java.lang.String)">setName</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.ptolemy.kernel.util.NamedObj">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;ptolemy.kernel.util.<a href="../kernel/util/NamedObj.html" title="class in ptolemy.kernel.util">NamedObj</a></h3>
<code><a href="../kernel/util/NamedObj.html#_addAttribute(ptolemy.kernel.util.Attribute)">_addAttribute</a>, <a href="../kernel/util/NamedObj.html#_adjustOverride(int)">_adjustOverride</a>, <a href="../kernel/util/NamedObj.html#_attachText(java.lang.String,java.lang.String)">_attachText</a>, <a href="../kernel/util/NamedObj.html#_cloneFixAttributeFields(ptolemy.kernel.util.NamedObj)">_cloneFixAttributeFields</a>, <a href="../kernel/util/NamedObj.html#_containedDecorators()">_containedDecorators</a>, <a href="../kernel/util/NamedObj.html#_copyChangeRequestList()">_copyChangeRequestList</a>, <a href="../kernel/util/NamedObj.html#_debug(java.lang.String)">_debug</a>, <a href="../kernel/util/NamedObj.html#_debug(java.lang.String,java.lang.String)">_debug</a>, <a href="../kernel/util/NamedObj.html#_debug(java.lang.String,java.lang.String,java.lang.String)">_debug</a>, <a href="../kernel/util/NamedObj.html#_debug(java.lang.String,java.lang.String,java.lang.String,java.lang.String)">_debug</a>, <a href="../kernel/util/NamedObj.html#_debug(ptolemy.kernel.util.DebugEvent)">_debug</a>, <a href="../kernel/util/NamedObj.html#_executeChangeRequests(java.util.List)">_executeChangeRequests</a>, <a href="../kernel/util/NamedObj.html#_getIndentPrefix(int)">_getIndentPrefix</a>, <a href="../kernel/util/NamedObj.html#_isMoMLSuppressed(int)">_isMoMLSuppressed</a>, <a href="../kernel/util/NamedObj.html#_markContentsDerived(int)">_markContentsDerived</a>, <a href="../kernel/util/NamedObj.html#_notifyHierarchyListenersAfterChange()">_notifyHierarchyListenersAfterChange</a>, <a href="../kernel/util/NamedObj.html#_notifyHierarchyListenersBeforeChange()">_notifyHierarchyListenersBeforeChange</a>, <a href="../kernel/util/NamedObj.html#_propagateValue(ptolemy.kernel.util.NamedObj)">_propagateValue</a>, <a href="../kernel/util/NamedObj.html#_removeAttribute(ptolemy.kernel.util.Attribute)">_removeAttribute</a>, <a href="../kernel/util/NamedObj.html#_splitName(java.lang.String)">_splitName</a>, <a href="../kernel/util/NamedObj.html#_stripNumericSuffix(java.lang.String)">_stripNumericSuffix</a>, <a href="../kernel/util/NamedObj.html#_validateSettables(java.util.Collection)">_validateSettables</a>, <a href="../kernel/util/NamedObj.html#addChangeListener(ptolemy.kernel.util.ChangeListener)">addChangeListener</a>, <a href="../kernel/util/NamedObj.html#addDebugListener(ptolemy.kernel.util.DebugListener)">addDebugListener</a>, <a href="../kernel/util/NamedObj.html#addHierarchyListener(ptolemy.kernel.util.HierarchyListener)">addHierarchyListener</a>, <a href="../kernel/util/NamedObj.html#attributeDeleted(ptolemy.kernel.util.Attribute)">attributeDeleted</a>, <a href="../kernel/util/NamedObj.html#attributeList()">attributeList</a>, <a href="../kernel/util/NamedObj.html#attributeList(java.lang.Class)">attributeList</a>, <a href="../kernel/util/NamedObj.html#attributeTypeChanged(ptolemy.kernel.util.Attribute)">attributeTypeChanged</a>, <a href="../kernel/util/NamedObj.html#clone()">clone</a>, <a href="../kernel/util/NamedObj.html#containedObjectsIterator()">containedObjectsIterator</a>, <a href="../kernel/util/NamedObj.html#decorators()">decorators</a>, <a href="../kernel/util/NamedObj.html#deepContains(ptolemy.kernel.util.NamedObj)">deepContains</a>, <a href="../kernel/util/NamedObj.html#depthInHierarchy()">depthInHierarchy</a>, <a href="../kernel/util/NamedObj.html#description()">description</a>, <a href="../kernel/util/NamedObj.html#description(int)">description</a>, <a href="../kernel/util/NamedObj.html#event(ptolemy.kernel.util.DebugEvent)">event</a>, <a href="../kernel/util/NamedObj.html#executeChangeRequests()">executeChangeRequests</a>, <a href="../kernel/util/NamedObj.html#exportMoML()">exportMoML</a>, <a href="../kernel/util/NamedObj.html#exportMoML(java.io.Writer)">exportMoML</a>, <a href="../kernel/util/NamedObj.html#exportMoML(java.io.Writer,int)">exportMoML</a>, <a href="../kernel/util/NamedObj.html#exportMoML(java.io.Writer,int,java.lang.String)">exportMoML</a>, <a href="../kernel/util/NamedObj.html#exportMoML(java.lang.String)">exportMoML</a>, <a href="../kernel/util/NamedObj.html#exportMoMLPlain()">exportMoMLPlain</a>, <a href="../kernel/util/NamedObj.html#getAttribute(java.lang.String)">getAttribute</a>, <a href="../kernel/util/NamedObj.html#getAttribute(java.lang.String,java.lang.Class)">getAttribute</a>, <a href="../kernel/util/NamedObj.html#getAttributes()">getAttributes</a>, <a href="../kernel/util/NamedObj.html#getChangeListeners()">getChangeListeners</a>, <a href="../kernel/util/NamedObj.html#getClassName()">getClassName</a>, <a href="../kernel/util/NamedObj.html#getDecoratorAttribute(ptolemy.kernel.util.Decorator,java.lang.String)">getDecoratorAttribute</a>, <a href="../kernel/util/NamedObj.html#getDecoratorAttributes(ptolemy.kernel.util.Decorator)">getDecoratorAttributes</a>, <a href="../kernel/util/NamedObj.html#getDerivedLevel()">getDerivedLevel</a>, <a href="../kernel/util/NamedObj.html#getDerivedList()">getDerivedList</a>, <a href="../kernel/util/NamedObj.html#getDisplayName()">getDisplayName</a>, <a href="../kernel/util/NamedObj.html#getElementName()">getElementName</a>, <a href="../kernel/util/NamedObj.html#getFullName()">getFullName</a>, <a href="../kernel/util/NamedObj.html#getModelErrorHandler()">getModelErrorHandler</a>, <a href="../kernel/util/NamedObj.html#getName()">getName</a>, <a href="../kernel/util/NamedObj.html#getName(ptolemy.kernel.util.NamedObj)">getName</a>, <a href="../kernel/util/NamedObj.html#getPrototypeList()">getPrototypeList</a>, <a href="../kernel/util/NamedObj.html#getSource()">getSource</a>, <a href="../kernel/util/NamedObj.html#handleModelError(ptolemy.kernel.util.NamedObj,ptolemy.kernel.util.IllegalActionException)">handleModelError</a>, <a href="../kernel/util/NamedObj.html#isDeferringChangeRequests()">isDeferringChangeRequests</a>, <a href="../kernel/util/NamedObj.html#isOverridden()">isOverridden</a>, <a href="../kernel/util/NamedObj.html#isPersistent()">isPersistent</a>, <a href="../kernel/util/NamedObj.html#lazyContainedObjectsIterator()">lazyContainedObjectsIterator</a>, <a href="../kernel/util/NamedObj.html#message(java.lang.String)">message</a>, <a href="../kernel/util/NamedObj.html#notifyOfNameChange(ptolemy.kernel.util.NamedObj)">notifyOfNameChange</a>, <a href="../kernel/util/NamedObj.html#propagateExistence()">propagateExistence</a>, <a href="../kernel/util/NamedObj.html#propagateValue()">propagateValue</a>, <a href="../kernel/util/NamedObj.html#propagateValues()">propagateValues</a>, <a href="../kernel/util/NamedObj.html#removeAttribute(ptolemy.kernel.util.Attribute)">removeAttribute</a>, <a href="../kernel/util/NamedObj.html#removeChangeListener(ptolemy.kernel.util.ChangeListener)">removeChangeListener</a>, <a href="../kernel/util/NamedObj.html#removeDebugListener(ptolemy.kernel.util.DebugListener)">removeDebugListener</a>, <a href="../kernel/util/NamedObj.html#removeHierarchyListener(ptolemy.kernel.util.HierarchyListener)">removeHierarchyListener</a>, <a href="../kernel/util/NamedObj.html#requestChange(ptolemy.kernel.util.ChangeRequest)">requestChange</a>, <a href="../kernel/util/NamedObj.html#setClassName(java.lang.String)">setClassName</a>, <a href="../kernel/util/NamedObj.html#setDeferringChangeRequests(boolean)">setDeferringChangeRequests</a>, <a href="../kernel/util/NamedObj.html#setDerivedLevel(int)">setDerivedLevel</a>, <a href="../kernel/util/NamedObj.html#setDisplayName(java.lang.String)">setDisplayName</a>, <a href="../kernel/util/NamedObj.html#setModelErrorHandler(ptolemy.kernel.util.ModelErrorHandler)">setModelErrorHandler</a>, <a href="../kernel/util/NamedObj.html#setPersistent(boolean)">setPersistent</a>, <a href="../kernel/util/NamedObj.html#setSource(java.lang.String)">setSource</a>, <a href="../kernel/util/NamedObj.html#sortContainedObjects(java.util.Collection)">sortContainedObjects</a>, <a href="../kernel/util/NamedObj.html#toplevel()">toplevel</a>, <a href="../kernel/util/NamedObj.html#toString()">toString</a>, <a href="../kernel/util/NamedObj.html#uniqueName(java.lang.String)">uniqueName</a>, <a href="../kernel/util/NamedObj.html#validateSettables()">validateSettables</a>, <a href="../kernel/util/NamedObj.html#workspace()">workspace</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a id="defaultValue">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defaultValue</h4>
<pre>public&nbsp;<a href="../data/expr/Parameter.html" title="class in ptolemy.data.expr">Parameter</a> defaultValue</pre>
<div class="block">The default value of the port. By default, this parameter is
  empty. If this value is not empty, then the port is persistent,
  which means that the get methods always return a token (they never
  throw NoTokenException), and that <a href="#hasToken(int)"><code>hasToken(int)</code></a>,
  <a href="#hasToken(int,int)"><code>hasToken(int, int)</code></a>,
  and <a href="#hasTokenInside(int)"><code>hasTokenInside(int)</code></a>
  always return true, indicating that a token is available.
  To determine whether there is a new token, use
  <a href="#hasNewToken(int)"><code>hasNewToken(int)</code></a> or <a href="#hasNewTokenInside(int)"><code>hasNewTokenInside(int)</code></a>.
  <p>
  The defaultValue may optionally be an array, in which case a different
  default value can be different for each channel.
  If the port is wider than the array, then only the first <i>n</i>
  channels will have default values, where <i>n</i> is the length of
  the array.
  <p>
  If this port is an output port, then the persistent value is
  used only when retrieving a token from the inside. I.e., it
  will be used only if the output port belongs to an opaque
  composite actor.</div>
</li>
</ul>
<a id="CONFIGURATION">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CONFIGURATION</h4>
<pre>public static final&nbsp;int CONFIGURATION</pre>
<div class="block">Indicate that the description(int) method should include information
  about whether the port is an input, output, or multiport, whether it
  is opaque, and what is its width.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#ptolemy.actor.IOPort.CONFIGURATION">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="RECEIVERS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RECEIVERS</h4>
<pre>public static final&nbsp;int RECEIVERS</pre>
<div class="block">Indicate that the description(int) method should include receivers
  contained by this port (if any).</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#ptolemy.actor.IOPort.RECEIVERS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="REMOTERECEIVERS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>REMOTERECEIVERS</h4>
<pre>public static final&nbsp;int REMOTERECEIVERS</pre>
<div class="block">Indicate that the description(int) method should include receivers
  remotely connected to this port (if any).</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#ptolemy.actor.IOPort.REMOTERECEIVERS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="_constantLimit">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_constantLimit</h4>
<pre>protected&nbsp;int _constantLimit</pre>
<div class="block">The limit of the number of constant values to return instead
 of the received tokens. This is protected so that AbstractReceiver
 can access it.</div>
</li>
</ul>
<a id="_constantToken">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_constantToken</h4>
<pre>protected&nbsp;<a href="../data/Token.html" title="class in ptolemy.data">Token</a> _constantToken</pre>
<div class="block">The constant value to return instead of the received tokens.
  This is protected so that AbstractReceiver can access it.</div>
</li>
</ul>
<a id="_constantTokensSent">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_constantTokensSent</h4>
<pre>protected&nbsp;int _constantTokensSent</pre>
<div class="block">The number of constant tokens that have been sent since the last
  call to _setConstant(). This is protected so that AbstractReceiver
 can access it.</div>
</li>
</ul>
<a id="_hasPortEventListeners">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_hasPortEventListeners</h4>
<pre>protected&nbsp;boolean _hasPortEventListeners</pre>
<div class="block">Flag that is true if there are port event listeners.</div>
</li>
</ul>
<a id="_portEventListeners">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>_portEventListeners</h4>
<pre>protected&nbsp;java.util.List&lt;<a href="IOPortEventListener.html" title="interface in ptolemy.actor">IOPortEventListener</a>&gt; _portEventListeners</pre>
<div class="block">The list of IOPortEventListeners registered with this object.
  NOTE: Because of the way we synchronize on this object, it should
  never be reset to null after the first list is created.</div>
</li>
</ul>
</li>
</ul>
</section>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>IOPort</h4>
<pre>public&nbsp;IOPort()</pre>
<div class="block">Construct an IOPort with no container and no name that is
  neither an input nor an output.</div>
</li>
</ul>
<a id="&lt;init&gt;(ptolemy.kernel.util.Workspace)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>IOPort</h4>
<pre>public&nbsp;IOPort&#8203;(<a href="../kernel/util/Workspace.html" title="class in ptolemy.kernel.util">Workspace</a>&nbsp;workspace)
       throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Construct a port in the specified workspace with an empty
  string as a name. You can then change the name with setName().
  If the workspace argument
  is null, then use the default workspace.
  The object is added to the workspace directory.
  Increment the version number of the workspace.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>workspace</code> - The workspace that will list the port.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If thrown by the superclass
  or while initializing</dd>
</dl>
</li>
</ul>
<a id="&lt;init&gt;(ptolemy.kernel.ComponentEntity,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>IOPort</h4>
<pre>public&nbsp;IOPort&#8203;(<a href="../kernel/ComponentEntity.html" title="class in ptolemy.kernel">ComponentEntity</a>&nbsp;container,
              java.lang.String&nbsp;name)
       throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a>,
              <a href="../kernel/util/NameDuplicationException.html" title="class in ptolemy.kernel.util">NameDuplicationException</a></pre>
<div class="block">Construct an IOPort with a containing actor and a name
  that is neither an input nor an output.  The specified container
  must implement the Actor interface, or an exception will be thrown.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>container</code> - The container actor.</dd>
<dd><code>name</code> - The name of the port.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the port is not of an acceptable
   class for the container, or if the container does not implement the
   Actor interface.</dd>
<dd><code><a href="../kernel/util/NameDuplicationException.html" title="class in ptolemy.kernel.util">NameDuplicationException</a></code> - If the name coincides with
   a port already in the container.</dd>
</dl>
</li>
</ul>
<a id="&lt;init&gt;(ptolemy.kernel.ComponentEntity,java.lang.String,boolean,boolean)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>IOPort</h4>
<pre>public&nbsp;IOPort&#8203;(<a href="../kernel/ComponentEntity.html" title="class in ptolemy.kernel">ComponentEntity</a>&nbsp;container,
              java.lang.String&nbsp;name,
              boolean&nbsp;isInput,
              boolean&nbsp;isOutput)
       throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a>,
              <a href="../kernel/util/NameDuplicationException.html" title="class in ptolemy.kernel.util">NameDuplicationException</a></pre>
<div class="block">Construct an IOPort with a container and a name that is
  either an input, an output, or both, depending on the third
  and fourth arguments. The specified container must implement
  the Actor interface or an exception will be thrown.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>container</code> - The container actor.</dd>
<dd><code>name</code> - The name of the port.</dd>
<dd><code>isInput</code> - True if this is to be an input port.</dd>
<dd><code>isOutput</code> - True if this is to be an output port.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the port is not of an acceptable
   class for the container, or if the container does not implement the
   Actor interface.</dd>
<dd><code><a href="../kernel/util/NameDuplicationException.html" title="class in ptolemy.kernel.util">NameDuplicationException</a></code> - If the name coincides with
   a port already in the container.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="addIOPortEventListener(ptolemy.actor.IOPortEventListener)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addIOPortEventListener</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;addIOPortEventListener&#8203;(<a href="IOPortEventListener.html" title="interface in ptolemy.actor">IOPortEventListener</a>&nbsp;listener)</pre>
<div class="block">Append a listener to the current set of port event listeners.
  If the listener is already in the set, it will not be added again.
  Note that this method is basically the same as addDebugListener
  in the class NamedObj.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>listener</code> - The listener to which to send token sent messages.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#removeIOPortEventListener(ptolemy.actor.IOPortEventListener)"><code>removeIOPortEventListener(IOPortEventListener)</code></a></dd>
</dl>
</li>
</ul>
<a id="attributeChanged(ptolemy.kernel.util.Attribute)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>attributeChanged</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;attributeChanged&#8203;(<a href="../kernel/util/Attribute.html" title="class in ptolemy.kernel.util">Attribute</a>&nbsp;attribute)
                      throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">If a communication aspect is added, removed or modified,
  invalidate the list of communication aspects which is read again
  in the preinitialize phase.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="../kernel/util/NamedObj.html#attributeChanged(ptolemy.kernel.util.Attribute)">attributeChanged</a></code>&nbsp;in class&nbsp;<code><a href="../kernel/util/NamedObj.html" title="class in ptolemy.kernel.util">NamedObj</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>attribute</code> - The attribute that changed.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the new color
      attribute cannot be created.</dd>
</dl>
</li>
</ul>
<a id="broadcast(ptolemy.data.Token)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>broadcast</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;broadcast&#8203;(<a href="../data/Token.html" title="class in ptolemy.data">Token</a>&nbsp;token)
               throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a>,
                      <a href="NoRoomException.html" title="class in ptolemy.actor">NoRoomException</a></pre>
<div class="block">Send a token to all connected receivers.
  Tokens are in general immutable, so each receiver is given a
  reference to the same token and no clones are made.
  The transfer is accomplished by calling getRemoteReceivers()
  to determine the number of channels with valid receivers and
  then putting the token into the receivers.
  If there are no destination receivers, then nothing is sent.
  If the port is not connected to anything, or receivers have not been
  created in the remote port, then just return.
  <p>
  Some of this method is read-synchronized on the workspace.
  Since it is possible for a thread to block while executing a put(),
  it is important that the thread does not hold read access on
  the workspace when it is blocked. Thus this method releases
  read access on the workspace before calling put().</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>token</code> - The token to send</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - Not thrown in this base class.</dd>
<dd><code><a href="NoRoomException.html" title="class in ptolemy.actor">NoRoomException</a></code> - If a send to one of the channels throws
     it.</dd>
</dl>
</li>
</ul>
<a id="broadcast(ptolemy.data.Token[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>broadcast</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;broadcast&#8203;(<a href="../data/Token.html" title="class in ptolemy.data">Token</a>[]&nbsp;tokenArray,
                      int&nbsp;vectorLength)
               throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a>,
                      <a href="NoRoomException.html" title="class in ptolemy.actor">NoRoomException</a></pre>
<div class="block">Send the specified portion of a token array to all receivers connected
  to this port. The first <i>vectorLength</i> tokens
  of the token array are sent.
  <p>
  Tokens are in general immutable, so each receiver
  is given a reference to the same token and no clones are made.
  If the port is not connected to anything, or receivers have not been
  created in the remote port, or the channel index is out of
  range, or the port is not an output port,
  then just silently return.  This behavior makes it
  easy to leave output ports unconnected when you are not interested
  in the output.  The transfer is accomplished
  by calling the vectorized put() method of the remote receivers.
  If the port is not connected to anything, or receivers have not been
  created in the remote port, then just return.
  <p>
  Some of this method is read-synchronized on the workspace.
  Since it is possible for a thread to block while executing a put,
  it is important that the thread does not hold read access on
  the workspace when it is blocked. Thus this method releases
  read access on the workspace before calling put().</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tokenArray</code> - The token array to send</dd>
<dd><code>vectorLength</code> - The number of elements of the token
   array to send.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="NoRoomException.html" title="class in ptolemy.actor">NoRoomException</a></code> - If there is no room in the receiver.</dd>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - Not thrown in this base class.</dd>
</dl>
</li>
</ul>
<a id="broadcastClear()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>broadcastClear</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;broadcastClear()
                    throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Set all receivers connected on the outside to have no
  tokens. The transfer is accomplished by calling clear() on the
  appropriate receivers.  If there are no destination receivers,
  or if this is not an output port, then do nothing.  Some of
  this method is read-synchronized on the workspace.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If a receiver does not support
   clear().</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#sendClear(int)"><code>sendClear(int )</code></a></dd>
</dl>
</li>
</ul>
<a id="checkWidthConstraints()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkWidthConstraints</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;checkWidthConstraints()
                           throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Check whether the widths constraints are met.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the width constraints or not met.</dd>
</dl>
</li>
</ul>
<a id="clone(ptolemy.kernel.util.Workspace)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clone</h4>
<pre class="methodSignature">public&nbsp;java.lang.Object&nbsp;clone&#8203;(<a href="../kernel/util/Workspace.html" title="class in ptolemy.kernel.util">Workspace</a>&nbsp;workspace)
                       throws java.lang.CloneNotSupportedException</pre>
<div class="block">Clone this port into the specified workspace. The new port is
  <i>not</i> added to the directory of that workspace (you must do this
  yourself if you want it there).
  The result is a new port with no connections and no container.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="../kernel/ComponentPort.html#clone(ptolemy.kernel.util.Workspace)">clone</a></code>&nbsp;in class&nbsp;<code><a href="../kernel/ComponentPort.html" title="class in ptolemy.kernel">ComponentPort</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>workspace</code> - The workspace for the cloned object.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new IOPort.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.CloneNotSupportedException</code> - If one or more of the attributes
   cannot be cloned.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../kernel/util/NamedObj.html#exportMoML(java.io.Writer,int,java.lang.String)"><code>NamedObj.exportMoML(Writer, int, String)</code></a>, 
<a href="../kernel/util/NamedObj.html#setDeferringChangeRequests(boolean)"><code>NamedObj.setDeferringChangeRequests(boolean)</code></a></dd>
</dl>
</li>
</ul>
<a id="convert(ptolemy.data.Token)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convert</h4>
<pre class="methodSignature">public&nbsp;<a href="../data/Token.html" title="class in ptolemy.data">Token</a>&nbsp;convert&#8203;(<a href="../data/Token.html" title="class in ptolemy.data">Token</a>&nbsp;token)
              throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Convert the specified token into a token acceptable to
  this port. In this base class, this method simply returns
  the same token passed to it, performing no conversion.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>token</code> - The token to convert.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The converted token.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the conversion is
   invalid (not thrown in this base class).</dd>
</dl>
</li>
</ul>
<a id="createReceivers()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createReceivers</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;createReceivers()
                     throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Create new receivers for this port, replacing any that may
  previously exist, and validate any instances of Settable that
  this port may contain. This method should only be called on
  opaque ports.
  <p>
  If the port is an input port, receivers are created as necessary
  for each relation connecting to the port from the outside.
  If the port is an output port, receivers are created as necessary
  for each relation connected to the port from the inside. Note that
  only composite entities will have relations connecting to ports
  from the inside.
  <p>
  Note that it is perfectly allowable for a zero width output port to
  have insideReceivers.  This can be used to allow a model to be
  embedded in a container that does not connect the port to anything.
  <p>
  This method is <i>not</i> write-synchronized on the workspace, so the
  caller should be.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If this port is not
   an opaque input port or if there is no director.</dd>
</dl>
</li>
</ul>
<a id="deepConnectedInPortList()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deepConnectedInPortList</h4>
<pre class="methodSignature">public&nbsp;java.util.List&lt;<a href="IOPort.html" title="class in ptolemy.actor">IOPort</a>&gt;&nbsp;deepConnectedInPortList()</pre>
<div class="block">Return a list of input ports connected to this port on the
  outside. NOTE: This method is not as useful as it might seem.
  In particular, it includes in the returned list input ports that
  are higher in the hierarchy to which this port is connected
  on the <i>inside</i>.  This can be confusing because such ports
  cannot receive data produced by this port.  To get a list of
  the ports that can receive data from this port, use the
  sinkPortList() method.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A list of IOPort objects.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../kernel/ComponentPort.html#deepConnectedPortList()"><code>ComponentPort.deepConnectedPortList()</code></a></dd>
</dl>
</li>
</ul>
<a id="deepConnectedInPorts()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deepConnectedInPorts</h4>
<pre class="methodSignature">@Deprecated
public&nbsp;java.util.Enumeration&nbsp;deepConnectedInPorts()</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use deepConnectedInPortList() instead.</div>
</div>
<div class="block">Deeply enumerate the ports connected to this port on the
  outside that are input ports.  This method is deprecated and calls
  deepConnectedInPortList(). It is read-synchronized on the
  workspace.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An enumeration of input IOPort objects.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../kernel/ComponentPort.html#deepConnectedPorts()"><code>ComponentPort.deepConnectedPorts()</code></a></dd>
</dl>
</li>
</ul>
<a id="deepConnectedOutPortList()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deepConnectedOutPortList</h4>
<pre class="methodSignature">public&nbsp;java.util.List&lt;<a href="IOPort.html" title="class in ptolemy.actor">IOPort</a>&gt;&nbsp;deepConnectedOutPortList()</pre>
<div class="block">Return a list of output ports connected to this port on the
  outside. NOTE: This method is not as useful as it might seem.
  In particular, it includes in the returned list output ports that
  are higher in the hierarchy to which this port is connected
  on the <i>inside</i>.  This can be confusing because such ports
  cannot send data to this port.  To get a list of
  the ports that can send data to this port, use the
  sourcePortList() method.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An enumeration of IOPort objects.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../kernel/ComponentPort.html#deepConnectedPorts()"><code>ComponentPort.deepConnectedPorts()</code></a></dd>
</dl>
</li>
</ul>
<a id="deepConnectedOutPorts()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deepConnectedOutPorts</h4>
<pre class="methodSignature">@Deprecated
public&nbsp;java.util.Enumeration&nbsp;deepConnectedOutPorts()</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use deepConnectedInPortList() instead.</div>
</div>
<div class="block">Deeply enumerate the ports connected to this port on the
  outside that are output ports. This method is deprecated and calls
  deepConnectedInPortList(). It is read-synchronized on the
  workspace.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An enumeration of output IOPort objects.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../kernel/ComponentPort.html#deepConnectedPorts()"><code>ComponentPort.deepConnectedPorts()</code></a></dd>
</dl>
</li>
</ul>
<a id="deepGetReceivers()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deepGetReceivers</h4>
<pre class="methodSignature">public&nbsp;<a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>[][]&nbsp;deepGetReceivers()
                              throws <a href="../kernel/util/InvalidStateException.html" title="class in ptolemy.kernel.util">InvalidStateException</a>,
                                     <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">If the port is an input, return the receivers deeply linked on
  the inside.  This method is used to obtain the receivers that
  are to receive data at this input port.  The returned value is
  an array of arrays in the same format as that returned by
  getReceivers(). The difference between this method and
  getReceivers() is that this method treats the port as a
  transparent port regardless of whether it is one.  That is,
  the returned receivers are contained by ports connected on the
  inside to this port.  The number of channels is the inside
  width of this port.  If there are no relations linked on the
  inside, it returns an empty array.  This method is used for opaque,
  non-atomic entities.  It "sees through" the boundary of opaque
  ports and actors.  This method is <i>not</i> read-synchronized
  on the workspace, so the caller should be.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The inside receivers, or an empty receiver array if there
   are none.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If thrown while getting the
 deep receivers of the relation or while getting the inside
 width.</dd>
<dd><code><a href="../kernel/util/InvalidStateException.html" title="class in ptolemy.kernel.util">InvalidStateException</a></code> - Not thrown in this base class</dd>
</dl>
</li>
</ul>
<a id="get(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get</h4>
<pre class="methodSignature">public&nbsp;<a href="../data/Token.html" title="class in ptolemy.data">Token</a>&nbsp;get&#8203;(int&nbsp;channelIndex)
          throws <a href="NoTokenException.html" title="class in ptolemy.actor">NoTokenException</a>,
                 <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Get a token from the specified channel.
  If the channel has a group with more than one receiver (something
  that is possible if this is a transparent port), then this method
  calls get() on all receivers, but returns only the first non-null
  token returned by these calls.
  Normally this method is not used on transparent ports.
  If there is no token to return, then throw an exception.
  <p>
  Some of this method is read-synchronized on the workspace.
  Since it is possible for a thread to block while executing a get,
  it is important that the thread does not hold read access on
  the workspace when it is blocked. Thus this method releases
  read access on the workspace before calling get().</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The channel index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A token from the specified channel.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="NoTokenException.html" title="class in ptolemy.actor">NoTokenException</a></code> - If there is no token.</dd>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If there is no director, and hence
   no receivers have been created, if the port is not an input port, or
   if the channel index is out of range.</dd>
</dl>
</li>
</ul>
<a id="get(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get</h4>
<pre class="methodSignature">public&nbsp;<a href="../data/Token.html" title="class in ptolemy.data">Token</a>[]&nbsp;get&#8203;(int&nbsp;channelIndex,
                   int&nbsp;vectorLength)
            throws <a href="NoTokenException.html" title="class in ptolemy.actor">NoTokenException</a>,
                   <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Get an array of tokens from the specified channel. The
  parameter <i>channelIndex</i> specifies the channel and
  the parameter <i>vectorLength</i> specifies the number of
  valid tokens to get in the returned array. The length of
  the returned array will be equal to <i>vectorLength</i>.
  <p>
  If the channel has a group with more than one receiver (something
  that is possible if this is a transparent port), then this method
  calls get() on all receivers, but returns only the result from
  the first in the group.
  Normally this method is not used on transparent ports.
  If there are not enough tokens to fill the array, then throw
  an exception.
  <p>
  Some of this method is read-synchronized on the workspace.
  Since it is possible for a thread to block while executing a get,
  it is important that the thread does not hold read access on
  the workspace when it is blocked. Thus this method releases
  read access on the workspace before calling get.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The channel index.</dd>
<dd><code>vectorLength</code> - The number of valid tokens to get in the
   returned array.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A token array from the specified channel containing
   <i>vectorLength</i> valid tokens.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="NoTokenException.html" title="class in ptolemy.actor">NoTokenException</a></code> - If there is no array of tokens.</dd>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If there is no director, and hence
   no receivers have been created, if the port is not an input port, or
   if the channel index is out of range.</dd>
</dl>
</li>
</ul>
<a id="getChannelForReceiver(ptolemy.actor.Receiver)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getChannelForReceiver</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getChannelForReceiver&#8203;(<a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>&nbsp;receiver)
                          throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Return the corresponding channel in this port for the given receiver.
  The given receiver may be contained by this port or a port that is
  connected to this port.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>receiver</code> - A receiver that is contained in this port or
   connected to another receiver contained in this port.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The corresponding channel for the receiver.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the given receiver does not
   take part in any connections pertaining to this port.</dd>
</dl>
</li>
</ul>
<a id="getCurrentTime(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCurrentTime</h4>
<pre class="methodSignature">@Deprecated
public&nbsp;double&nbsp;getCurrentTime&#8203;(int&nbsp;channelIndex)
                      throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">As Ptolemy II 4.1,
  replaced by <a href="#getModelTime(int)"><code>getModelTime(int)</code></a>.</div>
</div>
<div class="block">Call the <a href="#getModelTime(int)"><code>getModelTime(int)</code></a> method and return a double
  representation of the model time.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The channel index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The current time associated with a certain channel.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the channel index
  is out of range or if the port is not an input port.</dd>
</dl>
</li>
</ul>
<a id="getDefaultWidth()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDefaultWidth</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getDefaultWidth()</pre>
<div class="block">Get the default width. In case there is no unique solution for a relation
  connected to this port the default width will be used.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The default width.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#setDefaultWidth(int)"><code>setDefaultWidth(int)</code></a></dd>
</dl>
</li>
</ul>
<a id="getInside(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInside</h4>
<pre class="methodSignature">public&nbsp;<a href="../data/Token.html" title="class in ptolemy.data">Token</a>&nbsp;getInside&#8203;(int&nbsp;channelIndex)
                throws <a href="NoTokenException.html" title="class in ptolemy.actor">NoTokenException</a>,
                       <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Get a token from the specified inside channel of this port.
  This method is usually called on the output port of a
  composite actor.

  <p>If the channel has a group with more than one receiver
  (something that is possible if this is a transparent port),
  then this method calls get() on all receivers, but returns
  only the first non-null token returned by these calls.
  Normally this method is not used on transparent ports.  If
  there is no token to return, then throw an exception.  This
  method is usually called only by the director of a composite
  actor during transferOutputs(), as atomic actors do not normally
  have relations connected on the inside of their ports.

  <p> Some of this method is read-synchronized on the workspace.
  Since it is possible for a thread to block while executing a
  get(), it is important that the thread does not hold read access
  on the workspace when it is blocked. Thus this method releases
  read access on the workspace before calling get().</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The channel index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A token from the specified channel.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="NoTokenException.html" title="class in ptolemy.actor">NoTokenException</a></code> - If there is no token.</dd>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If there is no director, and hence
   no receivers have been created, if the port is not an output port, or
   if the channel index is out of range.</dd>
</dl>
</li>
</ul>
<a id="getInsideReceivers()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInsideReceivers</h4>
<pre class="methodSignature">public&nbsp;<a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>[][]&nbsp;getInsideReceivers()</pre>
<div class="block">If the port is an opaque output port, return the receivers that
  receive data from all inside linked relations.
  This method is used for opaque, non-atomic entities, which have
  opaque ports with inside links.  Normally, those inside links
  are not visible.
  This method permits a director to transfer data across an opaque
  boundary by transferring it from the inside receivers to whatever
  receivers this might be connected to on the outside.
  The returned value is an an array of arrays in the same format as
  that returned by getReceivers().
  This method is read-synchronized on the workspace.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The local inside receivers, or an empty array if there are
   none.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#getInside(int)"><code>getInside(int)</code></a></dd>
</dl>
</li>
</ul>
<a id="getIOPortEventListeners()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getIOPortEventListeners</h4>
<pre class="methodSignature">public&nbsp;java.util.List&lt;<a href="IOPortEventListener.html" title="interface in ptolemy.actor">IOPortEventListener</a>&gt;&nbsp;getIOPortEventListeners()</pre>
<div class="block">Get the listeners for IOPortEvents.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The a copy of the list of listeners for IOPortEvents,
 if any. Otherwise an empty list.</dd>
</dl>
</li>
</ul>
<a id="getRelationIndex(ptolemy.actor.IOPort,ptolemy.kernel.Relation,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRelationIndex</h4>
<pre class="methodSignature">public static&nbsp;int&nbsp;getRelationIndex&#8203;(<a href="IOPort.html" title="class in ptolemy.actor">IOPort</a>&nbsp;port,
                                   <a href="../kernel/Relation.html" title="class in ptolemy.kernel">Relation</a>&nbsp;relation,
                                   boolean&nbsp;isOutsideRelation)</pre>
<div class="block">Retrieve the index of the relation at the port.
 In case the relation is not connected with this port -1
 will be returned.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>port</code> - The port.</dd>
<dd><code>relation</code> - The relation.</dd>
<dd><code>isOutsideRelation</code> - A flag that specifies that the
          relation is an outside relation of the port.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The index of the relation at the port.</dd>
</dl>
</li>
</ul>
<a id="getModelTime(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getModelTime</h4>
<pre class="methodSignature">public&nbsp;<a href="util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;getModelTime&#8203;(int&nbsp;channelIndex)
                  throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Return the current time associated with a certain channel.
  In most domains, this is just the current time of the director.
  However, in some domains, the current time is a per-channel
  concept.  If the channel has a token to be read (i.e. hasToken()
  returns true), then the current time is the time associated with
  that token.  If there is no token to be read, then the current
  time is the time of most recently read token. If no token has been
  previously read, then the current time is 0.0.  Notice that this
  means that an actor accessing time should do things in the
  following order:
  <pre>
     if (hasToken(n)) {
        double time = port.getCurrentTime(n);
        Token token = port.get(n);
     }
  </pre>
  I.e., getCurrentTime() is called before get().
  Currently, only the DT domain uses this per-channel time feature.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The channel index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The current time associated with a certain channel.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the channel index
  is out of range or if the port is not an input port.</dd>
</dl>
</li>
</ul>
<a id="getModelTime(int,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getModelTime</h4>
<pre class="methodSignature">public&nbsp;<a href="util/Time.html" title="class in ptolemy.actor.util">Time</a>&nbsp;getModelTime&#8203;(int&nbsp;channelIndex,
                         boolean&nbsp;inside)
                  throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Return the current time associated with a certain channel.
  In most domains, this is just the current time of the director.
  However, in some domains, the current time is a per-channel
  concept.  If the channel has a token to be read (i.e. hasToken()
  returns true), then the current time is the time associated with
  that token.  If there is no token to be read, then the current
  time is the time of most recently read token. If no token has been
  previously read, then the current time is 0.0.  Notice that this
  means that an actor accessing time should do things in the
  following order:
  <pre>
     if (hasToken(n)) {
        double time = port.getCurrentTime(n);
        Token token = port.get(n);
     }
  </pre>
  I.e., getCurrentTime() is called before get().
  Currently, only the DT domain uses this per-channel time feature.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The channel index.</dd>
<dd><code>inside</code> - True for an inside channel.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The current time associated with a certain channel.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the channel index
  is out of range or if the port is not an input port.</dd>
</dl>
</li>
</ul>
<a id="getCommunicationAspects()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCommunicationAspects</h4>
<pre class="methodSignature">public&nbsp;java.util.List&lt;<a href="CommunicationAspect.html" title="interface in ptolemy.actor">CommunicationAspect</a>&gt;&nbsp;getCommunicationAspects()
                                                            throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Return the list of communication aspects in this port.
  A communication aspect is a <a href="../data/expr/Parameter.html" title="class in ptolemy.data.expr"><code>Parameter</code></a> whose value is an
  <a href="../data/ObjectToken.html" title="class in ptolemy.data"><code>ObjectToken</code></a> that references an object that implements
  the <a href="CommunicationAspect.html" title="interface in ptolemy.actor"><code>CommunicationAspect</code></a> interface.
  Update the sequence number of communication aspects.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The list of communication aspects.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - Thrown if the token of the parameter
      containing the communication aspect object cannot be retrieved.</dd>
</dl>
</li>
</ul>
<a id="getReceivers()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getReceivers</h4>
<pre class="methodSignature">public&nbsp;<a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>[][]&nbsp;getReceivers()</pre>
<div class="block">If the port is an input, return the receivers that receive data
  from all linked relations. For an input
  port, the returned value is an array of arrays.  The first index
  specifies the channel number.  The second index specifies the
  receiver number within the group of receivers that get copies from
  the same channel.
  <p>
  For a transparent port (a port of a non-opaque entity), this method
  returns receivers in ports connected to this port on the inside.
  For an opaque port, the receivers returned are contained directly by
  this port.
  <p>
  The number of channels (number of groups) is the width of the port.
  <p>
  For each channel, there may be any number of receivers in the group.
  The individual receivers are selected using the second index of the
  returned array of arrays.  If there are no receivers in the group,
  then the channel is represented by null.  I.e., if the returned
  array of arrays is <i>x</i> and the channel number is <i>c</i>,
  then <i>x</i>[<i>c</i>] is null.  Otherwise, it is an array, where
  the size of the array is the number of receivers in the group.
  If the port is opaque, then the group size is one, so only
  <i>x</i>[<i>c</i>][0] is defined.  If the port is transparent,
  the group size is arbitrary.
  <p>
  For an opaque port, this method creates receivers by calling
  _newReceiver() if there are no receivers or the number of receivers
  does not match the width of the port.  In the latter case,
  previous receivers are lost, together with any data they may contain.
  <p>
  This method is read-synchronized on the workspace.  If its cached
  list of local receivers is not valid, however, then it acquires
  write synchronization on the workspace to reconstruct it.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The local receivers, or an empty array if there are none.</dd>
</dl>
</li>
</ul>
<a id="getReceivers(ptolemy.actor.IORelation)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getReceivers</h4>
<pre class="methodSignature">public&nbsp;<a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>[][]&nbsp;getReceivers&#8203;(<a href="IORelation.html" title="class in ptolemy.actor">IORelation</a>&nbsp;relation)
                          throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">If the port is an input, return receivers that handle incoming
  channels from the specified relation. If the port is an opaque output
  and the relation is inside linked, return the receivers that handle
  incoming channels from the inside. Since the port may be linked
  multiple times to the specified relation, this method only returns
  the relations correspond to the first occurrence.
  The returned value is an array of arrays of the same form
  as that returned by getReceivers() with no arguments.  Note that a
  single occurrence of a relation may represent multiple channels
  because it may be a bus.  If there are no matching receivers,
  then return an empty array.
  <p>
  This method is read-synchronized on the workspace.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>relation</code> - Relations that are linked on the outside or inside.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The local receivers.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the relation is not linked
   from the outside, or if there is no director.</dd>
</dl>
</li>
</ul>
<a id="getReceivers(ptolemy.actor.IORelation,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getReceivers</h4>
<pre class="methodSignature">public&nbsp;<a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>[][]&nbsp;getReceivers&#8203;(<a href="IORelation.html" title="class in ptolemy.actor">IORelation</a>&nbsp;relation,
                                 int&nbsp;occurrence)
                          throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">If the port is an input, return receivers that handle incoming
  channels from the specified relation. If the port is an opaque output
  and the relation is inside linked, return the receivers that handle
  incoming channels from the inside. Since the port may be linked
  multiple times to the specified relation, the <i>occurrences</i>
  argument specifies which of the links we wish to examine.
  The returned value is an array of arrays of the same form
  as that returned by getReceivers() with no arguments.  Note that a
  single occurrence of a relation may represent multiple channels
  because it may be a bus.  If there are no matching receivers,
  then return an empty array.
  <p>
  This method is read-synchronized on the workspace.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>relation</code> - Relations that are linked on the outside or inside.</dd>
<dd><code>occurrence</code> - The occurrence number that we are interested in,
   starting at 0.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The local receivers, or an empty array if there are none.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the relation is not linked
   from the outside.</dd>
</dl>
</li>
</ul>
<a id="getRemoteReceivers()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRemoteReceivers</h4>
<pre class="methodSignature">public&nbsp;<a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>[][]&nbsp;getRemoteReceivers()
                                throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">If the port is an output, return the remote receivers that can
  receive from the port.  For an output
  port, the returned value is an array of arrays of the same form
  as that returned by getReceivers() with no arguments.  The length
  of the array is the width of the port (the number of channels).
  It is an array of arrays, each of which represents a group of
  receivers that receive data from the same channel.
  <p>
  This method may have the effect of creating new receivers in the
  remote input ports, if they do not already have the right number of
  receivers.  In this case, previous receivers are lost, together
  with any data they may contain.
  <p>
  This method is read-synchronized on the workspace.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The receivers for output data, or an empty array if there
   are none.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If thrown while getting the
  width of this port, getting the deep receives of a relation or getting the
  width of a relation.</dd>
</dl>
</li>
</ul>
<a id="getRemoteReceivers(ptolemy.actor.IORelation)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRemoteReceivers</h4>
<pre class="methodSignature">public&nbsp;<a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>[][]&nbsp;getRemoteReceivers&#8203;(<a href="IORelation.html" title="class in ptolemy.actor">IORelation</a>&nbsp;relation)
                                throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">If this port is an output, return the remote receivers that can
  receive data from this port through the specified relation or
  any relation in its relation group.
  The relation or one in its relation group should be linked to the port
  from the inside, otherwise an exception is thrown. For an output
  port, the returned value is an array of arrays of the same form
  as that returned by getReceivers() with no arguments.
  <p>
  This method may have the effect of creating new receivers in the
  remote input ports, if they do not already have the right number of
  receivers.  In this case, previous receivers are lost, together
  with any data they may contain.
  <p>
  This method is read-synchronized on the workspace.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>relation</code> - The specified relation from which the remote
  receivers can receive data.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The receivers for output data, or an empty array if there
   are none.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the IORelation is not linked
   to the port from the inside.</dd>
</dl>
</li>
</ul>
<a id="getWidth()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getWidth</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getWidth()
             throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Return the width of the port.  The width is the sum of the
  widths of the relations that the port is linked to (on the outside).
  Note that this method cannot be used to determine whether a port
  is connected (deeply) to another port that can either supply it with
  data or consume data it produces.  The correct methods to use to
  determine that are numberOfSinks() and numberOfSources().
  This method is read-synchronized on the workspace.
  This method will trigger the width inference algorithm if necessary.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The width of the port.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If thrown while calling _getWidth()</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#numberOfSinks()"><code>numberOfSinks()</code></a>, 
<a href="#numberOfSources()"><code>numberOfSources()</code></a></dd>
</dl>
</li>
</ul>
<a id="getWidthFromConstraints()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getWidthFromConstraints</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getWidthFromConstraints()</pre>
<div class="block">Get the width from the constraints put on the width
  of this port if the width is fully determined.
  If it is not possible to determine the width yet
  (for example because dependent relations also don't have
  their width inferred), -1 is returned</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The width.</dd>
</dl>
</li>
</ul>
<a id="getWidthInside()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getWidthInside</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getWidthInside()
                   throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Return the inside width of this port.  The inside width is the
  sum of the widths of the relations that the port is linked to
  on the inside.  This method is read-synchronized on the
  workspace.
  This method will trigger the width inference algorithm if necessary.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The width of the inside of the port.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If thrown while getting the
  width of the relations or while creating receivers.</dd>
</dl>
</li>
</ul>
<a id="hasNewToken(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasNewToken</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasNewToken&#8203;(int&nbsp;channelIndex)
                    throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Return true if the specified channel has a new token to deliver
  via the get() method.  This differs from <a href="#hasToken(int)"><code>hasToken(int)</code></a>
  in that it does not return true just because the port is persistent
  or the most recently received input was a <a href="../data/SmoothToken.html" title="class in ptolemy.data"><code>SmoothToken</code></a>.
  If this port is not an input, or if the
  channel index is out of range, then throw an exception.
  Note that this does not report any tokens in inside receivers
  of an output port. Those are accessible only through
  getInsideReceivers().</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The channel index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if there is a token in the channel.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the receivers do not support
   this query, if there is no director, and hence no receivers,
   if the port is not an input port, or if the channel index is out
   of range.</dd>
</dl>
</li>
</ul>
<a id="hasNewTokenInside(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasNewTokenInside</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasNewTokenInside&#8203;(int&nbsp;channelIndex)
                          throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Return true if the specified channel has a token to deliver
  via the getInside() method.  This differs from <a href="#hasTokenInside(int)"><code>hasTokenInside(int)</code></a>
  in that it does not return true just because the port is persistent
  or the most recently received input was a <a href="../data/SmoothToken.html" title="class in ptolemy.data"><code>SmoothToken</code></a>.
  If this port is not an output, or
  if the channel index is out of range, then throw an exception.
  Note that this does not report any tokens in receivers of an
  input port.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The channel index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if there is a token in the channel.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the receivers do not support
   this query, if there is no director, and hence no receivers,
   if the port is not an output port, or if the channel index is out
   of range.</dd>
</dl>
</li>
</ul>
<a id="hasRoom(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRoom</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasRoom&#8203;(int&nbsp;channelIndex)
                throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Return true if the specified channel can accept a token via the
  put() method.  If this port is not an output, or the channel index
  is out of range, then throw IllegalActionException.  If there
  are multiple receivers in the group associated with the channel,
  then return true only if all the receivers can accept a token.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The channel index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if there is room for a token in the channel.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the receivers do not support
   this query, if this is not an output port, or if the channel index
   is out of range.</dd>
</dl>
</li>
</ul>
<a id="hasRoomInside(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasRoomInside</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasRoomInside&#8203;(int&nbsp;channelIndex)
                      throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Return true if the specified channel can accept a token via
  the putInside() method.  If this port is not an input, or the
  channel index is out of range, then throw
  IllegalActionException.  If there are multiple receivers in
  the group associated with the channel, then return true only
  if all the receivers can accept a token.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The channel index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if there is room for a token in the channel.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the receivers do not
  support this query, if this is not an input port, or if the
  channel index is out of range.</dd>
</dl>
</li>
</ul>
<a id="hasToken(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasToken</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasToken&#8203;(int&nbsp;channelIndex)
                 throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Return true if the port is persistent (see <a href="#defaultValue"><code>defaultValue</code></a>),
  or if the most recent input was an <a href="../data/SmoothToken.html" title="class in ptolemy.data"><code>SmoothToken</code></a>, or
  if the specified channel has a token to deliver
  via the get() method.  If this port is not an input, or if the
  channel index is out of range, then throw an exception.
  Note that this does not report any tokens in inside receivers
  of an output port. Those are accessible only through
  getInsideReceivers().</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The channel index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if there is a token in the channel.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the receivers do not support
   this query, if there is no director, and hence no receivers,
   if the port is not an input port, or if the channel index is out
   of range.</dd>
</dl>
</li>
</ul>
<a id="hasToken(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasToken</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasToken&#8203;(int&nbsp;channelIndex,
                        int&nbsp;tokens)
                 throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Return true if the specified channel has the specified number
  of tokens to deliver via the get() method.
  If this port is not an input, or if the
  channel index is out of range, then throw an exception.
  Note that this does not report any tokens in inside receivers
  of an output port. Those are accessible only through
  getInsideReceivers().</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The channel index.</dd>
<dd><code>tokens</code> - The number of tokens to query the channel for.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if there is a token in the channel.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the receivers do not support
   this query, if there is no director, and hence no receivers,
   if the port is not an input port, or if the channel index is out
   of range.</dd>
</dl>
</li>
</ul>
<a id="hasTokenInside(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasTokenInside</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasTokenInside&#8203;(int&nbsp;channelIndex)
                       throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Return true if the port is persisent or the specified channel
  has a token to deliver
  via the getInside() method.  If this port is not an output, or
  if the channel index is out of range, then throw an exception.
  Note that this does not report any tokens in receivers of an
  input port.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The channel index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if there is a token in the channel.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the receivers do not support
   this query, if there is no director, and hence no receivers,
   if the port is not an output port, or if the channel index is out
   of range.</dd>
</dl>
</li>
</ul>
<a id="hasWidthConstraints()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasWidthConstraints</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;hasWidthConstraints()</pre>
<div class="block">Return whether there are constraints on the width of
  this port. There are constraints in case the method
  setWidthEquals has been called.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True when there are constraints on the width.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#setWidthEquals(ptolemy.data.expr.Parameter)"><code>setWidthEquals(Parameter)</code></a>, 
<a href="#setWidthEquals(ptolemy.actor.IOPort,boolean)"><code>setWidthEquals(IOPort, boolean)</code></a></dd>
</dl>
</li>
</ul>
<a id="insertLink(int,ptolemy.kernel.Relation)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>insertLink</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;insertLink&#8203;(int&nbsp;index,
                       <a href="../kernel/Relation.html" title="class in ptolemy.kernel">Relation</a>&nbsp;relation)
                throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Override the base class to invalidate the schedule and resolved
  types of the director of the container, if there is one, in addition
  to what the base class does.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="../kernel/ComponentPort.html#insertLink(int,ptolemy.kernel.Relation)">insertLink</a></code>&nbsp;in class&nbsp;<code><a href="../kernel/ComponentPort.html" title="class in ptolemy.kernel">ComponentPort</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - The index at which to insert the link.</dd>
<dd><code>relation</code> - The relation to link to this port.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the link would cross levels of
   the hierarchy, or the relation is incompatible,
   or the port has no container, or the port is not in the
   same workspace as the relation, or if this port is not a multiport
   and the index is greater than zero or if another link already exists.</dd>
</dl>
</li>
</ul>
<a id="insideSinkPortList()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>insideSinkPortList</h4>
<pre class="methodSignature">public&nbsp;java.util.List&lt;<a href="IOPort.html" title="class in ptolemy.actor">IOPort</a>&gt;&nbsp;insideSinkPortList()</pre>
<div class="block">Return a list of the ports that may accept data from this port
  when it sends on the inside.  In this base class, this includes
  both input ports and opaque output ports that are
  connected on the inside to this port, which are the ports that
  will receive data from this one if data is sent on the inside.
  However, derived classes are free to return ports on this list
  that <i>may</i> receive data from this port, even if they are
  not actually currently connected.  The wireless domain, for
  example, takes advantage of this and includes ports on the
  inside that share the same channel. This port must
  be an opaque input port, otherwise return an empty list.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A list of IOPort objects.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#deepGetReceivers()"><code>deepGetReceivers()</code></a></dd>
</dl>
</li>
</ul>
<a id="insideSourcePortList()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>insideSourcePortList</h4>
<pre class="methodSignature">public&nbsp;java.util.List&lt;<a href="IOPort.html" title="class in ptolemy.actor">IOPort</a>&gt;&nbsp;insideSourcePortList()</pre>
<div class="block">Return a list of the ports that can send data to this port
  from the inside.  This includes both output ports and opaque
  input ports that are connected on the inside to this port.
  These are the ports that will send data from this one from the inside.
  However, derived classes are free to return ports on this list
  that <i>may</i> send data to this port, even if they are
  not actually currently connected.  The wireless domain, for
  example, takes advantage of this and includes ports on the
  inside that share the same channel. This port must
  be an opaque output port, otherwise return an empty list.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A list of IOPort objects.</dd>
</dl>
</li>
</ul>
<a id="invalidateCommunicationAspects()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>invalidateCommunicationAspects</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;invalidateCommunicationAspects()</pre>
<div class="block">Invalidate the communication aspect list.</div>
</li>
</ul>
<a id="isInput()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isInput</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isInput()</pre>
<div class="block">Return true if the port is an input.  The port is an input
  if either setInput() has been called with a <i>true</i> argument, or
  it is connected on the inside to an input port, or if it is
  connected on the inside to the inside of an output port.
  In other words, it is an input if data can be put directly into
  it or sent through it to an input.
  This method is read-synchronized on the workspace.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if the port is an input.</dd>
</dl>
</li>
</ul>
<a id="isInsideConnected()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isInsideConnected</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isInsideConnected()</pre>
<div class="block">Return whether the port has relations connected on the inside.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True when a relation != null is connected on the inside.</dd>
</dl>
</li>
</ul>
<a id="isKnown()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isKnown</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isKnown()
                throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Return true if all channels of this port have known state; that is,
  the tokens on each channel are known, or each channel is known not to
  have any tokens.
  <p>
  This method supports domains, such as SR, which have fixed-point
  semantics.  In such domains, an iteration of a model starts with
  the state of all channels unknown, and the iteration concludes when
  the state of all channels is known.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if it is known whether there is a token in each channel.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the receivers do not support
   this query, or if there is no director, and hence no receivers.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#isKnown(int)"><code>isKnown(int)</code></a>, 
<a href="#isKnownInside(int)"><code>isKnownInside(int)</code></a></dd>
</dl>
</li>
</ul>
<a id="isKnown(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isKnown</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isKnown&#8203;(int&nbsp;channelIndex)
                throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Return <i>true</i> if the specified channel has known state;
  that is, the tokens on this channel are known, or this channel
  is known not to have any tokens.
  If the channel index is out of range, then throw
  an exception. If the port is an input and an output, then both
  the receivers in this port (for the input) and the remote
  receivers (for the output) must be known to return true.
  If the port is neither an input nor an output, then return true.
  <p>
  This method supports domains, such as SR, which have fixed-point
  semantics.  In such domains, an iteration of a model starts with
  the state of all channels unknown, and the iteration concludes when
  the state of all channels is known.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The channel index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if it is known whether there is a token in the channel.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the receivers do not support
   this query, if there is no director, and hence no receivers,
   if the port is not an input port, or if the channel index is out
   of range.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#isKnown()"><code>isKnown()</code></a>, 
<a href="#isKnownInside(int)"><code>*</code></a></dd>
</dl>
</li>
</ul>
<a id="isKnownInside(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isKnownInside</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isKnownInside&#8203;(int&nbsp;channelIndex)
                      throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Return <i>true</i> if the specified inside channel has known state;
  that is, the tokens on this channel are known, or this channel
  is known not to have any tokens.  If the channel index is out
  of range, then throw an exception.
  If the port is an input and an output, then both
  the receivers in this port (for the input) and the remote
  receivers (for the output) must be known to return true.
  If the port is neither an input nor an output, then return true.
  <p>
  This method supports domains, such as SR, which have fixed-point
  semantics.  In such domains, an iteration of a model starts with
  the state of all channels unknown, and the iteration concludes when
  the state of all channels is known.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The channel index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if it is known whether there is a token in the channel.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the receivers do not
   support this query, if there is no director, and hence no
   receivers, or if the inside channel index is out of range.</dd>
</dl>
</li>
</ul>
<a id="isMultiport()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isMultiport</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isMultiport()</pre>
<div class="block">Return true if the port is a multiport.  The port is a multiport
  if setMultiport() has been called with a true argument.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if the port is a multiport.</dd>
</dl>
</li>
</ul>
<a id="isOutput()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isOutput</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isOutput()</pre>
<div class="block">Return true if the port is an output. The port is an output
  if either setOutput() has been called with a true argument, or
  it is connected on the inside to an output port, or it is
  connected on the inside to the inside of an input port.
  This method is read-synchronized on the workspace.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if the port is an output.</dd>
</dl>
</li>
</ul>
<a id="isOutsideConnected()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isOutsideConnected</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isOutsideConnected()</pre>
<div class="block">Return whether the port has relations connected on the outside.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True when a relation != null is connected on the outside.</dd>
</dl>
</li>
</ul>
<a id="liberalLink(ptolemy.kernel.ComponentRelation)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>liberalLink</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;liberalLink&#8203;(<a href="../kernel/ComponentRelation.html" title="class in ptolemy.kernel">ComponentRelation</a>&nbsp;relation)
                 throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Override the base class to invalidate the schedule and resolved
  types of the director of the container, if there is one, in addition
  to what the base class does.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="../kernel/ComponentPort.html#liberalLink(ptolemy.kernel.ComponentRelation)">liberalLink</a></code>&nbsp;in class&nbsp;<code><a href="../kernel/ComponentPort.html" title="class in ptolemy.kernel">ComponentPort</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>relation</code> - The relation to link to.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the relation does not share
   the same workspace, or the port has no container.</dd>
</dl>
</li>
</ul>
<a id="link(ptolemy.kernel.Relation)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>link</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;link&#8203;(<a href="../kernel/Relation.html" title="class in ptolemy.kernel">Relation</a>&nbsp;relation)
          throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Override the base class to invalidate the schedule and resolved
  types of the director of the container, if there is one, in addition
  to what the base class does.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="../kernel/ComponentPort.html#link(ptolemy.kernel.Relation)">link</a></code>&nbsp;in class&nbsp;<code><a href="../kernel/ComponentPort.html" title="class in ptolemy.kernel">ComponentPort</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>relation</code> - The relation to link to.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the link crosses levels of
   the hierarchy, or the port has no container, or the relation
   is not an instance of IORelation.</dd>
</dl>
</li>
</ul>
<a id="numberOfSinks()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>numberOfSinks</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;numberOfSinks()</pre>
<div class="block">Return the number of sink ports that may receive data from this one.
  This is the number of ports returned by sinkPortList(), but
  this method is more efficient to call than that one if you only
  need to know how many ports there are (because the result is cached).
  This method is typically used to determine whether an output port
  is connected (deeply) to any input port that can consume its
  data.  Note that it is not sufficient to call getWidth() to determine
  this; it is possible for getWidth() to return a number greater than
  zero when this method returns zero. In particular, if this port
  is connected to the inside of an opaque output port, but that opaque
  output port is not connected on the outside, then this method will
  return zero, but getWidth() will return the width of the relation
  mediating the connection.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The number of ports that can receive data from this one.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#sinkPortList()"><code>sinkPortList()</code></a>, 
<a href="#numberOfSources()"><code>numberOfSources()</code></a>, 
<a href="#getWidth()"><code>getWidth()</code></a></dd>
</dl>
</li>
</ul>
<a id="numberOfSources()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>numberOfSources</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;numberOfSources()</pre>
<div class="block">Return the number of source ports that may send data to this one.
  This is no greater than number of ports returned by sourcePortList().
  This method is typically used to determine whether an input port
  is connected (deeply) to any output port that can supply it with
  data.  Note that it is not sufficient to call getWidth() to determine
  this; it is possible for getWidth() to return a number greater than
  zero when this method returns zero. In particular, if this port
  is connected to the inside of an opaque input port, but that opaque
  input port is not connected on the outside, then this method will
  return zero, but getWidth() will return the width of the relation
  mediating the connection.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The number of ports that can send data to this one.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#sourcePortList()"><code>sourcePortList()</code></a>, 
<a href="#numberOfSinks()"><code>numberOfSinks()</code></a>, 
<a href="#getWidth()"><code>getWidth()</code></a></dd>
</dl>
</li>
</ul>
<a id="removeIOPortEventListener(ptolemy.actor.IOPortEventListener)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeIOPortEventListener</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;removeIOPortEventListener&#8203;(<a href="IOPortEventListener.html" title="interface in ptolemy.actor">IOPortEventListener</a>&nbsp;listener)</pre>
<div class="block">Unregister a token sent listener.  If the specified listener has not
  been previously registered, then do nothing.  Note that this method
  is basically the same as removeDebugListener in the class NamedObj.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>listener</code> - The listener to remove from the list of listeners
   to which token sent messages are sent.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#addIOPortEventListener(ptolemy.actor.IOPortEventListener)"><code>addIOPortEventListener(IOPortEventListener)</code></a></dd>
</dl>
</li>
</ul>
<a id="reset()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reset</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;reset()
           throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">If port has default value reset the saved persistent value.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If defaultValue cannot be retrieved.</dd>
</dl>
</li>
</ul>
<a id="send(int,ptolemy.data.Token)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>send</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;send&#8203;(int&nbsp;channelIndex,
                 <a href="../data/Token.html" title="class in ptolemy.data">Token</a>&nbsp;token)
          throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a>,
                 <a href="NoRoomException.html" title="class in ptolemy.actor">NoRoomException</a></pre>
<div class="block">Send the specified token to all receivers connected to the
  specified channel.  Tokens are in general immutable, so each receiver
  is given a reference to the same token and no clones are made.
  If the port is not connected to anything, or receivers have not been
  created in the remote port, or the channel index is out of
  range, or the port is not an output port,
  then just silently return.  This behavior makes it
  easy to leave output ports unconnected when you are not interested
  in the output.  The transfer is
  accomplished by calling the put() method of the remote receivers.
  If the port is not connected to anything, or receivers have not been
  created in the remote port, then just return.
  <p>
  If a null token is specified, this is interpreted as an assertion
  that no token is being sent. For some domains, specifically those
  that queue tokens such as PN and SDF, this has no effect. For
  others, specifically those that have a well-defined notion of
  "absent" inputs such as SR, modal, and Continuous, sending a null
  token corresponds to asserting that the inputs of destination
  actors will be absent in this round.
  <p>
  Some of this method is read-synchronized on the workspace.
  Since it is possible for a thread to block while executing a put,
  it is important that the thread does not hold read access on
  the workspace when it is blocked. Thus this method releases
  read access on the workspace before calling put.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The index of the channel, from 0 to width-1</dd>
<dd><code>token</code> - The token to send, or null to send no token.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="NoRoomException.html" title="class in ptolemy.actor">NoRoomException</a></code> - If there is no room in the receiver.</dd>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - Not thrown in this base class.</dd>
</dl>
</li>
</ul>
<a id="send(int,ptolemy.data.Token[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>send</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;send&#8203;(int&nbsp;channelIndex,
                 <a href="../data/Token.html" title="class in ptolemy.data">Token</a>[]&nbsp;tokenArray,
                 int&nbsp;vectorLength)
          throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a>,
                 <a href="NoRoomException.html" title="class in ptolemy.actor">NoRoomException</a></pre>
<div class="block">Send the specified portion of a token array to all receivers connected
  to the specified channel. The first <i>vectorLength</i> tokens
  of the token array are sent.
  <p>
  Tokens are in general immutable, so each receiver
  is given a reference to the same token and no clones are made.
  If the port is not connected to anything, or receivers have not been
  created in the remote port, or the channel index is out of
  range, or the port is not an output port,
  then just silently return.  This behavior makes it
  easy to leave output ports unconnected when you are not interested
  in the output.  The transfer is accomplished
  by calling the vectorized put() method of the remote receivers.
  If the port is not connected to anything, or receivers have not been
  created in the remote port, then just return.
  <p>
  Some of this method is read-synchronized on the workspace.
  Since it is possible for a thread to block while executing a put,
  it is important that the thread does not hold read access on
  the workspace when it is blocked. Thus this method releases
  read access on the workspace before calling put.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The index of the channel, from 0 to width-1</dd>
<dd><code>tokenArray</code> - The token array to send</dd>
<dd><code>vectorLength</code> - The number of elements of of the token
   array to send.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="NoRoomException.html" title="class in ptolemy.actor">NoRoomException</a></code> - If there is no room in the receiver.</dd>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - Not thrown in this base class.</dd>
</dl>
</li>
</ul>
<a id="sendClear(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sendClear</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;sendClear&#8203;(int&nbsp;channelIndex)
               throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Set all destination receivers connected via the specified to channel
  to have no token. The transfer is accomplished by calling
  clear() on the appropriate receivers. If there are no
  destination receivers on the specified channel, or if this is not
  an output port, or if the array index is out of bounds,
  then do nothing.
  Some of this method is read-synchronized on the workspace.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The index of the channel, from 0 to width-1</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If a receiver does not support
   clear().</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#broadcastClear()"><code>broadcastClear()</code></a>, 
<a href="#sendClearInside(int)"><code>sendClearInside(int)</code></a></dd>
</dl>
</li>
</ul>
<a id="sendClearInside(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sendClearInside</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;sendClearInside&#8203;(int&nbsp;channelIndex)
                     throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Set all destination receivers connected on the inside via the specified
  to channel to have no token. This is accomplished by calling
  clear() on the appropriate receivers. If there are no
  destination inside receivers on the specified channel,
  or if the channel index is out of bounds, then do nothing.
  Some of this method is read-synchronized on the workspace.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The index of the channel, from 0 to insideWidth-1.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If a receiver does not support
   clear().</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#sendClear(int)"><code>sendClear(int)</code></a></dd>
</dl>
</li>
</ul>
<a id="sendInside(int,ptolemy.data.Token)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sendInside</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;sendInside&#8203;(int&nbsp;channelIndex,
                       <a href="../data/Token.html" title="class in ptolemy.data">Token</a>&nbsp;token)
                throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a>,
                       <a href="NoRoomException.html" title="class in ptolemy.actor">NoRoomException</a></pre>
<div class="block">Send the specified token to all receivers connected to the
  specified inside channel of this port.  Tokens are in general
  immutable, so each receiver is given a reference to the same
  token and no clones are made.  If the port is not connected to
  anything on the inside, or receivers have not been created in
  the remote port, or the channel index is out of range, or the
  port is not an input port, then just silently return.  This
  behavior makes it easy to leave external input ports of a
  composite unconnected when you are not interested in the
  received values.  The transfer is accomplished by calling the
  put() method of the inside remote receivers.  If the port is
  not connected to anything, or receivers have not been created
  in the remote port, then just return.  This method is normally
  called only by the transferInputs method of directors of
  composite actors, as AtomicActors do not usually have any
  relations on the inside of their ports.
  <p>
  If a null token is specified, this is interpreted as an assertion
  that no token is being sent. For some domains, specifically those
  that queue tokens such as PN and SDF, this has no effect. For
  others, specifically those that have a well-defined notion of
  "absent" inputs such as SR, modal, and Continuous, sending a null
  token corresponds to asserting that the inputs of destination
  actors will be absent in this round.

  <p> Some of this method is read-synchronized on the workspace.
  Since it is possible for a thread to block while executing a
  put, it is important that the thread does not hold read access
  on the workspace when it is blocked. Thus this method releases
  read access on the workspace before calling put.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channelIndex</code> - The index of the channel, from 0 to width-1</dd>
<dd><code>token</code> - The token to send, or null to send no token.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="NoRoomException.html" title="class in ptolemy.actor">NoRoomException</a></code> - If there is no room in the receiver.</dd>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - Not thrown in this base class.</dd>
</dl>
</li>
</ul>
<a id="setContainer(ptolemy.kernel.Entity)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setContainer</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setContainer&#8203;(<a href="../kernel/Entity.html" title="class in ptolemy.kernel">Entity</a>&nbsp;container)
                  throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a>,
                         <a href="../kernel/util/NameDuplicationException.html" title="class in ptolemy.kernel.util">NameDuplicationException</a></pre>
<div class="block">Override the base class to ensure that the proposed container
  implements the Actor interface (the base class ensures that the
  container is an instance of ComponentEntity) or null. A null
  argument will remove the port from the container.  This method
  invalidates the schedule and type resolution of the director
  of the container, if there is one.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="../kernel/ComponentPort.html#setContainer(ptolemy.kernel.Entity)">setContainer</a></code>&nbsp;in class&nbsp;<code><a href="../kernel/ComponentPort.html" title="class in ptolemy.kernel">ComponentPort</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>container</code> - The proposed container.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the proposed container is not a
   ComponentEntity, doesn't implement Actor, or has no name,
   or the port and container are not in the same workspace. Or
   it's not null</dd>
<dd><code><a href="../kernel/util/NameDuplicationException.html" title="class in ptolemy.kernel.util">NameDuplicationException</a></code> - If the container already has
   a port with the name of this port.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../kernel/Port.html#getContainer()"><code>Port.getContainer()</code></a>, 
<a href="../kernel/Port.html#_checkContainer(ptolemy.kernel.Entity)"><code>Port._checkContainer(Entity)</code></a></dd>
</dl>
</li>
</ul>
<a id="setDefaultWidth(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDefaultWidth</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setDefaultWidth&#8203;(int&nbsp;defaultWidth)</pre>
<div class="block">Set the default width. In case there is no unique solution for a relation
  connected to this port the default width will be used.
  If the default width is not set, the value will be -1
  which corresponds to no default width.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>defaultWidth</code> - The default width.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#getDefaultWidth()"><code>getDefaultWidth()</code></a></dd>
</dl>
</li>
</ul>
<a id="setInput(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setInput</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setInput&#8203;(boolean&nbsp;isInput)
              throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">If the argument is true, make the port an input port.
  If the argument is false, make the port not an input port.
  If this is never called, and setOutput() is never called,
  and the port is a transparent port of a composite actor,
  then the input/output status will be inferred from the connection.
  This method invalidates the schedule and resolved types of the
  director of the container, if there is one.
  It is write-synchronized on the workspace, and increments
  the version of the workspace.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>isInput</code> - True to make the port an input.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If changing the port status is
   not permitted (not thrown in this base class).</dd>
</dl>
</li>
</ul>
<a id="setMultiport(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setMultiport</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setMultiport&#8203;(boolean&nbsp;isMultiport)
                  throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">If the argument is true, make the port a multiport.
  That is, make it capable of linking with multiple IORelations,
  or with IORelations that have width greater than one.
  If the argument is false, allow only links with a single
  IORelation of width one.
  This method invalidates the schedule and resolved types of the
  director of the container, if there is one.
  It is write-synchronized on the workspace.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>isMultiport</code> - True to make the port a multiport.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If changing the port status is
   not permitted (not thrown in this base class).</dd>
</dl>
</li>
</ul>
<a id="setOutput(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOutput</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setOutput&#8203;(boolean&nbsp;isOutput)
               throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">If the argument is true, make the port an output port.
  If the argument is false, make the port not an output port.
  If this is never called, and setInput() is never called,
  and the port is a transparent port of a composite actor,
  then the input/output status will be inferred from the connection.
  This method invalidates the schedule and resolved types of the
  director of the container, if there is one.
  It is write-synchronized on the workspace, and increments
  the version of the workspace.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>isOutput</code> - True to make the port an output.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If changing the port status is
   not permitted (not thrown in this base class).</dd>
</dl>
</li>
</ul>
<a id="setWidthEquals(ptolemy.data.expr.Parameter)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setWidthEquals</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setWidthEquals&#8203;(<a href="../data/expr/Parameter.html" title="class in ptolemy.data.expr">Parameter</a>&nbsp;parameter)</pre>
<div class="block">Constrain the width of this port to be equal to the parameter.
  <p>Actors that call this method should have a clone() method that
  repeats the width constraints that were specified in
  the constructor.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>parameter</code> - A parameter.</dd>
</dl>
</li>
</ul>
<a id="setWidthEquals(ptolemy.actor.IOPort,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setWidthEquals</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setWidthEquals&#8203;(<a href="IOPort.html" title="class in ptolemy.actor">IOPort</a>&nbsp;port,
                           boolean&nbsp;bidirectional)</pre>
<div class="block">Constrain the width of this port to be equal to the width of
  the IOPort port. If bidirectional equals true, the width of port
  can also be inferred from the width of this.
  <p>Actors that call this method should have a clone() method that
  repeats the width constraints that were specified in
  the constructor.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>port</code> - A port.</dd>
<dd><code>bidirectional</code> - A flag that specifies whether the constraint
  work in two directions.</dd>
</dl>
</li>
</ul>
<a id="sinkPortList()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sinkPortList</h4>
<pre class="methodSignature">public&nbsp;java.util.List&lt;<a href="IOPort.html" title="class in ptolemy.actor">IOPort</a>&gt;&nbsp;sinkPortList()</pre>
<div class="block">Return a list of the ports that may accept data from this port when
  it sends on the outside.  This includes
  opaque input ports that are connected on the outside to this port
  and opaque output ports that are connected on the inside to this one.
  These are the ports that
  will receive data from this one if data is sent on the outside.
  However, derived classes are free to return ports on this list
  that <i>may</i> receive data from this port, even if they are
  not actually currently connected.  The wireless domain, for
  example, takes advantage of this and includes ports on the
  outside that share the same channel.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A list of IOPort objects.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#getRemoteReceivers()"><code>getRemoteReceivers()</code></a></dd>
</dl>
</li>
</ul>
<a id="sourcePortList()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sourcePortList</h4>
<pre class="methodSignature">public&nbsp;java.util.List&lt;<a href="IOPort.html" title="class in ptolemy.actor">IOPort</a>&gt;&nbsp;sourcePortList()</pre>
<div class="block">Return a list of ports that may send data to this port from the
  outside.  This includes all opaque output ports that are
  connected on the outside to this port, and opaque input ports
  that are connected on the inside to this port. These are the ports that
  will send data to this one.
  However, derived classes are free to return ports on this list
  that <i>may</i> send data to this port, even if they are
  not actually currently connected.  The wireless domain, for
  example, takes advantage of this and includes ports on the
  outside that share the same channel.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A list of IOPort objects, or an empty list if there are none.</dd>
</dl>
</li>
</ul>
<a id="transferInputs()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transferInputs</h4>
<pre class="methodSignature">@Deprecated
public&nbsp;boolean&nbsp;transferInputs()
                       throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Domains should use sendInside directly to
  implement their transferInputs method.</div>
</div>
<div class="block">Transfer data from this port to the ports it is connected to
  on the inside.
  This port must be an opaque input port.  If any
  channel of the this port has no data, then that channel is
  ignored. This method will transfer exactly one token on
  each input channel that has at least one token available.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if at least one data token is transferred.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If this port is not an
  opaque input port.</dd>
</dl>
</li>
</ul>
<a id="transferOutputs()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transferOutputs</h4>
<pre class="methodSignature">@Deprecated
public&nbsp;boolean&nbsp;transferOutputs()
                        throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">domains should use getInside directly to implement their
  transferOutputs method.</div>
</div>
<div class="block">Transfer data from this port to the ports it is connected to on
  the outside.
  This port must be an opaque output port.  If any
  channel of this port has no data, then that channel is
  ignored. This method will transfer exactly one token on
  each output channel that has at least one token available.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if at least one data token is transferred.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the port is not an opaque
  output port.</dd>
</dl>
</li>
</ul>
<a id="unlink(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unlink</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;unlink&#8203;(int&nbsp;index)</pre>
<div class="block">Unlink whatever relation is currently linked at the specified index
  number. If there is no such relation, do nothing.
  If a link is removed, then any links at higher index numbers
  will have their index numbers decremented by one.
  If there is a container, notify it by calling connectionsChanged().
  Invalidate the schedule and resolved types of the director of the
  container, if there is one.
  This method is write-synchronized on the
  workspace and increments its version number.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="../kernel/Port.html#unlink(int)">unlink</a></code>&nbsp;in class&nbsp;<code><a href="../kernel/Port.html" title="class in ptolemy.kernel">Port</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - The index number of the link to remove.</dd>
</dl>
</li>
</ul>
<a id="unlink(ptolemy.kernel.Relation)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unlink</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;unlink&#8203;(<a href="../kernel/Relation.html" title="class in ptolemy.kernel">Relation</a>&nbsp;relation)</pre>
<div class="block">Unlink the specified Relation. The receivers associated with
  this relation, and any data they contain, are lost. If the Relation
  is not linked to this port, do nothing. If the relation is linked
  more than once, then unlink all occurrences.
  Invalidate the schedule and resolved types of the director of the
  container, if there is one.
  Invalidate the schedule and resolved types of the director of the
  container, if there is one.
  This method is write-synchronized on the workspace.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="../kernel/ComponentPort.html#unlink(ptolemy.kernel.Relation)">unlink</a></code>&nbsp;in class&nbsp;<code><a href="../kernel/ComponentPort.html" title="class in ptolemy.kernel">ComponentPort</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>relation</code> - The relation to unlink.</dd>
</dl>
</li>
</ul>
<a id="unlinkAll()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unlinkAll</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;unlinkAll()</pre>
<div class="block">Unlink all relations that are linked on the outside.
  This method is write-synchronized on the
  workspace.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="../kernel/ComponentPort.html#unlinkAll()">unlinkAll</a></code>&nbsp;in class&nbsp;<code><a href="../kernel/ComponentPort.html" title="class in ptolemy.kernel">ComponentPort</a></code></dd>
</dl>
</li>
</ul>
<a id="unlinkAllInside()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unlinkAllInside</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;unlinkAllInside()</pre>
<div class="block">Unlink all relations that are linked on the inside.
  This method is write-synchronized on the
  workspace.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="../kernel/ComponentPort.html#unlinkAllInside()">unlinkAllInside</a></code>&nbsp;in class&nbsp;<code><a href="../kernel/ComponentPort.html" title="class in ptolemy.kernel">ComponentPort</a></code></dd>
</dl>
</li>
</ul>
<a id="unlinkInside(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unlinkInside</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;unlinkInside&#8203;(int&nbsp;index)</pre>
<div class="block">Unlink whatever relation is currently linked on the inside
  with the specified index number. If the relation
  is not linked to this port on the inside, do nothing.
  If a link is removed, then any links at higher index numbers
  will have their index numbers decremented by one.
  If there is a container, notify it by calling connectionsChanged().
  This method is write-synchronized on the workspace
  and increments its version number.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="../kernel/ComponentPort.html#unlinkInside(int)">unlinkInside</a></code>&nbsp;in class&nbsp;<code><a href="../kernel/ComponentPort.html" title="class in ptolemy.kernel">ComponentPort</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>index</code> - The index number of the link to remove.</dd>
</dl>
</li>
</ul>
<a id="unlinkInside(ptolemy.kernel.Relation)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unlinkInside</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;unlinkInside&#8203;(<a href="../kernel/Relation.html" title="class in ptolemy.kernel">Relation</a>&nbsp;relation)</pre>
<div class="block">Unlink the specified Relation on the inside. The receivers associated
  with this relation, and any data they contain, are lost. If the Relation
  is not linked to this port, do nothing. If the relation is linked
  more than once, then unlink all occurrences.
  This method is write-synchronized on the workspace.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="../kernel/ComponentPort.html#unlinkInside(ptolemy.kernel.Relation)">unlinkInside</a></code>&nbsp;in class&nbsp;<code><a href="../kernel/ComponentPort.html" title="class in ptolemy.kernel">ComponentPort</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>relation</code> - The relation to unlink.</dd>
</dl>
</li>
</ul>
<a id="_checkContainer(ptolemy.kernel.Entity)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_checkContainer</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;_checkContainer&#8203;(<a href="../kernel/Entity.html" title="class in ptolemy.kernel">Entity</a>&nbsp;container)
                        throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Check that the specified container implements the Actor interface
  (or is null).</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="../kernel/ComponentPort.html#_checkContainer(ptolemy.kernel.Entity)">_checkContainer</a></code>&nbsp;in class&nbsp;<code><a href="../kernel/ComponentPort.html" title="class in ptolemy.kernel">ComponentPort</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>container</code> - The proposed container.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the container is not of
   an acceptable class.</dd>
</dl>
</li>
</ul>
<a id="_checkLiberalLink(ptolemy.kernel.Relation)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_checkLiberalLink</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;_checkLiberalLink&#8203;(<a href="../kernel/Relation.html" title="class in ptolemy.kernel">Relation</a>&nbsp;relation)
                          throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Override parent method to ensure compatibility of the relation
  and validity of the width of the port.
  If this port is not a multiport, then the width of the
  relation is required to be specified to be one.  This method
  allows level-crossing links.
  This method is <i>not</i> synchronized on the
  workspace, so the caller should be.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="../kernel/ComponentPort.html#_checkLiberalLink(ptolemy.kernel.Relation)">_checkLiberalLink</a></code>&nbsp;in class&nbsp;<code><a href="../kernel/ComponentPort.html" title="class in ptolemy.kernel">ComponentPort</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>relation</code> - The relation to link to on the inside.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If this port has no container or
   the relation is not an IORelation, or the port already linked to a
   relation and is not a multiport, or the relation has width
   not exactly one and the port is not a multiport, or the
   relation is incompatible with this port, or the port is not
   in the same workspace as the relation.</dd>
</dl>
</li>
</ul>
<a id="_checkLink(ptolemy.kernel.Relation)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_checkLink</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;_checkLink&#8203;(<a href="../kernel/Relation.html" title="class in ptolemy.kernel">Relation</a>&nbsp;relation)
                   throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Override parent method to ensure compatibility of the relation
  and validity of the width of the port.
  If this port is not a multiport, then the width of the
  relation is required to be specified to be one.
  This method is <i>not</i> synchronized on the
  workspace, so the caller should be.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="../kernel/ComponentPort.html#_checkLink(ptolemy.kernel.Relation)">_checkLink</a></code>&nbsp;in class&nbsp;<code><a href="../kernel/ComponentPort.html" title="class in ptolemy.kernel">ComponentPort</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>relation</code> - The relation to link to.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If this port has no container or
   the relation is not an IORelation, or the port already linked to a
   relation and is not a multiport, or if the relation has width
   not exactly one and the port is not a multiport, or the port is
   not in the same workspace as the relation.</dd>
</dl>
</li>
</ul>
<a id="_description(int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_description</h4>
<pre class="methodSignature">protected&nbsp;java.lang.String&nbsp;_description&#8203;(int&nbsp;detail,
                                        int&nbsp;indent,
                                        int&nbsp;bracket)
                                 throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Return a description of the object.  The level of detail depends
  on the argument, which is an or-ing of the static final constants
  defined in the NamedObj class and in this class.
  Lines are indented according to
  to the level argument using the protected method _getIndentPrefix().
  Zero, one or two brackets can be specified to surround the returned
  description.  If one is specified it is the leading bracket.
  This is used by derived classes that will append to the description.
  Those derived classes are responsible for the closing bracket.
  An argument other than 0, 1, or 2 is taken to be equivalent to 0.
  <p>
  If the detail argument sets the bit defined by the constant
  CONFIGURATION, then append to the description a field containing
  any subset of the words "input", "output", "multiport", and "opaque",
  separated by spaces, plus a subfield of the form "{width
  <i>integer</i>}", where the integer is the width of the port.
  The field keyword is "configuration".
  <p>
  If the detail argument sets the bit defined by the constant
  RECEIVERS, then append to the description a field containing
  the receivers contained by this port.  The keyword is "receivers"
  and the format is like the Receivers array, an array of groups, with
  each group receiving from a channel.
  Each group is a list of receiver descriptions (it may also be empty).
  If the detail argument sets the bit defined by the constant
  REMOTERECEIVERS, then also append to the description a field containing
  the remote receivers connected to this port.

  This method is read-synchronized on the workspace.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="../kernel/ComponentPort.html#_description(int,int,int)">_description</a></code>&nbsp;in class&nbsp;<code><a href="../kernel/ComponentPort.html" title="class in ptolemy.kernel">ComponentPort</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>detail</code> - The level of detail.</dd>
<dd><code>indent</code> - The amount of indenting.</dd>
<dd><code>bracket</code> - The number of surrounding brackets (0, 1, or 2).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A description of the object.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If thrown while getting the
  description of subcomponents.</dd>
</dl>
</li>
</ul>
<a id="_exportMoMLContents(java.io.Writer,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_exportMoMLContents</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;_exportMoMLContents&#8203;(java.io.Writer&nbsp;output,
                                   int&nbsp;depth)
                            throws java.io.IOException</pre>
<div class="block">Write a MoML description of the contents of this object, which
  in this class is the attributes plus possibly a special attribute
  to indicate whether the port is a multiport.  This method is called
  by _exportMoML().  If there are attributes, then
  each attribute description is indented according to the specified
  depth and terminated with a newline character.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="../kernel/util/NamedObj.html#_exportMoMLContents(java.io.Writer,int)">_exportMoMLContents</a></code>&nbsp;in class&nbsp;<code><a href="../kernel/util/NamedObj.html" title="class in ptolemy.kernel.util">NamedObj</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>output</code> - The output stream to write to.</dd>
<dd><code>depth</code> - The depth in the hierarchy, to determine indenting.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.io.IOException</code> - If an I/O error occurs.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../kernel/util/NamedObj.html#exportMoML(java.io.Writer,int)"><code>NamedObj.exportMoML(Writer, int)</code></a></dd>
</dl>
</li>
</ul>
<a id="_getInsideWidth(ptolemy.actor.IORelation)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_getInsideWidth</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;_getInsideWidth&#8203;(<a href="IORelation.html" title="class in ptolemy.actor">IORelation</a>&nbsp;except)
                       throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Return the sums of the widths of the relations linked on the
  inside, except the specified relation.  If any of these relations
  has not had its width specified, throw an exception.  This is
  used by IORelation to infer the width of a bus with
  unspecified width and to determine whether more than one
  relation with unspecified width is linked on the inside, and
  by the liberalLink() method to check validity of the link.  If
  the argument is null, all relations linked on the inside are
  checked.  This method is not read-synchronized on the
  workspace, so the caller should be.
  This method ignores the relations for which the width still has
  to be inferred.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>except</code> - The relation to exclude.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The sums of the width of the relations linked on the inside,
  except for the specified port.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If thrown while checking if a
  relation needs width inference, while getting the width of the
  relation, while checking if the width or a relation is fixed.</dd>
</dl>
</li>
</ul>
<a id="_getOutsideWidth(ptolemy.actor.IORelation)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_getOutsideWidth</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;_getOutsideWidth&#8203;(<a href="IORelation.html" title="class in ptolemy.actor">IORelation</a>&nbsp;except)
                        throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Return the sums of the widths of the relations linked on the
  outside, except the specified relation.  If any of these relations
  has not had its width specified, throw an exception.  This is
  used by IORelation to infer the width of a bus with
  unspecified width and to determine whether more than one
  relation with unspecified width is linked on the outside, and
  by the liberalLink() method to check validity of the link.  If
  the argument is null, all relations linked on the inside are
  checked.  This method is not read-synchronized on the
  workspace, so the caller should be.
  This method ignores the relations for which the width still has
  to be inferred.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>except</code> - The relation to exclude.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The sums of the width of the relations linked on the outside,
  except for the specified port.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If thrown while checking if a
  relation needs width inference, while getting the width of the
  relation, while checking if the width or a relation is fixed.</dd>
</dl>
</li>
</ul>
<a id="_getReceiversLinkedToGroup(ptolemy.actor.IORelation,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_getReceiversLinkedToGroup</h4>
<pre class="methodSignature">protected&nbsp;<a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>[][]&nbsp;_getReceiversLinkedToGroup&#8203;(<a href="IORelation.html" title="class in ptolemy.actor">IORelation</a>&nbsp;relation,
                                                  int&nbsp;occurrence)
                                           throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">If the port is an input, return receivers that handle incoming
  channels from the specified relation or any relation in its
  relation group. If the port is an opaque output
  and the relation is inside linked, return the receivers that handle
  incoming channels from the inside. Since the port may be linked
  multiple times to the specified relation, the <i>occurrences</i>
  argument specifies which of the links we wish to examine.
  The returned value is an array of arrays of the same form
  as that returned by getReceivers() with no arguments.  Note that a
  single occurrence of a relation may represent multiple channels
  because it may be a bus.  If there are no matching receivers,
  then return an empty array.
  <p>
  This method handles relation groups. That is, given any relation
  in a relation group, it returns the combined receivers of all
  the relations in the relation group, in the order as returned
  by the getRelationGroup() method of Receiver.
  <p>
  This method is read-synchronized on the workspace.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>relation</code> - Relations that are linked on the outside or inside.</dd>
<dd><code>occurrence</code> - The occurrence number that we are interested in,
   starting at 0.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The local receivers, or an empty array if there are none.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the relation is not linked
   from the outside.</dd>
</dl>
</li>
</ul>
<a id="_newInsideReceiver()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_newInsideReceiver</h4>
<pre class="methodSignature">protected&nbsp;<a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>&nbsp;_newInsideReceiver()
                               throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Create a new receiver compatible with the local director.
  This is done by asking the local director of the container for
  a new receiver, and then setting its
  container to this port.  This allows actors to work across
  several domains, since often the only domain-specific part of
  of an actor is its receivers.  Derived classes may choose to
  handle this directly, creating whatever specific type of receiver
  they want. This method is not read-synchronized
  on the workspace, so the caller should be.
  <p>
  The returned receiver is either the new receiver, or another
  receiver wrapping it as specified in <a href="#_wrapReceiver(ptolemy.actor.Receiver,int)"><code>_wrapReceiver(Receiver, int)</code></a>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new receiver.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the port has no container,
   or the container is unable to return a new receiver (for example
   if it has no local director).</dd>
</dl>
</li>
</ul>
<a id="_newInsideReceiver(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_newInsideReceiver</h4>
<pre class="methodSignature">protected&nbsp;<a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>&nbsp;_newInsideReceiver&#8203;(int&nbsp;channel)
                               throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Create a new receiver compatible with the local director.
  This is done by asking the local director of the container for
  a new receiver, and then setting its
  container to this port.  This allows actors to work across
  several domains, since often the only domain-specific part of
  of an actor is its receivers.  Derived classes may choose to
  handle this directly, creating whatever specific type of receiver
  they want. This method is not read-synchronized
  on the workspace, so the caller should be.
  <p>
  The returned receiver is either the new receiver, or another
  receiver wrapping it as specified in <a href="#_wrapReceiver(ptolemy.actor.Receiver,int)"><code>_wrapReceiver(Receiver, int)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channel</code> - Used to determine source port.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new receiver.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the port has no container,
   or the container is unable to return a new receiver (for example
   if it has no local director).</dd>
</dl>
</li>
</ul>
<a id="_newReceiver()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_newReceiver</h4>
<pre class="methodSignature">protected&nbsp;<a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>&nbsp;_newReceiver()
                         throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Create a new receiver compatible with the executive director.
  This is done by asking the
  containing actor for a new receiver, and then setting its
  container to this port.  This allows actors to work across
  several domains, since often the only domain-specific part of
  of an actor is its receivers.  Derived classes may choose to
  handle this directly, creating whatever specific type of receiver
  they want.  This method is not write-synchronized
  on the workspace, so the caller should be.
  <p>
  The returned receiver is either the new receiver, or another
  receiver wrapping it as specified in <a href="#_wrapReceiver(ptolemy.actor.Receiver,int)"><code>_wrapReceiver(Receiver, int)</code></a>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new receiver.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the port has no container,
   or the container is unable to return a new receiver (for example
   if it has no executive director).</dd>
</dl>
</li>
</ul>
<a id="_newReceiver(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_newReceiver</h4>
<pre class="methodSignature">protected&nbsp;<a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>&nbsp;_newReceiver&#8203;(int&nbsp;channel)
                         throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Create a new receiver compatible with the executive director.
  This is done by asking the
  containing actor for a new receiver, and then setting its
  container to this port.  This allows actors to work across
  several domains, since often the only domain-specific part of
  of an actor is its receivers.  Derived classes may choose to
  handle this directly, creating whatever specific type of receiver
  they want.  This method is not write-synchronized
  on the workspace, so the caller should be.
  <p>
  The returned receiver is either the new receiver, or another
  receiver wrapping it as specified in <a href="#_wrapReceiver(ptolemy.actor.Receiver,int)"><code>_wrapReceiver(Receiver, int)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channel</code> - Channel id used to determine the source port.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new receiver.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If the port has no container,
   or the container is unable to return a new receiver (for example
   if it has no executive director).</dd>
</dl>
</li>
</ul>
<a id="_removeReceivers(ptolemy.kernel.Relation)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_removeReceivers</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;_removeReceivers&#8203;(<a href="../kernel/Relation.html" title="class in ptolemy.kernel">Relation</a>&nbsp;relation)</pre>
<div class="block">Remove the receivers associated with the specified
  relation, if there are any.  This sets the container
  of each receiver to null.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>relation</code> - The relation.</dd>
</dl>
</li>
</ul>
<a id="_notifyPortEventListeners(ptolemy.actor.IOPortEvent)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_notifyPortEventListeners</h4>
<pre class="methodSignature">protected final&nbsp;void&nbsp;_notifyPortEventListeners&#8203;(<a href="IOPortEvent.html" title="class in ptolemy.actor">IOPortEvent</a>&nbsp;event)
                                        throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">Send a PortEvent to all port event listeners that
  have registered with this IOPort.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>event</code> - The event.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If thrown by portEvent().</dd>
</dl>
</li>
</ul>
<a id="_setConstant(ptolemy.data.Token,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_setConstant</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;_setConstant&#8203;(<a href="../data/Token.html" title="class in ptolemy.data">Token</a>&nbsp;token,
                            int&nbsp;limit)</pre>
<div class="block">Set a constant token so that every call to <a href="#get(int)"><code>get(int)</code></a>
  or <a href="#get(int,int)"><code>get(int,int)</code></a> replaces the returned token(s) with
  this specified token. This is a rather specialized piece
  of functionality added to be able to support
  <a href="ConstantPublisherPort.html" title="class in ptolemy.actor"><code>ConstantPublisherPort</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>token</code> - The token to return instead of received tokens,
   or null to cancel this functionality.</dd>
<dd><code>limit</code> - If a non-negative number is given here, then
   limit the number of constant tokens provided.</dd>
</dl>
</li>
</ul>
<a id="_wrapReceiver(ptolemy.actor.Receiver,int)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>_wrapReceiver</h4>
<pre class="methodSignature">protected&nbsp;<a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>&nbsp;_wrapReceiver&#8203;(<a href="Receiver.html" title="interface in ptolemy.actor">Receiver</a>&nbsp;receiver,
                                 int&nbsp;channel)
                          throws <a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></pre>
<div class="block">If this port has parameters whose values are tokens that contain
  an object implementing <a href="CommunicationAspect.html" title="interface in ptolemy.actor"><code>CommunicationAspect</code></a>, then wrap the
  receiver specified in the argument using those communication aspects.
  If there are no such parameters, then simply return the specified
  receiver. If there is one such parameter, then use the quantity
  manager to wrap the specified receiver in a new receiver, and return
  that receiver. If there are two such parameters, then use the second
  communication aspect to create a receiver that wraps that created by the
  first communication aspect. Etc.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>receiver</code> - The receiver to wrap.</dd>
<dd><code>channel</code> - Channel id used to determine the source port.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Either a new receiver wrapping the specified receiver,
   or the specified receiver.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../kernel/util/IllegalActionException.html" title="class in ptolemy.kernel.util">IllegalActionException</a></code> - If any parameter of the port
   cannot be evaluated.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="CommunicationAspect.html" title="interface in ptolemy.actor"><code>CommunicationAspect</code></a></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
