<?xml version="1.0" standalone="yes"?>
<!DOCTYPE doc PUBLIC "-//UC Berkeley//DTD DocML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/DocML_1.dtd">
<doc name="DTDirector" class="ptolemy.domains.dt.kernel.DTDirector">
  <description>
The Discrete Time (DT) domain director.&#10;&#10; &lt;h1&gt;DT overview&lt;/h1&gt;&#10;&#10; &lt;p&gt;The Discrete Time (DT) domain is a timed extension of the Synchronous&#10; Dataflow (SDF) domain.  Like SDF, it has static scheduling of the&#10; dataflow graph model. Similarly, DT requires that the data rates on&#10; the ports of all actors be known beforehand and fixed. DT handles&#10; feedback systems in the same way that SDF does, but with additional&#10; constraints on initial tokens.&lt;/p&gt;&#10;&#10; &lt;h1&gt;Local and Global Time&lt;/h1&gt;&#10;&#10; &lt;p&gt; Because of the inherent concurrency occurring within SDF models, there&#10; are two notions of time in DT -- global time and local time.  Global&#10; time increases steadily as execution progresses.  Moreover, global&#10; time increases by fixed discrete amounts given by the &lt;i&gt;period&lt;/i&gt;&#10; parameter. On the other hand, each receiver is associated with an&#10; independent local time. All the receivers have distinct local times as&#10; an iteration proceeds. The local time of a receiver during an&#10; iteration depends on the global time, period, firing count, port&#10; rates, and the schedule. These local times obey the following&#10; constraint:&lt;/p&gt;&#10;&#10;  &lt;center&gt;Global Time  &amp;lt;=  Local Time &amp;lt;= (Global Time + period)&lt;/center&gt;&#10;&#10; &lt;p&gt;The exact way that local time increments during an iteration is described in&#10; detail in the DTReceiver documentation.&lt;/p&gt;n&#10;&#10; &lt;h1&gt; Period Parameter &lt;/h1&gt;&lt;p&gt;&#10;&#10; &lt;p&gt;The DT director has a &lt;i&gt;period&lt;/i&gt; parameter which specifies the&#10; amount of time per iteration. For hierarchical DT, this period&#10; parameter only makes sense on the top-level. The user cannot&#10; explicitly set the period parameter for a DT subsystem inside another&#10; DT system. For heterogeneous hierarchies (e.g. DT inside DE or DT&#10; inside CT), the period parameter specifies the time interval between&#10; firings of the DT subsystem. The DT subsystem will not fire on times&#10; that are not integer multiples of the period parameter.&lt;/p&gt;&#10;&#10; &lt;h1&gt;DT Features&lt;/h1&gt;&#10; &lt;p&gt;The design of the DT domain is motivated by the following criteria:&lt;/p&gt;&#10; &lt;ol&gt;&#10;&#10; &lt;li&gt;) Uniform Token Flow: The time interval between tokens should be&#10; regular and unchanging.  This conforms to the idea of having sampled&#10; systems with fixed rates. Although the tokens flowing in DT do not&#10; keep internal time stamps, each actor can query the DT director for&#10; its own local time.  This local time is uniformly increasing by a&#10; constant fraction of the director's &lt;i&gt;period&lt;/I&gt;.  Local time is&#10; incremented every time the get() method is called to obtain a token.&lt;/li&gt;&#10;&#10; &lt;li&gt;) Causality: Tokens produced by an actor should only depend on&#10; tokens produced or consumed in the past. This makes sense because we&#10; don't expect an actor to produce a token before it can calculate the&#10; token's value.  For example, if an actor needs three tokens A, B, and&#10; C to compute token D, then the time when tokens A, B, and C are&#10; consumed should be earlier than or equal to the time when token D is&#10; produced.  Note that in DT, time does not get incremented due to&#10; computation.&lt;/li&gt;&#10;&#10; &lt;li&gt;) SDF-style semantics: Ideally, we want DT to be a&#10; timed-superset of SDF with compatible token flow and scheduling.&#10; However, we can only approximate this behavior. It is not possible to&#10; have uniform token flow, causality, and SDF-style semantics at the&#10; same time.  Causality breaks for non-homogeneous actors in a feedback&#10; system when fully-compatible SDF-style semantics is adopted.  To&#10; remedy this situation, every actor in DT that has non-homogeneous&#10; input ports should produce initial tokens at each of its output ports.&lt;/li&gt;&#10;&#10; &lt;/oL&gt;&#10; &lt;h1&gt; Design Notes&lt;/h1&gt;&#10; &lt;p&gt;DT (Discrete Time) is a timed model of computation.  In order&#10; to benefit from the internal time-keeping mechanism of DT, one should&#10; use actors aware of time. For example, one should use TimedPlotter or&#10; TimedScope instead of SequencePlotter or SequenceScope.&lt;/p&gt;&#10;&#10; &lt;p&gt; Top-level DT Directors have a &lt;i&gt;period&lt;/i&gt; parameter that can be set by the&#10; user.  Setting the period parameter of a non-top-level DT Director&#10; under hierarchical DT has no meaning; and hence will be ignored.&lt;/p&gt;&#10;&#10; &lt;p&gt; Domain-polymorphic actors that want to take advantage of the&#10; multi-rate timing capabilities of DT should call&#10; getCurrentTime(channel_number) for every&#10; get(channel_number). Moreover, the call sequence should be ordered as&#10; follows: getCurrentTime(channel_number) before get(channel_number). &lt;p&gt;&#10;&#10; Known bugs:&#10; &lt;pre&gt;&#10; 1.) Put more tests on this case: when events come in faster than the period&#10; of a DT composite actor (e.g clock feeding DT)&#10; 2.) Put more tests on this case: when DT composite actor doesn't fire because&#10; there aren't enough tokens.&#10; 3.) Domain-polymorphic actors that use getCurrentTime() should be modified&#10; to use DT's multirate timing capabilities.&#10; CurrentTime  - modified&#10; TimedPlotter - modified&#10; TimedScope   - modified&#10; SequentialClock - no input ports, gets global time only&#10; PoissonClock - under investigation&#10; Clock        - under investigation&#10; Expression   - under investigation&#10; 4.) This director does not implement fireAt(). Instead, it inherits&#10; the implementation from SDF, which isn't quite correct. It does not always&#10; return the correct next time of firing. As a workaround, this class does not&#10; check the values returned by fireAt(). Thus, if it is embedded in a domain&#10; that does not respect the calls to fireAt(), then the user could get&#10; odd behavior without any error reported.&#10; &lt;/pre&gt;  </description>
  <author>C. Fong</author>
  <version>$Id$</version>
  <since>Ptolemy II 1.0</since>
  <Pt.ProposedRating>Yellow (chf)</Pt.ProposedRating>
  <Pt.AcceptedRating>Yellow (vogel)</Pt.AcceptedRating>
</doc>
