<?xml version="1.0" standalone="yes"?>
<!DOCTYPE doc PUBLIC "-//UC Berkeley//DTD DocML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/DocML_1.dtd">
<doc name="MetroIIDirector" class="ptolemy.domains.metroII.kernel.MetroIIDirector">
  <description>
&lt;p&gt;&#10; A MetroII Director governs the execution of actors with simplified MetroII&#10; execution semantics. The major distinction from other directors is the way&#10; MetroIIDirector fires the actors. In stead of explicitly calling fire() of&#10; the governing actors, MetroIIDirector implicitly fires actors by exchanging&#10; MetroII events with actors (@see&#10; ptolemy.domains.metroII.kernel.util.ProtoBuf.Event). Under MetroIIDirector,&#10; each actor is wrapped by either BlockingFire (@see BlockingFire) or&#10; ResumableFire (@see ResumableFire). With a wrapper, the firing of an actor is&#10; a process which executes and then blocks to generate MetroII events. Each&#10; MetroII event has one of the following states: PROPOSED, WAITING, and&#10; NOTIFIED. When the firing of an actor blocks to generate MetroII events, the&#10; events are sent to MetroIIDirector with the state of PROPOSED. This is also&#10; referred to as proposing MetroII events. MetroIIDirector delegates the events&#10; to constraint solvers (@see ConstraintSolver) which update the event states&#10; to either WAITING or NOTIFIED. If any event state of a process is updated to&#10; NOTIFIED, the process is supposed to resume execution. The resumed execution&#10; may depend on the updated events.&#10; &lt;/p&gt;&#10;&#10; &lt;p&gt;&#10; The execution of MetroIIDirector has two phases. In Phase 1, MetroIIDirector&#10; repeatedly fires each actor (no particular order should be presumed). As&#10; mentioned, each firing is a process runs and then blocks to propose MetroII&#10; events. Phase 1 ends when all processes of firing are blocked. In Phase 2,&#10; MetroIIDirector delegates all the proposed events to constraint solvers (@see&#10; ConstraintSolver), which updates the states of MetroII events based on the&#10; constraints. In particular, MappingConstraintSolver (MappingConstraintSolver)&#10; is a constraint solver that resolves rendezvous constraints. A rendezvous&#10; constraint requires the specified pair of MetroII events must be proposed&#10; together, otherwise the states will be updated to WAITING. A collection of&#10; two completed phases is referred to as an iteration. After constraint&#10; resolving in Phase 2, MetroIIDirector goes back to Phase 1, in which each&#10; existing process has a chance to react to the updated MetroII events. The&#10; process with at least one NOTIFIED event is supposed to resume execution&#10; while the process with all events WAITING keeps blocked. If the process of&#10; firing successfully completes in last iteration, a new process will be&#10; created as long as prefire() returns true. The actor with postfire() returns&#10; false will not be fired any more.&#10; &lt;/p&gt;&#10;&#10; &lt;p&gt;&#10; An actor that implements GetFirable interface (@see GetFirable) is wrapped by&#10; ResumableFire (@see ResumableFire). Otherwise it's wrapped by BlockingFire (@see&#10; BlockingFire). Particularly, the MetroIIComposite, MetroIIModalModel,&#10; MetroIIPtidesPlatform have GetFirable interface implemented and are thus&#10; wrapped by ResumableFire. And all other ordinary Ptolemy actors are wrapped&#10; by BlockingFire. If an actor is wrapped by BlockingFire, the firing of an&#10; actor has two MetroII events associated: FIRE_BEGIN and FIRE_END. FIRE_BEGIN&#10; is first proposed and the firing blocks. When FIRE_BEGIN is NOTIFIED, fire()&#10; is called and FIRE_END is proposed. When FIRE_END is NOTIFIED, the firing&#10; successfully completes. The firing is atomic and there is no chance to&#10; propose events during firing. If an actor is wrapped by ResumableFire, in&#10; addition to FIRE_BEGIN and FIRE_END, getfire(MetroII event list) is called&#10; instead of fire(). The process of firing may not only block on FIRE_BEGIN and&#10; FIRE_END, but also block on the internal events of getfire(MetroII event&#10; list).&#10; &lt;/p&gt;&#10;&#10; &lt;p&gt;&#10; In ResumableFire, the 'start', 'block', and 'resume' are realized using&#10; YieldAdapter, see &lt;a&#10; href=&quot;http://jimblackler.net/blog/?p=61&quot;&gt;http://jimblackler&#10; .net/blog/?p=61&lt;/a&gt;. The underlying mechanism is to create, suspend, and&#10; resume a java thread. And proposed MetroII events are returned by the&#10; parameters of startOrResume().&#10; &lt;/p&gt;  </description>
  <author>Liangpeng Guo</author>
  <version>$Id$</version>
  <since>Ptolemy II 10.0</since>
  <Pt.ProposedRating>Red (glp)</Pt.ProposedRating>
  <Pt.AcceptedRating>Red (glp)</Pt.AcceptedRating>
    <!--ptolemy.data.expr.FileParameter-->
    <property name="mappingFileName">A mapping constraint is a pair of events that are rendezvous. Mapping&#10; file is a text file that specifies such constraints. In mapping file,&#10; each line is a mapping constraint, which contains two event names&#10; separated by a space.&#10;&#10; &lt;p&gt;&#10; _mappingFileName is a string that contains the absolute path of the&#10; mapping file.&#10; &lt;/p&gt;&#10;&#10; The default value of _mappingFileName is null, which means no mapping&#10; constraint is specified.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="iterations">A Parameter representing the number of times that postfire may be called&#10; before it returns false. If the value is less than or equal to zero, then&#10; the execution will never return false in postfire, and thus the execution&#10; can continue forever.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="printTrace">Option parameter whether trace info is printed out.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="printDebug">Option parameter whether debug info is printed out.</property>
</doc>
