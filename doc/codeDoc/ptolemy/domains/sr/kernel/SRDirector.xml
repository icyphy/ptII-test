<?xml version="1.0" standalone="yes"?>
<!DOCTYPE doc PUBLIC "-//UC Berkeley//DTD DocML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/DocML_1.dtd">
<doc name="SRDirector" class="ptolemy.domains.sr.kernel.SRDirector">
  <description>
A director for the Synchronous Reactive (SR) model of computation.&#10; The SR model of computation has a notion of a global &quot;tick&quot; of a&#10; clock, and at each tick of the clock, each port either has a value&#10; or is &quot;absent.&quot; The job of this director is determine what that&#10; value is for each connection between ports. An iteration of this&#10; director is one tick of this global clock.&#10; &lt;p&gt;&#10; Execution proceeds as follows. The director checks&#10; each actor to determine whether it is &lt;i&gt;strict&lt;/i&gt; or not by calling&#10; its isStrict() method (here, &quot;strict&quot; means that all inputs&#10; must be known before the actor can specify any outputs).&#10; By default, actors are strict. Strict actors are fired only&#10; once in an iteration. Their inputs are all known (and may&#10; absent) when prefire() is invoked. If prefire() returns true,&#10; the fire() and postfire() are invoked exactly once.&#10; &lt;p&gt;&#10; Specialized actors may be non-strict, meaning that they are able&#10; to produce outputs even their inputs are not known. Such actors&#10; must conform to certain requirements in order to ensure determinacy.&#10; First, such actors should check input ports by calling their&#10; isKnown() method before calling hasToken() to determine whether&#10; the port is &quot;absent.&quot; Only if both isKnown() and hasToken() return&#10; true should the actor call get() on that port.&#10; A non-strict actor may be prefired and fired&#10; repeatedly in an iteration if some of the inputs are unknown.&#10; Once an actor is fired with all its inputs known, it will not&#10; be fired again in the same iteration.&#10; A composite actor containing this director is a non-strict actor.&#10; &lt;p&gt;&#10; Each actor's fire() method implements a (possibly state-dependent)&#10; function from input ports to output ports. At each tick of the&#10; clock, the fire() method of each non-strict actor may be evaluated multiple&#10; times, and each time, it &lt;i&gt;must&lt;/i&gt; implement the same function.&#10; Thus, the actors are required to conform with the strict actor&#10; semantics, which means that they do not change their state in&#10; the prefire() or fire() methods, and only change their state&#10; in postfire(). This helps ensure that the actor is &lt;i&gt;monotonic&lt;/i&gt;.&#10; Montonicity implies three constraints on the actor. First, if prefire()&#10; ever returns true during an iteration, then it will return true&#10; on all subsequent invocations of prefire() in the same iteration().&#10; In subsequent iterations, inputs may become known, but once they&#10; are known, the value of the input and whether it is present cannot&#10; change in subsequent firings in the same iteration.&#10; Second, if either prefire() or fire() call clear() on an output port,&#10; then no subsequent invocation in the same iteration can call&#10; put() on the port. Third, if prefire() or fire() call put() on an&#10; output port with some token, then no subsequent invocation in&#10; the same iteration can call clear() or put() with a token with&#10; a different value.&#10; These constraints ensure determinacy.&#10; &lt;/p&gt;&lt;p&gt;&#10; If &lt;i&gt;synchronizeToRealTime&lt;/i&gt; is set to &lt;code&gt;true&lt;/code&gt;,&#10; then the postfire() method stalls until the real time elapsed&#10; since the model started matches the current time.&#10; This ensures that the director does not get ahead of real time. However,&#10; of course, this does not ensure that the director keeps up with real time.&#10; Note that this synchronization occurs &lt;i&gt;after&lt;/i&gt; actors have been fired,&#10; but before they have been postfired.&#10; &lt;p&gt;&#10; The SR director has a &lt;i&gt;period&lt;/i&gt; parameter which specifies the&#10; amount of model time that elapses per iteration. If the value of&#10; &lt;i&gt;period&lt;/i&gt; is 0.0 (the default), then it has no effect, and&#10; this director never increments time nor calls fireAt() on the&#10; enclosing director. If the period is greater than 0.0, then&#10; if this director is at the top level, it increments&#10; time by this amount in each invocation of postfire().&#10; If it is not at the top level, then it refuses to fire&#10; at times that do not match a multiple of the &lt;i&gt;period&lt;/i&gt;&#10; (by returning false in prefire()).&#10; If it fires, then in postfire() it calls&#10; fireAt(currentTime + period) in postfire() to request&#10; the next firing.&#10;  &lt;/p&gt;&lt;p&gt;&#10; Note that currentTime, as usual, means local time.&#10; If this director is inside a modal model, then that current&#10; time may lag behind the time of the environment in which&#10; the modal model executes because time does not elapse while&#10; a mode is inactive. In fact, time may bounce around, since&#10; if a &lt;i&gt;startTime&lt;/i&gt; is specified and the modal model has&#10; a reset transition, then local time may be reinitialized&#10; to the start time during execution. Moreover, if the&#10; &lt;i&gt;startTime&lt;/i&gt; of this director inside a modal is greater&#10; than the start time of the enclosing director, then local&#10; time may actually be &lt;i&gt;ahead&lt;/i&gt; of environment time.&#10; &lt;/p&gt;&lt;p&gt;&#10; This behavior gives an interesting use of SR within DE or&#10; Continuous. In particular, if set a period other than 0.0,&#10; the composite actor with this SR director will fire periodically&#10; with the specified period.&#10; &lt;/p&gt;&lt;p&gt;&#10; If &lt;i&gt;period&lt;/i&gt; is greater than 0.0 and the parameter&#10; &lt;i&gt;synchronizeToRealTime&lt;/i&gt; is set to &lt;code&gt;true&lt;/code&gt;,&#10; then the prefire() method stalls until the real time elapsed&#10; since the model started matches the period multiplied by&#10; the iteration count.&#10; This ensures that the director does not get ahead of real time. However,&#10; of course, this does not ensure that the director keeps up with real time.  </description>
  <author>Paul Whitaker, Edward A. Lee, Contributor: Ivan Jeukens, Haiyang Zheng</author>
  <version>$Id$</version>
  <since>Ptolemy II 2.0</since>
  <Pt.ProposedRating>Green (pwhitake)</Pt.ProposedRating>
  <Pt.AcceptedRating>Green (pwhitake)</Pt.AcceptedRating>
    <!--ptolemy.data.expr.Parameter-->
    <property name="period">The time period of each iteration.  This parameter has type double&#10;  and default value 0.0, which means that this director does not&#10;  increment model time and does not request firings by calling&#10;  fireAt() on any enclosing director.  If the value is set to&#10;  something greater than 0.0, then if this director is at the&#10;  top level, it will increment model time by the specified&#10;  amount in its postfire() method. If it is not at the top&#10;  level, then it will call fireAt() on the enclosing executive&#10;  director with the argument being the current time plus the&#10;  specified period.  In addition,&#10;  if it is not at the top level, then it refuses to fire&#10;  at times that do not match a multiple of the &lt;i&gt;period&lt;/i&gt;&#10;  (by returning false in prefire()).</property>
</doc>
