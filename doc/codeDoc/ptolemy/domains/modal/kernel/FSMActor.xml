<?xml version="1.0" standalone="yes"?>
<!DOCTYPE doc PUBLIC "-//UC Berkeley//DTD DocML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/DocML_1.dtd">
<doc name="FSMActor" class="ptolemy.domains.modal.kernel.FSMActor">
  <description>
An FSMActor contains a set of states and transitions. A transition has&#10; a &lt;i&gt;guard expression&lt;/i&gt;, any number of &lt;i&gt;output actions&lt;/i&gt;, and any&#10; number of &lt;i&gt;set actions&lt;/i&gt;. It has an &lt;i&gt;initial state&lt;/i&gt;, which is&#10; the unique state whose &lt;i&gt;isInitialState&lt;/i&gt; parameter is true.&#10; In outline, a firing of this actor is a sequence of steps as&#10; follows. In the fire() method:&#10; &lt;ol&gt;&#10; &lt;li&gt; Read inputs.&#10; &lt;li&gt; Evaluate guards on outgoing transitions of the current state.&#10; &lt;li&gt; Choose a transitions whose guard is true.&#10; &lt;li&gt; Execute the output actions.&#10; &lt;/ol&gt;&#10; In the postfire() method:&#10; &lt;ol&gt;&#10; &lt;li&gt; Execute the set actions of the chosen transition.&#10; &lt;li&gt; Change the current state to the destination of the chosen transition.&#10; &lt;/ol&gt;&#10; The fire() method may be invoked more than once&#10; in an iteration, for example in a fixedpoint iteration.&#10; This actor makes no persistent state changes in&#10; its fire()  method, so actor conforms&#10; with the &lt;i&gt;actor abstract semantics&lt;/i&gt;, and hence can be used in any&#10; Ptolemy II domain.&#10; &lt;p&gt;&#10; After reading the inputs, this actor examines&#10; the outgoing transitions of the current state, evaluating their&#10; guard expressions. A transition is &lt;i&gt;enabled&lt;/i&gt; if its guard&#10; expression evaluates to true. A blank guard expression is&#10; interpreted to be always true. The guard expression may refer to any&#10; input port and any variable in scope.&#10; &lt;p&gt;&#10; If an input port name &lt;i&gt;portName&lt;/i&gt; is used in a guard expression,&#10; it refers to the current input on that port on channel zero.&#10; If the input port status is not known, or if the input is absent,&#10; then a guard expression referring to &lt;i&gt;portName&lt;/i&gt; will not be evaluated.&#10; The guard expression may alternatively refer to &lt;i&gt;portName&lt;/i&gt;_&lt;i&gt;isPresent&lt;/i&gt;,&#10; which is a boolean that is true if an input is present on the specified&#10; port. Again, if the input port status is not known, such a guard&#10; would not be evaluated. The status of an input port may not be&#10; known during firings under a director with fixed-point semantics,&#10; such as SR or Continuous.&#10; &lt;p&gt;&#10; To refer to a channel specifically, a guard expression may use&#10; &lt;i&gt;portName&lt;/i&gt;_&lt;i&gt;channelIndex&lt;/i&gt;, which has value equal to the token&#10; received on the port on the given channel. Similarly, it may refer&#10; to &lt;i&gt;portName&lt;/i&gt;_&lt;i&gt;channelIndex&lt;/i&gt;_&lt;i&gt;isPresent&lt;/i&gt;.&#10; &lt;p&gt;&#10; FIXME: Document multirate behavior.&#10; &lt;p&gt;&#10; The identifier &lt;i&gt;portName&lt;/i&gt;Array or&#10; &lt;i&gt;portName&lt;/i&gt;_&lt;i&gt;channelIndex&lt;/i&gt;Array refers the&#10; array of all tokens consumed from the port in the last firing.  This&#10; identifier has an array type whose element type is the type of the&#10; corresponding input port.&#10; &lt;p&gt;&#10; Nondeterministic transitions are allowed if all enabled transitions&#10; are marked &lt;i&gt;nondeterministic&lt;/i&gt;. If more than one transition is&#10; enabled and they are all marked nondeterministic, then one is chosen&#10; at random in the fire() method. Note that this class provides no&#10; guarantees about the probability of selecting a particular&#10; nondeterministic transition. It is perfectly valid to always&#10; choose the same one, for example. To provide such a guarantee,&#10; we would have to impose the constraint that no nondeterministic&#10; transition can be chosen until the guards of all nondeterministic&#10; transitions can be evaluated. This would rule out certain models,&#10; in particular those that illustrate the celebrated Brock-Ackerman&#10; anomaly.  Hence, in this implementation,&#10; if the fire() method is invoked more&#10; than once in an iteration, then subsequent invocations in the same&#10; iteration will always choose the same transition, if it is still&#10; enabled. If more transitions become enabled in subsequent firings and&#10; they are not all marked nondeterminate, then an&#10; exception will thrown. All of this means that&#10; if some input is unknown on the first invocation&#10; of fire(), and a guard refers to that input, then that transition&#10; will not be chosen. As a consequence, for nondeterministic state&#10; machines, the behavior may depend on the order of firings in&#10; a fixed-point iteration. This is in fact unavoidable (it is&#10; related to the celebrated Brock-Ackerman anomaly, which demonstrates&#10; that the input/output relations of a nondeterministic system do&#10; not completely determine its behavior; the context in which it&#10; is used can also affect the behavior; specifically, the context&#10; may make it impossible to know the value of input on the first&#10; invocation of fire() because of a feedback loop). Thus, to&#10; correctly realize all nondeterministic systems, we cannot provide&#10; probabilistic execution of nondeterministic transitions.&#10; &lt;p&gt;&#10; If no transition is&#10; enabled and all their guard expressions have been evaluated (all relevant&#10; inputs are known), then if there is a transition marked as a&#10; &lt;i&gt;default transition&lt;/i&gt;, then that transition is chosen. If&#10; there is more than one default transition and they are all marked&#10; nondeterministic, then one is chosen at random.&#10; &lt;p&gt;&#10; Once a transition is chosen, its output actions are executed.&#10; Typically, these will write values to output ports. The form of an output&#10; action is typically &lt;i&gt;y&lt;/i&gt; = &lt;i&gt;expression&lt;/i&gt;, where expression may&#10; refer to any variable defined as above or any parameter in scope&#10; (and also to outputs of state refinements, see below).&#10; This gives the behavior of a Mealy machine, where&#10; outputs are produced by transitions rather than by states. Moore machine&#10; behavior is also achievable using state refinements that produce&#10; outputs (see FSMDirector documentation).&#10; Multiple output actions may be given by separating them with semicolons.&#10; Also, output actions may take the form of &lt;i&gt;d.p&lt;/i&gt; = &lt;i&gt;expression&lt;/i&gt;,&#10; where &lt;i&gt;d&lt;/i&gt; is the name of the destination state and &lt;i&gt;p&lt;/i&gt; is a&#10; parameter of the destination refinement.&#10;  &lt;p&gt;&#10; After a transition is taken, this actor calls fireAtCurrentTime()&#10; on its enclosing director. This ensures that if the destination&#10; state has an enabled transition, that transition will be taken&#10; at the same time (in the next superdense time index). It also&#10; supports continuous-time models, where the destination state&#10; refinement, if any, should produce an output at the next superdense&#10; time index.&#10; &lt;p&gt;&#10; A final state is a state that has its &lt;i&gt;isFinalState&lt;/i&gt; parameter&#10; set to true. When the actor reaches a final state, then the&#10; postfire method will return false, indicating that the actor does not&#10; wish to be fired again.&#10; &lt;p&gt;&#10; An FSMActor can be used in a modal model to represent the mode&#10; control logic.  In this case, the states and transitions have&#10; refinements, and this actor works in concert with the FSMDirector&#10; to execute those refinements. See the documentation for&#10; FSMDirector for details on how that works.&#10; &lt;p&gt;&#10; By default, this actor has a conservative causality interface,&#10; implemented by the &lt;a href=&quot;../../../../ptolemy/actor/util/DefaultCausalityInterface.xml&quot;&gt;ptolemy.actor.util.DefaultCausalityInterface&lt;/a&gt;, which declares&#10; that all outputs depend on all inputs. If, however, the enclosing&#10; director and all state refinement directors implement the&#10; strict actor semantics (as indicated by their&#10; implementsStrictActorSemantics() method), then the returned&#10; causality interface is&#10; implemented by the &lt;a href=&quot;../../../../ptolemy/domains/modal/kernel/FSMCausalityInterface.xml&quot;&gt;ptolemy.domains.modal.kernel.FSMCausalityInterface&lt;/a&gt; class. If&#10; the &lt;i&gt;stateDependentCausality&lt;/i&gt; is false (the default),&#10; then this causality interface in conservative and valid in all&#10; states. If it is true, then the causality interface will show&#10; different input/output dependencies depending on the state.&#10; See &lt;a href=&quot;../../../../ptolemy/domains/modal/kernel/FSMCausalityInterface.xml&quot;&gt;ptolemy.domains.modal.kernel.FSMCausalityInterface&lt;/a&gt; for details.  </description>
  <author>Edward A. Lee, Xiaojun Liu, Haiyang Zheng, Ye Zhou, Christian Motika</author>
  <version>$Id$</version>
  <since>Ptolemy II 8.0</since>
  <Pt.ProposedRating>Yellow (liuxj)</Pt.ProposedRating>
  <Pt.AcceptedRating>Yellow (kienhuis)</Pt.AcceptedRating>
    <!--ptolemy.data.expr.Parameter-->
    <property name="errorCause">Parameter containing the cause of an exception thrown&#10;  while executing a refinement if the exception is a&#10;  KernelException that specified a Nameable.&#10;  This parameter may be used in a guard&#10;  expression or output or set action to access the object&#10;  that originated an exception on an error transition.&#10;  This is an object token that defaults to null.&#10;  This parameter is not persistent. It will not be exported to MoML.</property>
    <!--ptolemy.data.expr.StringParameter-->
    <property name="errorClass">Parameter containing the name of the class of exception thrown&#10;  while executing a refinement. This parameter may be used in a guard&#10;  expression or output or set action to access the class of an&#10;  exception on an error transition.&#10;  This is a string that defaults to the empty string.&#10;  This parameter is not persistent. It will not be exported to MoML.</property>
    <!--ptolemy.data.expr.StringParameter-->
    <property name="errorMessage">Parameter containing the message of exception thrown&#10;  while executing a refinement. This parameter may be used in a guard&#10;  expression or output or set action to access the message of an&#10;  exception on an error transition.&#10;  This is a string that defaults to the empty string.&#10;  This parameter is not persistent. It will not be exported to MoML.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="probability">Parameter that is a function which evaluates to true&#10; when the randomly generated token value is within the probability&#10; range expressed by a transition.</property>
    <!--ptolemy.actor.parameters.SharedParameter-->
    <property name="resetOnEachRun">Boolean parameter to determine whether seeds are reset on each run.</property>
    <!--ptolemy.actor.parameters.SharedParameter-->
    <property name="seed">The seed to be used for random token generation, to evaluate&#10; probabilistic transitions between states.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="timeout">Parameter that is a function that evaluates to true when the&#10;  time elapsed in the current state equals the argument to the&#10;  function. This can be used in a guard to trigger a transition.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="stateDependentCausality">Indicate whether input/output dependencies can depend on the&#10;  state. By default, this is false (the default), indicating that a conservative&#10;  dependency is provided by the causality interface. Specifically,&#10;  if there is a dependency in any state, then the causality interface&#10;  indicates that there is a dependency. If this is true, then a less&#10;  conservative dependency is provided, indicating a dependency only&#10;  if there can be one in the current state.  If this is true, then&#10;  upon any state transition, this actor issues a change request, which&#10;  forces causality analysis to be redone. Note that this can be expensive.</property>
    <!--ptolemy.kernel.util.StringAttribute-->
    <property name="finalStateNames">Attribute specifying the names of the final states of this&#10;  actor. This attribute is kept for backward compatibility only,&#10;  and is set to expert visibility. To set the final states,&#10;  set the &lt;i&gt;isFinalState&lt;/i&gt; parameter of a States.</property>
    <!--ptolemy.kernel.util.StringAttribute-->
    <property name="initialStateName">Attribute specifying the name of the initial state of this&#10;  actor. This attribute is kept for backward compatibility only,&#10;  and is set to expert visibility. To set the initial state,&#10;  set the &lt;i&gt;isInitialState&lt;/i&gt; parameter of a State.</property>
</doc>
