<?xml version="1.0" standalone="yes"?>
<!DOCTYPE doc PUBLIC "-//UC Berkeley//DTD DocML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/DocML_1.dtd">
<doc name="FSMDirector" class="ptolemy.domains.modal.kernel.FSMDirector">
  <description>
An FSMDirector governs the execution of a modal model. A modal&#10; model is a TypedCompositeActor with a FSMDirector as local&#10; director. The mode control logic is captured by a mode controller,&#10; an instance of FSMActor contained by the composite actor. Each&#10; state of the mode controller represents a mode of operation and can&#10; be refined by an opaque CompositeActor contained by the same&#10; composite actor.&#10;&#10; &lt;p&gt; The mode controller contains a set of states and transitions. A&#10; transition has a &lt;i&gt;guard expression&lt;/i&gt;, any number of &lt;i&gt;output&#10; actions&lt;/i&gt;, and any number of &lt;i&gt;set actions&lt;/i&gt;. It has an&#10; &lt;i&gt;initial state&lt;/i&gt;, which is the unique state whose&#10; &lt;i&gt;isInitialState&lt;/i&gt; parameter is true.  The states and&#10; transitions can have &lt;i&gt;refinements&lt;/i&gt;, which are composite&#10; actors. In outline, a firing of this director is a sequence of&#10; steps:&lt;/p&gt;&#10;&#10; &lt;ol&gt;&#10; &lt;li&gt;Read inputs.&#10; &lt;li&gt;Evaluate the guards of preemptive transition out of the current state.&#10; &lt;li&gt;If no preemptive transition is enabled:&#10; &lt;ol&gt;&#10; &lt;li&gt;Fire the refinements of the current state (if any).&#10; &lt;li&gt;Evaluate guards on non-preemptive transitions out of the current state.&#10; &lt;/ol&gt;&#10; &lt;li&gt;Choose a transition whose guard is true.&#10; &lt;li&gt;Execute the output actions of the chosen transition.&#10; &lt;li&gt;Fire the transition refinements of the chosen transition.&#10; &lt;/ol&gt;&#10; &lt;p&gt;In postfire, the following steps are performed:&lt;/p&gt;&#10; &lt;ol&gt;&#10; &lt;li&gt;Postfire the refinements of the current state if they were fired.&#10; &lt;li&gt;Initialize the refinements of the destination state if the transition is a reset&#10; transition.&#10; &lt;li&gt;Execute the set actions of the chosen transition.&#10; &lt;li&gt;Postfire the transition refinements of the chosen transition.&#10; &lt;li&gt;Change the current state to the destination of the chosen transition.&#10; &lt;/ol&gt;&#10;&#10; &lt;p&gt;Since this director makes no persistent state changes in its fire()&#10; method, it conforms with the &lt;i&gt;actor abstract&#10; semantics&lt;/i&gt;. Assuming the state and transition refinements also&#10; conform, this director can be used inside any Ptolemy II actor&#10; model of computation. How it behaves in each domain, however, can&#10; be somewhat subtle, particularly with domains that have fixed-point&#10; semantics and when nondeterministic transitions are used. The&#10; details are given below.&lt;/p&gt;&#10;&#10; &lt;p&gt; When a modal model is fired, this director first transfers the&#10; input tokens from the outside domain to the mode controller and the&#10; refinement of its current state. The preemptive transitions from&#10; the current state of the mode controller are examined. If there is&#10; more than one transition enabled, and any of the enabled&#10; transitions is not marked nondeterministic, an exception is&#10; thrown. If there is exactly one preemptive transition enabled then&#10; it is chosen. The choice actions (outputActions) contained by the&#10; transition are executed. Any output token produced by the mode&#10; controller is transferred to both the output ports of the modal&#10; model and the input ports of the mode controller. Then the&#10; refinements associated with the enabled transition are&#10; executed. Any output token produced by the refinements is&#10; transferred to both the output ports of the modal model and the&#10; input ports of the mode controller. The refinements of the current&#10; state will not be fired.&lt;/p&gt;&#10;&#10; &lt;p&gt; If no preemptive transition is enabled, the refinements of the&#10; current state are fired. Any output token produced by the&#10; refinements is transferred to both the output ports of the modal&#10; model and the input ports of the mode controller. After this, the&#10; non-preemptive transitions from the current state of the mode&#10; controller are examined. If there is more than one transition&#10; enabled, and any of the enabled transitions is not marked&#10; nondeterministic, an exception is thrown. If there is exactly one&#10; non-preemptive transition enabled then it is chosen and the choice&#10; actions contained by the transition are executed. Any output token&#10; produced by the mode controller is transferred to the output ports&#10; of the modal model and the input ports of the mode&#10; controller. Then, the refinements of the enabled transition are&#10; executed. Any output token produced by the refinements is&#10; transferred to both the output ports of the modal model and the&#10; input ports of the mode controller.&lt;/p&gt;&#10;&#10; &lt;p&gt; In a firing, it is possible that the current state refinement&#10; produces an output, and a transition that is taken also produces an&#10; output on the same port. In this case, only the second of these&#10; outputs will appear on the output of the composite actor containing&#10; this director.  However, the first of these output values, the one&#10; produced by the refinement, may affect whether the transition is&#10; taken. That is, it can affect the guard. If in addition a&#10; transition refinement writes to the output, then that value will be&#10; produced, overwriting the value produced either by the state&#10; refinement or the output action on the transition.&lt;/p&gt;&#10;&#10; &lt;p&gt; At the end of one firing, the modal model transfers its outputs&#10; to the outside model. The mode controller does not change state&#10; during successive firings in one iteration of the top level in&#10; order to support upper level domains that iterate to a fixed&#10; point.&lt;/p&gt;&#10;&#10; &lt;p&gt; When the modal model is postfired, the chosen transition of the&#10; latest firing is committed. The commit actions contained by the&#10; transition are executed and the current state of the mode&#10; controller is set to the destination state of the transition.&lt;/p&gt;&#10;&#10; &lt;p&gt;FIXME: If a state has multiple refinements, they are fired in the order defined.&#10; If they write to the same output, then the &quot;last one wins.&quot; It will be its value&#10; produced. It might make more sense to require them to be consistent, giving something&#10; closer to SR semantics. The same argument could apply when both a refinement and&#10; a transition produce outputs.&lt;/p&gt;  </description>
  <author>Xiaojun Liu, Haiyang Zheng, Edward A. Lee, Christian Motika</author>
  <version>$Id$</version>
  <since>Ptolemy II 8.0</since>
  <Pt.ProposedRating>Yellow (hyzheng)</Pt.ProposedRating>
  <Pt.AcceptedRating>Red (hyzheng)</Pt.AcceptedRating>
    <!--ptolemy.kernel.util.StringAttribute-->
    <property name="controllerName">Attribute specifying the name of the mode controller in the&#10; container of this director. This director must have a mode&#10; controller that has the same container as this director,&#10; otherwise an IllegalActionException will be thrown when action&#10; methods of this director are called.</property>
</doc>
