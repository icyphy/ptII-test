<?xml version="1.0" standalone="yes"?>
<!DOCTYPE doc PUBLIC "-//UC Berkeley//DTD DocML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/DocML_1.dtd">
<doc name="DDFDirector" class="ptolemy.domains.ddf.kernel.DDFDirector">
  <description>
The dynamic dataflow (DDF) domain is a superset of the synchronous&#10; dataflow(SDF) and Boolean dataflow(BDF) domains. In the SDF domain,&#10; an actor consumes and produces a fixed number of tokens per firing.&#10; This static information makes possible compile-time scheduling. In the&#10; DDF domain, there are few constraints on the production and consumption&#10; behavior of actors, and the schedulers make no attempt to construct a&#10; compile-time schedule. Instead, each actor has a set of firing rules&#10; (patterns) and can be fired if one of them is satisfied, i.e., one&#10; particular firing pattern forms a prefix of sequences of unconsumed&#10; tokens at input ports. The canonical actors in the DDF domain include&#10; Select and Switch, which consume or produce tokens on different channels&#10; based on the token received from the control port. You can also use&#10; the two-channel versions BooleanSelect and BooleanSwitch.&#10; &lt;p&gt;&#10; The dynamic scheduler implemented in this director fires all enabled&#10; and non-deferrable actors once in a basic iteration. A deferrable&#10; actor is one that will not help one of the downstream actors become&#10; enabled because that downstream actor either already has enough tokens on&#10; the channel connecting those two actors or is waiting for tokens on&#10; another channel. If no actor fires so far, which means there is no&#10; enabled and non-deferrable actor, then among all enabled and deferrable&#10; actors, this director fires those which have the smallest maximum number&#10; of tokens on their output channels which satisfy the demand of destination&#10; actors. If still no actor fires, then there is no enabled actor. A user&#10; can treat several such basic iterations as a single iteration by adding&#10; a parameter with name &lt;i&gt;requiredFiringsPerIteration&lt;/i&gt; to an actor&#10; (which is often a sink actor or an actor directly connected to output port&#10; of the composite actor) and specifying the number of times this actor must&#10; be fired in a single iteration. If the value of the parameter&#10; &lt;i&gt;runUntilDeadlockInOneIteration&lt;/i&gt; is a BooleanToken with value true,&#10; one single iteration consists of repeating the basic iteration until&#10; deadlock is reached (thus overriding the previous definition of one&#10; iteration), which is the status of the model where all active&#10; actors under the control of this director are unable to fire because&#10; their firing rules are not satisfied. However, they may be able to fire&#10; again during next iteration when tokens are transferred in from an outside&#10; domain. Note &lt;i&gt;runUntilDeadlockInOneIteration&lt;/i&gt; can be set to true&#10; only when this director is not on the top level.&#10; &lt;p&gt;&#10; The algorithm implementing one basic iteration goes like this:&#10; &lt;pre&gt;&#10; E = set of enabled actors&#10; D = set of deferrable enabled actors&#10; &lt;/pre&gt;&#10; One basic(default) iteration consists of:&#10; &lt;pre&gt;&#10; if (E\D != empty set) {&#10; fire (E\D)&#10; } else if (D != empty set) {&#10; fire minimax(D)&#10; } else {&#10; declare deadlock&#10; }&#10; &lt;/pre&gt;&#10; The function &quot;minimax(D)&quot; returns a subset of D with the smallest&#10; maximum number of tokens on their output channels which satisfy the&#10; demand of destination actors.&#10; &lt;p&gt;&#10; Note that any SDF model can be run with a DDF Director. However, the&#10; notion of iteration is different. One could try to imitate the SDF&#10; iteration in the DDF domain by controlling the number of firings in one&#10; iteration for some actors, such as requiring a plotter to plot a fixed&#10; number of points in each iteration.&#10; &lt;p&gt;&#10; In the DDF domain, the firing rule of any actor is specified by the token&#10; consumption rates of its input ports. A general DDF actor could change&#10; the consumption rates of its input ports after each firing of this actor.&#10; For multiports, an array token could be used to specify different rates&#10; for different channels connected to the same multiport. Note that in SDF,&#10; all channels connected to the same multiport have the same rate.&#10; &lt;p&gt;&#10; Based on DDFSimpleSched in Ptolemy Classic, by Edward Lee.&#10; See E. A. Lee et al., &quot;The Almagest,&quot; documentation for Ptolemy Classic,&#10; Vol. 1, Chapter 7, 1997.  </description>
  <author>Gang Zhou</author>
  <version>$Id$</version>
  <since>Ptolemy II 4.1</since>
  <Pt.ProposedRating>Yellow (zgang)</Pt.ProposedRating>
  <Pt.AcceptedRating>Yellow (cxh)</Pt.AcceptedRating>
    <!--ptolemy.data.expr.Parameter-->
    <property name="iterations">A Parameter representing the number of times that postfire() may&#10;  be called before it returns false.  If the value is less than or&#10;  equal to zero, then the execution will never return false in&#10;  postfire(), and thus the execution can continue forever or until&#10;  the model is deadlocked.&#10;  The default value is an IntToken with the value zero.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="maximumReceiverCapacity">A Parameter representing the maximum capacity of each receiver&#10;  controlled by this director. This is an integer that defaults to 0,&#10;  which means the queue in each receiver is unbounded. To specify&#10;  bounded queues, set this to a positive integer.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="runUntilDeadlockInOneIteration">A parameter indicating whether one iteration consists of&#10;  repeated basic iterations until deadlock. If this parameter is&#10;  true, the model will be executed until deadlock in one iteration.&#10;  The default value is a BooleanToken with the value false. It&#10;  cannot be set to true if this director is at the top level.</property>
</doc>
