<?xml version="1.0" standalone="yes"?>
<!DOCTYPE doc PUBLIC "-//UC Berkeley//DTD DocML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/DocML_1.dtd">
<doc name="DEDirector" class="ptolemy.domains.de.kernel.DEDirector">
  <description>
&lt;p&gt;This director implements the discrete-event (DE) model of computation (MoC).&#10; It should be used as the local director of a CompositeActor that is&#10; to be executed according to the DE MoC. This director maintains a totally&#10; ordered set of events and processes these events in the order defined on&#10; their tags and depths.&#10; &lt;/p&gt;&lt;p&gt;&#10; An event is associated with a tag, which is a tuple of timestamp and&#10; microstep. A timestamp indicates the model time when this event occurs. It&#10; is an object of the &lt;a href=&quot;../../../../ptolemy/actor/util/Time.xml&quot;&gt;ptolemy.actor.util.Time&lt;/a&gt; class. A microstep is an&#10; integer which represents the index of the sequence of execution phases when&#10; this director processes events with the same timestamp. Two tags are equal&#10; if they have the same timestamp and microstep. If two events have the same&#10; tag, they are called simultaneous events.&#10; &lt;/p&gt;&lt;p&gt;&#10; Microsteps can only be increased by calling the fireAt() method. For example,&#10; when an actor requests to be fired again at the current model time, a&#10; new event with the same timestamp but a bigger microstep (incremented by 1)&#10; will be generated.&#10; &lt;/p&gt;&lt;p&gt;&#10; An event is also associated with a depth reflecting its priority, based&#10; on which a DE director chooses the execution order for simultaneous events.&#10; A depth is an integer and a larger value of depth indicates a lower priority.&#10; The depth of an event is determined by topologically sorting all the ports&#10; of actors according to their data dependencies over which there is no time&#10; delay.&#10; &lt;/p&gt;&lt;p&gt;&#10; The order of events is defined as follows. An event A is said to be earlier&#10; than another event B if A's timestamp is smaller than B's; or if A's&#10; timestamp is the same as B's, and A's microstep is smaller than B's; or if&#10; A's tag is the same as B's, and A's depth is smaller than B's. By giving&#10; events this well-defined order, this director can handle simultaneous events&#10; in a deterministic way.&#10; &lt;/p&gt;&lt;p&gt;&#10; The bottleneck in a typical DE simulator is in the maintenance of the&#10; global event queue. This director uses the calendar queue as the global&#10; event queue. This is an efficient algorithm with O(1) time complexity in&#10; both enqueue and dequeue operations. Sorting in the&#10; &lt;a href=&quot;../../../../ptolemy/actor/util/CalendarQueue.xml&quot;&gt;ptolemy.actor.util.CalendarQueue&lt;/a&gt; class is done according to the&#10; order defined above.&#10; &lt;/p&gt;&lt;p&gt;&#10; The complexity of the calendar algorithm is sensitive to the length of the&#10; event queue. When the size of the event queue becomes too long or changes&#10; very often, the simulation performance suffers from the penalties of queuing&#10; and dequeuing events. A few mechanisms are implemented to reduce such&#10; penalties by keeping the event queue short. The first mechanism is to only&#10; store in the event queue &lt;i&gt;pure&lt;/i&gt; events and the &lt;i&gt;trigger&lt;/i&gt; events&#10; with the same timestamp and microstep as those of the director. See&#10; &lt;a href=&quot;../../../../ptolemy/domains/de/kernel/DEEvent.xml&quot;&gt;ptolemy.domains.de.kernel.DEEvent&lt;/a&gt; for explanation of these two types of events. What is more,&#10; no duplicate trigger events are allowed in the event queue. Another mechanism&#10; is that in a hierarchical model, each level keeps a local event queue.&#10; A lower level only reports the earliest event to its upper level&#10; to schedule a future firing. The last mechanism is to maintain a list which&#10; records all actors that are disabled. Any triggers sent to the actors in&#10; this list are discarded.&#10; &lt;/p&gt;&lt;p&gt;&#10; In the initialize() method, depths of actors and IO ports are statically&#10; analyzed and calculated. They are not calculated in the preinitialize()&#10; method because hierarchical models may change their structures during their&#10; preinitialize() method. For example, a modal model does not specify its&#10; initial state (and its refinement) until the end of its preinitialize()&#10; method. See &lt;a href=&quot;../../../../ptolemy/domains/modal/kernel/FSMActor.xml&quot;&gt;ptolemy.domains.modal.kernel.FSMActor&lt;/a&gt;. In order to support&#10; mutation, this director recalculates the depths at the beginning of its next&#10; iteration.&#10; &lt;/p&gt;&lt;p&gt;&#10; There are two types of depths: one is associated with IO ports, which&#10; reflects the order of trigger events; the other one is associated with&#10; actors, which is for pure events. The relationship between the depths of IO&#10; ports and actors is that the depth of an actor is the smallest of the depths&#10; of its IO ports. Pure events can only be produced by calling the fireAt()&#10; method, and trigger events can only be produced by actors that produce&#10; outputs. See &lt;a href=&quot;../../../../ptolemy/domains/de/kernel/DEReceiver.html#put&quot;&gt;put(Token)&lt;/a&gt;.&#10; &lt;/p&gt;&lt;p&gt;&#10; Directed loops of IO ports with no delay will trigger an exception.&#10; These are called &lt;i&gt;causality loops&lt;/i&gt;. Such loops can be broken with&#10; actors whose output ports do not have an immediate dependence on their&#10; input ports, such as the &lt;i&gt;TimeDelay&lt;/i&gt; actor.  Notice that the&#10; &lt;i&gt;TimeDelay&lt;/i&gt; actor breaks a causality loop even if the time&#10; delay is set to 0.0. This is because DE uses a &lt;i&gt;superdense&lt;/i&gt;&#10; notion of time.  The output is interpreted as being strictly later&#10; than the input even though its time value is the same.&#10; Whether a causality loop exists is determined by the&#10; &lt;a href=&quot;../../../../ptolemy/actor/util/CausalityInterface.xml&quot;&gt;ptolemy.actor.util.CausalityInterface&lt;/a&gt; returned by each actor's&#10; getCausalityInterface() method.&#10; &lt;/p&gt;&lt;p&gt;&#10; An input port in a DE model contains an instance of DEReceiver.&#10; When a token is put into a DEReceiver, that receiver posts a trigger&#10; event to the director. This director sorts trigger events in a global event&#10; queue.&#10; &lt;/p&gt;&lt;p&gt;&#10; An iteration, in the DE domain, is defined as processing all the events&#10; whose tags are equal to the current tag of the director (also called the&#10; model tag). At the beginning of the fire() method, this director dequeues&#10; a subset of the earliest events (the ones with smallest timestamp, microstep,&#10; and depth) that have the same destination actor&#10; from the global event queue. Then, this director fires that actor.&#10; This actor must consume tokens from its input port(s),&#10; and usually produces new events on its output port(s). These new events will&#10; trigger the destination actors to fire. It is important that the actor&#10; actually consumes tokens from its inputs, even if the tokens are solely&#10; used to trigger reactions, because the actor will be fired repeatedly&#10; until there are no more tokens in its input ports with the same tag,&#10; or until the actor returns false in its prefire() method. The&#10; director then keeps dequeuing and processing the earliest events from the&#10; event queue until no more events have the same tag.&#10; &lt;/p&gt;&lt;p&gt;&#10; Note that each time this director fires an actor, it&#10; also invokes postfire() on that actor.&#10; Note that under this policy, it is possible for an actor to be fired and postfired&#10; multiple times in an iteration.&#10; This does not really correctly implement superdense time semantics, but it is&#10; an approximation that will reject some models that should be able to be executed.&#10; An actor like the TimeDelay will be fired (and postfired) multiple times&#10; at a superdense time index if it is in a feedback loop.&#10; &lt;/p&gt;&lt;p&gt;&#10; A model starts from the time specified by &lt;i&gt;startTime&lt;/i&gt;. This is blank&#10; by default, which indicates that the start time is the current time of&#10; the enclosing director, if there is one, and 0.0 otherwise.&#10; The stop time of the execution can be set&#10; using the &lt;i&gt;stopTime&lt;/i&gt; parameter. The parameter has a default value&#10; &lt;i&gt;Infinity&lt;/i&gt;, which means the execution runs forever.&#10; &lt;/p&gt;&lt;p&gt;&#10; Execution of a DE model ends when the timestamp of the earliest event&#10; exceeds the stop time. This stopping condition is checked inside&#10; the postfire() method of this director. By default, execution also ends&#10; when the global event queue becomes empty. Sometimes, the desired&#10; behaviour is for the director to wait on an empty queue until another&#10; thread makes new events available. For example, a DE actor may produce&#10; events when a user hits a button on the screen. To prevent ending the&#10; execution when there are no more events, set the&#10; &lt;i&gt;stopWhenQueueIsEmpty&lt;/i&gt; parameter to &lt;code&gt;false&lt;/code&gt;.&#10; &lt;/p&gt;&lt;p&gt;&#10; Parameters &lt;i&gt;isCQAdaptive&lt;/i&gt;, &lt;i&gt;minBinCount&lt;/i&gt;, and&#10; &lt;i&gt;binCountFactor&lt;/i&gt;, are used to configure the calendar queue.&#10; Changes to these parameters are ignored when the model is running.&#10; &lt;/p&gt;&lt;p&gt;&#10; If the parameter &lt;i&gt;synchronizeToRealTime&lt;/i&gt; is set to &lt;code&gt;true&lt;/code&gt;,&#10; then the director will not process events until the real time elapsed&#10; since the model started matches the timestamp of the event.&#10; This ensures that the director does not get ahead of real time. However,&#10; of course, this does not ensure that the director keeps up with real time.&#10; &lt;/p&gt;&lt;p&gt;&#10; This director tolerates changes to the model during execution.&#10; The change should be queued with a component in the hierarchy using&#10; requestChange().  While invoking those changes, the method&#10; invalidateSchedule() is expected to be called, notifying the director&#10; that the topology it used to calculate the priorities of the actors&#10; is no longer valid.  This will result in the priorities (depths of actors)&#10; being recalculated the next time prefire() is invoked.&#10; &lt;/p&gt;&lt;p&gt;&#10; &lt;b&gt;Limitations&lt;/b&gt;: According to [1], at each microstep, DE should&#10; perform a fixed point iteration. This implementation does not do that,&#10; and consequently, this director is not able to execute all correctly&#10; constructed DE models. For an example, see&#10; $PTII/ptolemy/domains/de/test/auto/DEFixedPointLimitation.xml.&#10; That example has a DE opaque composite actor in a feedback loop.&#10; In principle, there should be no causality loop. The actor output&#10; should be able to be produced without knowing the input. However,&#10; the inside director has to guarantee that when it fires any of&#10; its contained actors, all inputs of a given microstep are available&#10; to that actor. As a consequence, the opaque actor also needs to know&#10; all of its inputs at the current microstep. Hence, a causality loop&#10; is reported. We encourage the reader to make a variant of this director&#10; that can handle such models.&#10;  &lt;/p&gt;&lt;p&gt;&#10; &lt;b&gt;References&lt;/b&gt;:&#10; &lt;br&gt;&#10; [1] Lee, E. A. and H. Zheng (2007). Leveraging Synchronous Language&#10; Principles for Heterogeneous Modeling and Design of Embedded Systems.&#10; EMSOFT, Salzburg, Austria, October, ACM.  </description>
  <author>Lukito Muliadi, Edward A. Lee, Jie Liu, Haiyang Zheng</author>
  <version>$Id$</version>
  <since>Ptolemy II 0.2</since>
  <Pt.ProposedRating>Green (hyzheng)</Pt.ProposedRating>
  <Pt.AcceptedRating>Yellow (hyzheng)</Pt.AcceptedRating>
    <!--ptolemy.data.expr.Parameter-->
    <property name="binCountFactor">The factor when adjusting the bin number.&#10;  This parameter must contain an IntToken.&#10;  Changes to this parameter are ignored when the model is running.&#10;  The value defaults to 2.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="enforceMicrostepSemantics">A flag indicating whether this director should enforce&#10;  microstep semantics, throwing an exception when actors&#10;  deliver events at microstep 0. Such events can arise from&#10;  attempting to deliver to the DE domain a continuous signal&#10;  from the Continuous domain. This is a boolean that defaults&#10;  to false.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="isCQAdaptive">Specify whether the calendar queue adjusts its bin number&#10;  at run time. This parameter must contain a BooleanToken.&#10;  If this parameter is true, the calendar queue will adapt&#10;  its bin number with respect to the distribution of events.&#10;  Changes to this parameter are ignored when the model is running.&#10;  The value defaults to true.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="minBinCount">The minimum (initial) number of bins in the calendar queue.&#10;  This parameter must contain an IntToken.&#10;  Changes to this parameter are ignored when the model is running.&#10;  The value defaults to 2.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="stopWhenQueueIsEmpty">Specify whether the execution stops when the queue is empty.&#10;  This parameter must contain a&#10;  BooleanToken. If this parameter is true, the&#10;  execution of the model will be stopped when the queue is empty.&#10;  The value defaults to true.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="synchronizeToRealTime">Specify whether the execution should synchronize to the&#10;  real time. This parameter must contain a BooleanToken.&#10;  If this parameter is true, then do not process events until the&#10;  elapsed real time matches the time stamp of the events.&#10;  The value defaults to false.</property>
</doc>
