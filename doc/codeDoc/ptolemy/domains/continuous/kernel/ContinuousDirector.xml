<?xml version="1.0" standalone="yes"?>
<!DOCTYPE doc PUBLIC "-//UC Berkeley//DTD DocML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/DocML_1.dtd">
<doc name="ContinuousDirector" class="ptolemy.domains.continuous.kernel.ContinuousDirector">
  <description>
The continuous time domain is a timed domain that supports&#10; continuous-time signals, discrete-event signals, and mixtures of the&#10; two. There is a global notion of time that all the actors are aware of.&#10; The semantics of this domain is given in the following two papers:&#10; &lt;ul&gt;&#10; &lt;li&gt;&#10; Edward A. Lee and Haiyang Zheng, &quot;&lt;a href=&quot;http://ptolemy.eecs.berkeley.edu/publications/papers/05/OperationalSemantics/#in_browser&quot;&gt;Operational Semantics of Hybrid Systems&lt;/a&gt;,&quot;&#10; Invited paper in Proceedings of Hybrid Systems: Computation and Control&#10; (HSCC) LNCS 3414, Zurich, Switzerland, March 9-11, 2005.&lt;/li&gt;&#10; &lt;li&gt;&#10; Edward A. Lee, Haiyang Zheng, &quot;&lt;a href=&quot;http://ptolemy.eecs.berkeley.edu/publications/papers/07/unifying/index.htm#in_browser&quot;&gt;Leveraging Synchronous Language Principles for Heterogeneous Modeling and Design of Embedded Systems&lt;/a&gt;,&quot;&#10; EMSOFT 07, September 30-October 3, 2007, Salzburg, Austria.&lt;/li&gt;&#10; &lt;/ul&gt;&#10; &lt;p&gt;&#10; A signal is a set of &quot;events,&quot; each of which has a tag and value.&#10; The set of values includes a special element, called &quot;absent&quot;, denoting&#10; the absence of a (normal) value.&#10; This director uses superdense time, where every event has a tag&#10; that is a member of the set RxN.&#10; R is a connected subset of the real numbers (giving &quot;time&quot;,&#10; and approximated by instances of the Time class),&#10; and N is the natural numbers (giving an &quot;index&quot;).&#10; At a time &lt;i&gt;t&lt;/i&gt;, a signal&#10; may have multiple values in sequence with tags&#10; (&lt;i&gt;t&lt;/i&gt;, 0), (&lt;i&gt;t&lt;/i&gt;, 1)... Its &quot;initial value&quot; is the value&#10; at tag (&lt;i&gt;t&lt;/i&gt;, 0). It typically settles to&#10; a &quot;final value&quot; after a finite number of indices.&#10; If it fails to settle to a final value, the signal is said to&#10; have a &quot;stuttering Zeno&quot; condition, and time will not progress.&lt;/p&gt;&#10; &lt;p&gt;&#10; In our semantics, all signals are piecewise continuous.&#10; This means that the initial value, as a function of time,&#10; is continuous on the left, the final value, as a function&#10; of time, is continuous on the right, and the signal&#10; has exactly one value (meaning the initial value and the final value&#10; are the same) at all times except those&#10; on a discrete subset D.&lt;/p&gt;&#10; &lt;p&gt;&#10; A purely continuous signal has exactly one value at&#10; all times, meaning that the final value equals the initial&#10; value at all times.&#10; A purely discrete signal has&#10; initial value &quot;absent&quot; and final value &quot;absent&quot; at all&#10; times, and at a discrete subset of the times, it may&#10; have non-absent values. The only signal that is both&#10; purely continuous and purely discrete is the one that&#10; is absent at all tags.&lt;/p&gt;&#10; &lt;p&gt;&#10; A signal may be mostly continuous,&#10; but have multiple values at a discrete subset of times.&#10; These multiple values semantically represent discontinuities&#10; in a continuous signal that is not purely continuous.&lt;/p&gt;&#10; &lt;p&gt;&#10; The set of times where signals have more than one distinct value&#10; is a discrete subset D of the time line. These times are called&#10; &quot;breakpoints&quot; and are treated specially in the execution.&#10; Between these times, an ordinary differential equation (ODE)&#10; solver governs the execution. Initial values are always given&#10; by the ODE solver.&lt;/p&gt;&#10; &lt;p&gt;&#10; The parameters of this director are:&#10; &lt;ul&gt;&#10; &lt;li&gt; &lt;i&gt;startTime&lt;/i&gt;: The start time of the&#10; execution.&lt;/li&gt;&#10;&#10; &lt;li&gt; &lt;i&gt;stopTime&lt;/i&gt;: The stop time of the execution.&#10; When the current time reaches this value, postfire() will return false.&#10; This will occur whether or not this director is at the top level.&lt;/li&gt;&#10;&#10; &lt;li&gt; &lt;i&gt;initStepSize&lt;/i&gt;: The suggested integration step size.&#10; If the ODE solver is a fixed step size solver, then this parameter&#10; gives the step size taken. Otherwise, at the start of execution,&#10; this provides the first guess for the integration step size.&#10; In later iterations, the integrators provide the suggested step&#10; size. This is a double with default value 0.1&lt;/li&gt;&#10;&#10; &lt;li&gt; &lt;i&gt;maxStepSize&lt;/i&gt;: The maximum step size.&#10; This can be used to prevent the solver from too few&#10; samples of signals. That is, for certain models, it might&#10; be possible to get accurate results for very large step&#10; sizes, but plots of the signals may be misleading (even&#10; if they are accurate) because they represent the signal&#10; with only a few samples. The default value is 1.0.&lt;/li&gt;&#10;&#10; &lt;li&gt; &lt;i&gt;maxIterations&lt;/i&gt;:&#10; The maximum number of iterations that an&#10; ODE solver can use to resolve the states of integrators.&#10; Implicit solvers, for example, iterate until they converge,&#10; and this parameter bounds the number of iterations.&#10; An example of an implicit solver is the BackwardsEuler solver.&#10; The default value is 20, and the type is int.&#10; FIXME: Currently, this package implements no implicit solvers.&lt;/li&gt;&#10;&#10; &lt;li&gt; &lt;i&gt;ODESolver&lt;/i&gt;:&#10; The class name of the ODE solver used for integration.&#10; This is a string that defaults to &quot;ExplicitRK23Solver&quot;,&#10; a solver that tends to deliver smooth renditions of signals.&#10; The &quot;ExplicitRK45Solver&quot; may be more efficient in that it can&#10; use larger step sizes, but the resulting signals when displayed&#10; may be more jagged in appearance.&#10; Solvers are all required to be in package&#10; &quot;ptolemy.domains.continuous.kernel.solver&quot;.&#10; If there is another ContinuousDirector above this one&#10; in the hierarchy, then the value of this parameter is ignored and the&#10; solver given by the first ContinuousDirector above will be used.&lt;/li&gt;&#10;&#10; &lt;li&gt; &lt;i&gt;errorTolerance&lt;/i&gt;: This is the local truncation&#10; error tolerance, used for controlling the integration accuracy&#10; in variable step size ODE solvers, and also for determining whether&#10; unpredictable breakpoints have been accurately identified. Any actor&#10; that implements ContinuousStepSizeControl may use this error&#10; tolerance to determine whether the current step is accurate.&#10; For example, if the local truncation error&#10; in some integrator is greater than this tolerance, then the&#10; integration step is considered to have failed, and should be restarted with&#10; a reduced step size. The default value is 1e-4.&lt;/li&gt;&#10; &lt;/ul&gt;&#10; &lt;p&gt;&#10; This director maintains a breakpoint table to record all predictable&#10; breakpoints that are greater than or equal to&#10; the current time. The breakpoints are sorted in chronological order.&#10; Breakpoints at the same time are considered to be identical, and the&#10; breakpoint table does not contain duplicate time points. A breakpoint can&#10; be inserted into the table by calling the fireAt() method. The fireAt method&#10; may be requested by the director, which inserts the stop time of the&#10; execution. The fireAt method may also be requested by actors and the&#10; requested firing time will be inserted into the breakpoint table.&lt;/p&gt;&#10; &lt;p&gt;&#10; This director is designed to work with any other director that&#10; implements the strict actor semantics. As long as the other director does&#10; not commit state changes except in postfire(), that director&#10; can be used within the model controlled by&#10; this director. If, in addition to implementing the strict&#10; actor semantics that other director also respects calls to&#10; fireAt(), then this director may be used within a model&#10; governed by that director.&lt;/p&gt;&#10; &lt;p&gt;&#10; This director is based on the CTDirector by Jie Liu and Haiyang Zheng,&#10; but it has a much simpler scheduler and a fixed-point semantics.&lt;/p&gt;  </description>
  <author>Haiyang Zheng and Edward A. Lee, based on CTDirector by Jie Liu and Haiyang Zheng</author>
  <version>$Id$</version>
  <since>Ptolemy II 6.0</since>
  <Pt.ProposedRating>Yellow (hyzheng)</Pt.ProposedRating>
  <Pt.AcceptedRating>Red (hyzheng)</Pt.AcceptedRating>
    <!--ptolemy.data.expr.Parameter-->
    <property name="errorTolerance">Error tolerance for data values, used with variable step&#10;  size solvers to determine whether the current step size is accurate.&#10;  The default value is 1e-4, and the type is double.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="initStepSize">User's hint for the initial integration step size.&#10;  The default value is 0.1, and the type is double.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="maxIterations">The maximum number of rounds that an&#10;  ODE solver can use to resolve the states of integrators.&#10;  Many solvers, such as RK 2-3 and RK 4-5, use a fixed number&#10;  of rounds (3 and 6, respectively). Implicit ODE solvers use&#10;  however many rounds it takes to converge to a solution within&#10;  a specified accuracy (given by &lt;i&gt;errorTolerance&lt;/i&gt;).&#10;  An example of an implicit solver is the BackwardsEuler solver.&#10;  This parameter limits the number of rounds.&#10;  The default value is 20, and the type is int.</property>
    <!--ptolemy.data.expr.Parameter-->
    <property name="maxStepSize">The maximum step size.&#10;  The default value is 1.0, and the type is double.</property>
    <!--ptolemy.data.expr.StringParameter-->
    <property name="ODESolver">The class name of the ODE solver used for integration.&#10;  This is a string that defaults to &quot;ExplicitRK23Solver&quot;.&#10;  Solvers are all required to be in package&#10;  &quot;ptolemy.domains.continuous.kernel.solver&quot;.&#10;  If a solver is changed during execution, the&#10;  change does not take effect until the next execution&#10;  of the model.&#10;  If there is another ContinuousDirector above this one&#10;  in the hierarchy, separated possibly by MultiComposite,&#10;  then the value of this parameter is ignored and the&#10;  solver given by the other ContinuousDirector will be used.</property>
</doc>
