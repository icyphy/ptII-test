<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>SignalProcessing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../jquery/jquery-3.3.1.js"></script>
<script type="text/javascript" src="../../jquery/jquery-migrate-3.0.1.js"></script>
<script type="text/javascript" src="../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="SignalProcessing";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":41,"i7":41,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":9,"i31":9,"i32":9,"i33":9,"i34":9,"i35":9,"i36":9,"i37":9,"i38":9,"i39":9,"i40":9,"i41":9,"i42":9,"i43":9,"i44":9,"i45":9,"i46":9,"i47":9,"i48":9,"i49":9,"i50":9,"i51":9,"i52":9,"i53":9,"i54":9,"i55":9,"i56":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">ptolemy.math</a></div>
<h2 title="Class SignalProcessing" class="title">Class SignalProcessing</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>ptolemy.math.SignalProcessing</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">SignalProcessing</span>
extends java.lang.Object</pre>
<div class="block">This class provides signal processing functions.

 The algorithms for the FFT and DCT are based on the FFCT algorithm
 described in:

 Martin Vetterli and Henri J. Nussbaumer."Simple FFT and DCT Algorithms with
 Reduced Number of Operations". Signal Processing 6 (1984) 267-278.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Ptolemy II 0.2</dd>
<dt><span class="simpleTagLabel">Version:</span></dt>
<dd>$Id$</dd>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>Albert Chen, William Wu, Edward A. Lee, Jeff Tsay, Elaine Cheong</dd>
<dt><span class="simpleTagLabel">Pt.AcceptedRating:</span></dt>
<dd>Red (cxh)</dd>
<dt><span class="simpleTagLabel">Pt.ProposedRating:</span></dt>
<dd>Yellow (ctsay)</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="SignalProcessing.GaussianSampleGenerator.html" title="class in ptolemy.math">SignalProcessing.GaussianSampleGenerator</a></span></code></th>
<td class="colLast">
<div class="block">This class generates samples of a Gaussian function with the
  specified mean and standard deviation.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="SignalProcessing.PolynomialSampleGenerator.html" title="class in ptolemy.math">SignalProcessing.PolynomialSampleGenerator</a></span></code></th>
<td class="colLast">
<div class="block">This class generates samples of a polynomial.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="SignalProcessing.RaisedCosineSampleGenerator.html" title="class in ptolemy.math">SignalProcessing.RaisedCosineSampleGenerator</a></span></code></th>
<td class="colLast">
<div class="block">This class generates samples of a raised cosine pulse, or if the
  excess is zero, a modified sinc function.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="SignalProcessing.SawtoothSampleGenerator.html" title="class in ptolemy.math">SignalProcessing.SawtoothSampleGenerator</a></span></code></th>
<td class="colLast">
<div class="block">This class generates samples of a sawtooth wave with the specified
  period and phase.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="SignalProcessing.SincSampleGenerator.html" title="class in ptolemy.math">SignalProcessing.SincSampleGenerator</a></span></code></th>
<td class="colLast">
<div class="block">This class generates samples of a sinc wave with the specified
  first zero crossing.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="SignalProcessing.SinusoidSampleGenerator.html" title="class in ptolemy.math">SignalProcessing.SinusoidSampleGenerator</a></span></code></th>
<td class="colLast">
<div class="block">This class generates samples of a sinusoidal wave.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="SignalProcessing.SqrtRaisedCosineSampleGenerator.html" title="class in ptolemy.math">SignalProcessing.SqrtRaisedCosineSampleGenerator</a></span></code></th>
<td class="colLast">
<div class="block">This class generates samples of a square-root raised cosine pulse.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- =========== FIELD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#DCT_TYPE_NORMALIZED">DCT_TYPE_NORMALIZED</a></span></code></th>
<td class="colLast">
<div class="block">To select the forward transform :</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#DCT_TYPE_ORTHONORMAL">DCT_TYPE_ORTHONORMAL</a></span></code></th>
<td class="colLast">
<div class="block">To select the forward transform :
                         N - 1
   X[k] = sqrt(2/N) e[k]  sum  x[n] * cos ((2n + 1)k * PI / 2N)
                         n = 0
  and the inverse transform :
                   N - 1
   x[n] = sqrt(2/N) sum  e[k] X[k] * cos ((2n + 1)k * PI / 2N)
                   k = 0
  use this DCT type.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#DCT_TYPE_UNNORMALIZED">DCT_TYPE_UNNORMALIZED</a></span></code></th>
<td class="colLast">
<div class="block">To select the forward transform :
         N - 1
   X[k] = sum  x[n] * cos ((2n + 1)k * PI / 2N)
         n = 0
  and the inverse transform :
         N - 1
   x[n] = sum  X[k] * cos ((2n + 1)k * PI / 2N)
         k = 0
  use this DCT type.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#DCT_TYPES">DCT_TYPES</a></span></code></th>
<td class="colLast">
<div class="block">The number of DCT types supported.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#EPSILON">EPSILON</a></span></code></th>
<td class="colLast">
<div class="block">A small number ( = 1.0e-9).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#WINDOW_TYPE_BARTLETT">WINDOW_TYPE_BARTLETT</a></span></code></th>
<td class="colLast">
<div class="block">To select the Bartlett (triangular) window,</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#WINDOW_TYPE_BLACKMAN">WINDOW_TYPE_BLACKMAN</a></span></code></th>
<td class="colLast">
<div class="block">To select the Blackman window,</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#WINDOW_TYPE_BLACKMAN_HARRIS">WINDOW_TYPE_BLACKMAN_HARRIS</a></span></code></th>
<td class="colLast">
<div class="block">To select the 4-term Blackman-Harris window,</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#WINDOW_TYPE_HAMMING">WINDOW_TYPE_HAMMING</a></span></code></th>
<td class="colLast">
<div class="block">To select the Hamming window,</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#WINDOW_TYPE_HANNING">WINDOW_TYPE_HANNING</a></span></code></th>
<td class="colLast">
<div class="block">To select the Hanning window,</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#WINDOW_TYPE_RECTANGULAR">WINDOW_TYPE_RECTANGULAR</a></span></code></th>
<td class="colLast">
<div class="block">To select the rectangular window,</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#WINDOW_TYPES">WINDOW_TYPES</a></span></code></th>
<td class="colLast">
<div class="block">The number of window types that can be generated.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#close(double,double)">close</a></span>&#8203;(double&nbsp;first,
     double&nbsp;second)</code></th>
<td class="colLast">
<div class="block">Return true if the first argument is close to the second (within
  EPSILON, where EPSILON is a static public variable of this class).</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#convolve(double%5B%5D,double%5B%5D)">convolve</a></span>&#8203;(double[]&nbsp;array1,
        double[]&nbsp;array2)</code></th>
<td class="colLast">
<div class="block">Return a new array that is the convolution of the two argument arrays.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static <a href="Complex.html" title="class in ptolemy.math">Complex</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#convolve(ptolemy.math.Complex%5B%5D,ptolemy.math.Complex%5B%5D)">convolve</a></span>&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;array1,
        <a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;array2)</code></th>
<td class="colLast">
<div class="block">Return a new array that is the convolution of two complex arrays.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#DCT(double%5B%5D)">DCT</a></span>&#8203;(double[]&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Return a new array of doubles that is the forward, normalized
  DCT of the input array of doubles.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#DCT(double%5B%5D,int)">DCT</a></span>&#8203;(double[]&nbsp;x,
   int&nbsp;order)</code></th>
<td class="colLast">
<div class="block">Return a new array of doubles that is the forward, normalized
  DCT of the input array of doubles.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#DCT(double%5B%5D,int,int)">DCT</a></span>&#8203;(double[]&nbsp;x,
   int&nbsp;order,
   int&nbsp;type)</code></th>
<td class="colLast">
<div class="block">Return a new array of doubles that is the forward DCT of the
  input array of doubles.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#decibel(double)">decibel</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use toDecibels() instead.</div>
</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#decibel(double%5B%5D)">decibel</a></span>&#8203;(double[]&nbsp;values)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use toDecibels() instead.</div>
</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#downsample(double%5B%5D,int)">downsample</a></span>&#8203;(double[]&nbsp;x,
          int&nbsp;n)</code></th>
<td class="colLast">
<div class="block">Return a new array that is formed by taking every nth sample
  starting with the 0th sample, and discarding the rest.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#downsample(double%5B%5D,int,int)">downsample</a></span>&#8203;(double[]&nbsp;x,
          int&nbsp;n,
          int&nbsp;startIndex)</code></th>
<td class="colLast">
<div class="block">Return a new array that is formed by taking every nth sample
  starting at startIndex, and discarding the samples in between.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static <a href="Complex.html" title="class in ptolemy.math">Complex</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#FFT(ptolemy.math.Complex%5B%5D)">FFT</a></span>&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Return a new array of complex numbers which is the FFT
  of an input array of complex numbers.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static <a href="Complex.html" title="class in ptolemy.math">Complex</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#FFT(ptolemy.math.Complex%5B%5D,int)">FFT</a></span>&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x,
   int&nbsp;order)</code></th>
<td class="colLast">
<div class="block">Return a new array of complex numbers which is the FFT
  of an input array of complex numbers.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static <a href="Complex.html" title="class in ptolemy.math">Complex</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#FFTComplexOut(double%5B%5D)">FFTComplexOut</a></span>&#8203;(double[]&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Return a new array of Complex's which is the forward FFT
  of a real input array of doubles.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static <a href="Complex.html" title="class in ptolemy.math">Complex</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#FFTComplexOut(double%5B%5D,int)">FFTComplexOut</a></span>&#8203;(double[]&nbsp;x,
             int&nbsp;order)</code></th>
<td class="colLast">
<div class="block">Return a new array of Complex's which is the forward FFT
  of a real input array of doubles.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static <a href="Complex.html" title="class in ptolemy.math">Complex</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#FFTComplexOut(ptolemy.math.Complex%5B%5D)">FFTComplexOut</a></span>&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Return a new array of Complex's which is the forward FFT
  of an input array of Complex's.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static <a href="Complex.html" title="class in ptolemy.math">Complex</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#FFTComplexOut(ptolemy.math.Complex%5B%5D,int)">FFTComplexOut</a></span>&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x,
             int&nbsp;order)</code></th>
<td class="colLast">
<div class="block">Return a new array of Complex's which is the forward FFT
  of an input array of Complex's.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#FFTImagOut(double%5B%5D)">FFTImagOut</a></span>&#8203;(double[]&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Return a new array of doubles that is the imaginary part of the FFT
  of the real input array of doubles.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#FFTImagOut(double%5B%5D,int)">FFTImagOut</a></span>&#8203;(double[]&nbsp;x,
          int&nbsp;order)</code></th>
<td class="colLast">
<div class="block">Return a new array of doubles that is the imaginary part of the FFT
  of the real input array of doubles.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#FFTImagOut(ptolemy.math.Complex%5B%5D)">FFTImagOut</a></span>&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Return a new array of doubles which is the imaginary part of the
  FFT of an input array of Complex's.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#FFTImagOut(ptolemy.math.Complex%5B%5D,int)">FFTImagOut</a></span>&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x,
          int&nbsp;order)</code></th>
<td class="colLast">
<div class="block">Return a new array of doubles which is the imaginary part of the
  FFT of an input array of Complex's.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#FFTRealOut(double%5B%5D)">FFTRealOut</a></span>&#8203;(double[]&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Return a new array of doubles that is the real part of the FFT of
  the real input array of doubles.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#FFTRealOut(double%5B%5D,int)">FFTRealOut</a></span>&#8203;(double[]&nbsp;x,
          int&nbsp;order)</code></th>
<td class="colLast">
<div class="block">Return a new array of doubles that is the real part of the FFT of
  the real input array of doubles.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#FFTRealOut(ptolemy.math.Complex%5B%5D)">FFTRealOut</a></span>&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Return a new array of doubles which is the real part of the
  forward FFT of an input array of Complex's.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#FFTRealOut(ptolemy.math.Complex%5B%5D,int)">FFTRealOut</a></span>&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x,
          int&nbsp;order)</code></th>
<td class="colLast">
<div class="block">Return a new array of doubles which is the real part of the
  forward FFT of an input array of Complex's.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#generateBartlettWindow(int)">generateBartlettWindow</a></span>&#8203;(int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Return a new array that is filled with samples of a Bartlett
  window of a specified length.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#generateBlackmanHarrisWindow(int)">generateBlackmanHarrisWindow</a></span>&#8203;(int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Return a new array that is filled with samples of a Blackman Harris
  window of a specified length.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#generateBlackmanWindow(int)">generateBlackmanWindow</a></span>&#8203;(int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Return a new array that is filled with samples of a Blackman
  window of a specified length.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#generateGaussianCurve(double,double,int)">generateGaussianCurve</a></span>&#8203;(double&nbsp;standardDeviation,
                     double&nbsp;extent,
                     int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Return an array with samples the Gaussian curve (the "bell curve").</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#generateHammingWindow(int)">generateHammingWindow</a></span>&#8203;(int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Return a new array that is filled with samples of a Hamming
  window of a specified length.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#generateHanningWindow(int)">generateHanningWindow</a></span>&#8203;(int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Return a new array that is filled with samples of a Hanning
  window of a specified length.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#generatePolynomialCurve(double%5B%5D,double,double,int)">generatePolynomialCurve</a></span>&#8203;(double[]&nbsp;polynomial,
                       double&nbsp;start,
                       double&nbsp;step,
                       int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Return an array with samples a polynomial curve.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#generateRaisedCosinePulse(double,double,int)">generateRaisedCosinePulse</a></span>&#8203;(double&nbsp;excessBandwidth,
                         double&nbsp;firstZeroCrossing,
                         int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Return an array containing a symmetric raised-cosine pulse.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#generateRectangularWindow(int)">generateRectangularWindow</a></span>&#8203;(int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Return a new array that is filled with samples of a rectangular
  window of a specified length.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#generateSqrtRaisedCosinePulse(double,double,int)">generateSqrtRaisedCosinePulse</a></span>&#8203;(double&nbsp;excessBandwidth,
                             double&nbsp;firstZeroCrossing,
                             int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Return an array containing a symmetric raised-cosine pulse.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#generateWindow(int,int)">generateWindow</a></span>&#8203;(int&nbsp;length,
              int&nbsp;windowType)</code></th>
<td class="colLast">
<div class="block">Return a new array that is filled with samples of a window of a
  specified length and type.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#IDCT(double%5B%5D)">IDCT</a></span>&#8203;(double[]&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Return a new array of doubles that is the inverse, normalized
  DCT of the input array of doubles.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#IDCT(double%5B%5D,int)">IDCT</a></span>&#8203;(double[]&nbsp;x,
    int&nbsp;order)</code></th>
<td class="colLast">
<div class="block">Return a new array of doubles that is the inverse, normalized
  DCT of the input array of doubles, using the specified order.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#IDCT(double%5B%5D,int,int)">IDCT</a></span>&#8203;(double[]&nbsp;x,
    int&nbsp;order,
    int&nbsp;type)</code></th>
<td class="colLast">
<div class="block">Return a new array of doubles that is the inverse DCT of the
  input array of doubles.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>static <a href="Complex.html" title="class in ptolemy.math">Complex</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#IFFT(ptolemy.math.Complex%5B%5D)">IFFT</a></span>&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Return a new array of complex numbers which is the inverse FFT
  of an input array of complex numbers.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>static <a href="Complex.html" title="class in ptolemy.math">Complex</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#IFFT(ptolemy.math.Complex%5B%5D,int)">IFFT</a></span>&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x,
    int&nbsp;order)</code></th>
<td class="colLast">
<div class="block">Return a new array of complex numbers which is the inverse FFT
  of an input array of complex numbers.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>static <a href="Complex.html" title="class in ptolemy.math">Complex</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#IFFTComplexOut(ptolemy.math.Complex%5B%5D)">IFFTComplexOut</a></span>&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Return a new array of Complex's which is the inverse FFT
  of an input array of Complex's.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>static <a href="Complex.html" title="class in ptolemy.math">Complex</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#IFFTComplexOut(ptolemy.math.Complex%5B%5D,int)">IFFTComplexOut</a></span>&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x,
              int&nbsp;order)</code></th>
<td class="colLast">
<div class="block">Return a new array of Complex's which is the forward FFT
  of an input array of Complex's.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#IFFTRealOut(double%5B%5D)">IFFTRealOut</a></span>&#8203;(double[]&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Return a new array of doubles which is the real part of the inverse
  FFT of an input array of doubles.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#IFFTRealOut(double%5B%5D,int)">IFFTRealOut</a></span>&#8203;(double[]&nbsp;x,
           int&nbsp;order)</code></th>
<td class="colLast">
<div class="block">Return a new array of doubles which is the real part of the inverse
  FFT of an input array of doubles.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#IFFTRealOut(ptolemy.math.Complex%5B%5D)">IFFTRealOut</a></span>&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Return a new array of doubles which is the real part of the inverse
  FFT of an input array of Complex's.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#IFFTRealOut(ptolemy.math.Complex%5B%5D,int)">IFFTRealOut</a></span>&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x,
           int&nbsp;order)</code></th>
<td class="colLast">
<div class="block">Return a new array of doubles which is the real part of the inverse
  FFT of an input array of Complex's.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#nextPowerOfTwo(double)">nextPowerOfTwo</a></span>&#8203;(double&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Return the next power of two larger than the argument.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#order(int)">order</a></span>&#8203;(int&nbsp;size)</code></th>
<td class="colLast">
<div class="block">Return the "order" of a transform size, i.e.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>static <a href="Complex.html" title="class in ptolemy.math">Complex</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#poleZeroToFrequency(ptolemy.math.Complex%5B%5D,ptolemy.math.Complex%5B%5D,ptolemy.math.Complex,int)">poleZeroToFrequency</a></span>&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;poles,
                   <a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;zeros,
                   <a href="Complex.html" title="class in ptolemy.math">Complex</a>&nbsp;gain,
                   int&nbsp;numSteps)</code></th>
<td class="colLast">
<div class="block">Given an array of pole locations, an array of zero locations, and a
  gain term, return frequency response specified by these.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sampleWave(int,double,double,ptolemy.math.DoubleUnaryOperation)">sampleWave</a></span>&#8203;(int&nbsp;length,
          double&nbsp;startTime,
          double&nbsp;interval,
          <a href="DoubleUnaryOperation.html" title="interface in ptolemy.math">DoubleUnaryOperation</a>&nbsp;sampleGen)</code></th>
<td class="colLast">
<div class="block">Return a new array that is filled with samples of a waveform of a
  specified length.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sawtooth(double,double,double)">sawtooth</a></span>&#8203;(double&nbsp;period,
        double&nbsp;phase,
        double&nbsp;time)</code></th>
<td class="colLast">
<div class="block">Return a sample of a sawtooth wave with the specified period and
  phase at the specified time.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sinc(double)">sinc</a></span>&#8203;(double&nbsp;x)</code></th>
<td class="colLast">
<div class="block">Return sin(x)/x, the so-called sinc function.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#square(double,double,double)">square</a></span>&#8203;(double&nbsp;period,
      double&nbsp;phase,
      double&nbsp;time)</code></th>
<td class="colLast">
<div class="block">Return a sample of a square wave with the specified period and
  phase at the specified time.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toDecibels(double)">toDecibels</a></span>&#8203;(double&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Return the value of the argument
  in decibels, which is defined to be 20*log<sub>10</sub>(<em>z</em>),
  where <em>z</em> is the argument.</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#triangle(double,double,double)">triangle</a></span>&#8203;(double&nbsp;period,
        double&nbsp;phase,
        double&nbsp;time)</code></th>
<td class="colLast">
<div class="block">Return a sample of a triangle wave with the specified period and
  phase at the specified time.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#unwrap(double%5B%5D)">unwrap</a></span>&#8203;(double[]&nbsp;angles)</code></th>
<td class="colLast">
<div class="block">Return a new array that is constructed from the specified
  array by unwrapping the angles.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#upsample(double%5B%5D,int)">upsample</a></span>&#8203;(double[]&nbsp;x,
        int&nbsp;n)</code></th>
<td class="colLast">
<div class="block">Return a new array that is the result of inserting (n-1) zeroes
  between each successive sample in the input array, resulting in an
  array of length n * L, where L is the length of the original array.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a id="EPSILON">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>EPSILON</h4>
<pre>public static final&nbsp;double EPSILON</pre>
<div class="block">A small number ( = 1.0e-9). This number is used by algorithms to
  detect whether a double is close to zero.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#ptolemy.math.SignalProcessing.EPSILON">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="DCT_TYPE_NORMALIZED">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DCT_TYPE_NORMALIZED</h4>
<pre>public static final&nbsp;int DCT_TYPE_NORMALIZED</pre>
<div class="block">To select the forward transform :
  <p>
               N - 1 <br>
   X[k] = e[k]  sum  x[n] * cos ((2n + 1)k * PI / 2N) <br>
               n = 0 <br>
  </p>
  <p>
  and the inverse transform :
              N - 1 <br>
   x(n) = (2/N) sum  e(k) X[k] * cos ((2n + 1)k * PI / 2N)<br>
              k = 0 <br>
  </p>
  use this DCT type.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#ptolemy.math.SignalProcessing.DCT_TYPE_NORMALIZED">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="DCT_TYPE_UNNORMALIZED">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DCT_TYPE_UNNORMALIZED</h4>
<pre>public static final&nbsp;int DCT_TYPE_UNNORMALIZED</pre>
<div class="block">To select the forward transform :
         N - 1
   X[k] = sum  x[n] * cos ((2n + 1)k * PI / 2N)
         n = 0
  and the inverse transform :
         N - 1
   x[n] = sum  X[k] * cos ((2n + 1)k * PI / 2N)
         k = 0
  use this DCT type.
  This is the definition of the DCT used by MPEG.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#ptolemy.math.SignalProcessing.DCT_TYPE_UNNORMALIZED">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="DCT_TYPE_ORTHONORMAL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DCT_TYPE_ORTHONORMAL</h4>
<pre>public static final&nbsp;int DCT_TYPE_ORTHONORMAL</pre>
<div class="block">To select the forward transform :
                         N - 1
   X[k] = sqrt(2/N) e[k]  sum  x[n] * cos ((2n + 1)k * PI / 2N)
                         n = 0
  and the inverse transform :
                   N - 1
   x[n] = sqrt(2/N) sum  e[k] X[k] * cos ((2n + 1)k * PI / 2N)
                   k = 0
  use this DCT type.
  This is the definition of the DCT used in Matlab.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#ptolemy.math.SignalProcessing.DCT_TYPE_ORTHONORMAL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="DCT_TYPES">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DCT_TYPES</h4>
<pre>public static final&nbsp;int DCT_TYPES</pre>
<div class="block">The number of DCT types supported.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#ptolemy.math.SignalProcessing.DCT_TYPES">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="WINDOW_TYPE_RECTANGULAR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>WINDOW_TYPE_RECTANGULAR</h4>
<pre>public static final&nbsp;int WINDOW_TYPE_RECTANGULAR</pre>
<div class="block">To select the rectangular window,
  <p>
   w[n] = 1 for 0 &le; n &le; M
  </p>
  use this window type.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#ptolemy.math.SignalProcessing.WINDOW_TYPE_RECTANGULAR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="WINDOW_TYPE_BARTLETT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>WINDOW_TYPE_BARTLETT</h4>
<pre>public static final&nbsp;int WINDOW_TYPE_BARTLETT</pre>
<div class="block">To select the Bartlett (triangular) window,
  <p>
   w[n] = 2n/M      for 0 &le; n &le; M/2 <br>
   w[n] = 2 - 2n/M  for M/2 &lt; n &le; M
  </p>
  use this window type.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#ptolemy.math.SignalProcessing.WINDOW_TYPE_BARTLETT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="WINDOW_TYPE_HANNING">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>WINDOW_TYPE_HANNING</h4>
<pre>public static final&nbsp;int WINDOW_TYPE_HANNING</pre>
<div class="block">To select the Hanning window,
  <p>
   w[n] = 0.5 - 0.5 cos(2 * PI * n / M)  <br>
   for 0 &le; n &le; M
  </p>
  use this window type.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#ptolemy.math.SignalProcessing.WINDOW_TYPE_HANNING">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="WINDOW_TYPE_HAMMING">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>WINDOW_TYPE_HAMMING</h4>
<pre>public static final&nbsp;int WINDOW_TYPE_HAMMING</pre>
<div class="block">To select the Hamming window,
  <p>
   w[n] = 0.54 - 0.46 cos(2 * PI * n / M) <br>
   for 0 &le; n &le; M
  </p>
  use this window type.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#ptolemy.math.SignalProcessing.WINDOW_TYPE_HAMMING">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="WINDOW_TYPE_BLACKMAN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>WINDOW_TYPE_BLACKMAN</h4>
<pre>public static final&nbsp;int WINDOW_TYPE_BLACKMAN</pre>
<div class="block">To select the Blackman window,
  <p>
   w[n] = 0.42 - 0.5 cos(2 * PI * n /M)  + <br>
          0.08 cos (4 * PI * n / M) <br>
   for 0 &le; n &le; M
  </p>
  use this window type.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#ptolemy.math.SignalProcessing.WINDOW_TYPE_BLACKMAN">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="WINDOW_TYPE_BLACKMAN_HARRIS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>WINDOW_TYPE_BLACKMAN_HARRIS</h4>
<pre>public static final&nbsp;int WINDOW_TYPE_BLACKMAN_HARRIS</pre>
<div class="block">To select the 4-term Blackman-Harris window,
  <p>
   w[n] = 0.35875 - 0.48829 cos(2 * PI * n /M)  + <br>
          0.14128 cos (4 * PI * n / M) - 0.01168 cos(6 * PI * n / M) <br>
   for 0 &le; n &le; M
  </p>
  use this window type.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#ptolemy.math.SignalProcessing.WINDOW_TYPE_BLACKMAN_HARRIS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="WINDOW_TYPES">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>WINDOW_TYPES</h4>
<pre>public static final&nbsp;int WINDOW_TYPES</pre>
<div class="block">The number of window types that can be generated.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#ptolemy.math.SignalProcessing.WINDOW_TYPES">Constant Field Values</a></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="close(double,double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>close</h4>
<pre class="methodSignature">public static final&nbsp;boolean&nbsp;close&#8203;(double&nbsp;first,
                                  double&nbsp;second)</pre>
<div class="block">Return true if the first argument is close to the second (within
  EPSILON, where EPSILON is a static public variable of this class).</div>
</li>
</ul>
<a id="convolve(double[],double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convolve</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;convolve&#8203;(double[]&nbsp;array1,
                                      double[]&nbsp;array2)</pre>
<div class="block">Return a new array that is the convolution of the two argument arrays.
  The length of the new array is equal to the sum of the lengths of the
  two argument arrays minus one.  Note that convolution is the same
  as polynomial multiplication.  If the two argument arrays represent
  the coefficients of two polynomials, then the resulting array
  represents the coefficients of the product polynomial.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>array1</code> - The first array.</dd>
<dd><code>array2</code> - The second array.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="convolve(ptolemy.math.Complex[],ptolemy.math.Complex[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convolve</h4>
<pre class="methodSignature">public static final&nbsp;<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;convolve&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;array1,
                                       <a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;array2)</pre>
<div class="block">Return a new array that is the convolution of two complex arrays.
  The length of the new array is equal to the sum of the lengths of the
  two argument arrays minus one.  Note that some authors define
  complex convolution slightly differently as the convolution of the
  first array with the <em>conjugate</em> of the second.  If you need
  to use that definition, then conjugate the second array before
  calling this method. Convolution defined as we do here is the
  same as polynomial multiplication.  If the two argument arrays
  represent the coefficients of two polynomials, then the resulting
  array represents the coefficients of the product polynomial.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>array1</code> - The first array.</dd>
<dd><code>array2</code> - The second array.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of complex numbers.</dd>
</dl>
</li>
</ul>
<a id="DCT(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DCT</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;DCT&#8203;(double[]&nbsp;x)</pre>
<div class="block">Return a new array of doubles that is the forward, normalized
  DCT of the input array of doubles.
  This method automatically computes the order of the transform
  based on the length of the input array. It is equivalent to
  DCT(x, order, DCT_TYPE_NORMALIZED), where 2^order is the smallest
  power of two greater than or equal to the length of the specified
  array.  The length of the result is 2^order.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of doubles.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles, with length 2^order.</dd>
</dl>
</li>
</ul>
<a id="DCT(double[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DCT</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;DCT&#8203;(double[]&nbsp;x,
                                 int&nbsp;order)</pre>
<div class="block">Return a new array of doubles that is the forward, normalized
  DCT of the input array of doubles.
  This method is equivalent to
  DCT(x, order, DCT_TYPE_NORMALIZED).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of doubles.</dd>
<dd><code>order</code> - Log base 2 of the size of the transform.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles, with length 2^order.</dd>
</dl>
</li>
</ul>
<a id="DCT(double[],int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DCT</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;DCT&#8203;(double[]&nbsp;x,
                                 int&nbsp;order,
                                 int&nbsp;type)</pre>
<div class="block">Return a new array of doubles that is the forward DCT of the
  input array of doubles.
  See the DCT_TYPE_XXX constants for documentation of the
  exact formula, which depends on the type.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of doubles.</dd>
<dd><code>order</code> - Log base 2 of the size of the transform.</dd>
<dd><code>type</code> - The type of DCT, which is one of DCT_TYPE_NORMALIZED,
   DCT_TYPE_UNNORMALIZED, or DCT_TYPE_ORTHONORMAL.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles, with length 2^order.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#DCT_TYPE_NORMALIZED"><code>DCT_TYPE_NORMALIZED</code></a>, 
<a href="#DCT_TYPE_UNNORMALIZED"><code>DCT_TYPE_UNNORMALIZED</code></a>, 
<a href="#DCT_TYPE_ORTHONORMAL"><code>DCT_TYPE_ORTHONORMAL</code></a></dd>
</dl>
</li>
</ul>
<a id="decibel(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>decibel</h4>
<pre class="methodSignature">@Deprecated
public static final&nbsp;double&nbsp;decibel&#8203;(double&nbsp;value)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use toDecibels() instead.</div>
</div>
<div class="block">Return the value of the argument
  in decibels, which is defined to be 20*log<sub>10</sub>(<em>z</em>),
  where <em>z</em> is the argument.
  Note that if the input represents power, which is proportional to a
  magnitude squared, then this should be divided
  by two to get 10*log<sub>10</sub>(<em>z</em>).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The value to convert to decibels.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#toDecibels(double)"><code>toDecibels(double)</code></a></dd>
</dl>
</li>
</ul>
<a id="decibel(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>decibel</h4>
<pre class="methodSignature">@Deprecated
public static final&nbsp;double[]&nbsp;decibel&#8203;(double[]&nbsp;values)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Use toDecibels() instead.</div>
</div>
<div class="block">Return a new array the value of the argument array
  in decibels, using the previous decibel() method.
  You may wish to combine this with DoubleArrayMath.limit().</div>
</li>
</ul>
<a id="downsample(double[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>downsample</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;downsample&#8203;(double[]&nbsp;x,
                                        int&nbsp;n)</pre>
<div class="block">Return a new array that is formed by taking every nth sample
  starting with the 0th sample, and discarding the rest.
  This method calls :
  downsample(x, n, 0)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of doubles.</dd>
<dd><code>n</code> - An integer specifying the downsampling factor.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles of length = floor(L / n), where
  L is the size of the input array.</dd>
</dl>
</li>
</ul>
<a id="downsample(double[],int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>downsample</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;downsample&#8203;(double[]&nbsp;x,
                                        int&nbsp;n,
                                        int&nbsp;startIndex)</pre>
<div class="block">Return a new array that is formed by taking every nth sample
  starting at startIndex, and discarding the samples in between.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of doubles.</dd>
<dd><code>n</code> - An integer specifying the downsampling factor.</dd>
<dd><code>startIndex</code> - An integer specifying the index of sample at
  which to start downsampling. This integer must be between 0 and
  L - 1, where L is the size of the input array.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles of length =
  floor((L - startIndex) / n),
  where L is the size of the input array.</dd>
</dl>
</li>
</ul>
<a id="FFT(ptolemy.math.Complex[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FFT</h4>
<pre class="methodSignature">public static final&nbsp;<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;FFT&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x)</pre>
<div class="block">Return a new array of complex numbers which is the FFT
  of an input array of complex numbers.  The order of the transform
  is the next power of two greater than the length of the argument.
  The input is zero-padded if it does not match this length.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of complex numbers.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The FFT of the argument.</dd>
</dl>
</li>
</ul>
<a id="FFT(ptolemy.math.Complex[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FFT</h4>
<pre class="methodSignature">public static final&nbsp;<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;FFT&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x,
                                  int&nbsp;order)</pre>
<div class="block">Return a new array of complex numbers which is the FFT
  of an input array of complex numbers.
  The input is zero-padded if it does not match the length.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of complex numbers.</dd>
<dd><code>order</code> - The log base 2 of the length of the FFT.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The FFT of the argument.</dd>
</dl>
</li>
</ul>
<a id="FFTComplexOut(ptolemy.math.Complex[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FFTComplexOut</h4>
<pre class="methodSignature">public static final&nbsp;<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;FFTComplexOut&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x)</pre>
<div class="block">Return a new array of Complex's which is the forward FFT
  of an input array of Complex's.
  This method automatically computes the order of the transform
  based on the length of the input array, and calls
  FFTComplexOut(x, order).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of Complex's.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of Complex's.</dd>
</dl>
</li>
</ul>
<a id="FFTComplexOut(ptolemy.math.Complex[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FFTComplexOut</h4>
<pre class="methodSignature">public static final&nbsp;<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;FFTComplexOut&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x,
                                            int&nbsp;order)</pre>
<div class="block">Return a new array of Complex's which is the forward FFT
  of an input array of Complex's.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of Complex's.</dd>
<dd><code>order</code> - The base-2 logarithm of the size of the transform.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of Complex's.</dd>
</dl>
</li>
</ul>
<a id="FFTComplexOut(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FFTComplexOut</h4>
<pre class="methodSignature">public static final&nbsp;<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;FFTComplexOut&#8203;(double[]&nbsp;x)</pre>
<div class="block">Return a new array of Complex's which is the forward FFT
  of a real input array of doubles.
  This method automatically computes the order of the transform
  based on the length of the input array, and calls
  FFTComplexOut(x, order).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of doubles.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of Complex's.</dd>
</dl>
</li>
</ul>
<a id="FFTComplexOut(double[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FFTComplexOut</h4>
<pre class="methodSignature">public static final&nbsp;<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;FFTComplexOut&#8203;(double[]&nbsp;x,
                                            int&nbsp;order)</pre>
<div class="block">Return a new array of Complex's which is the forward FFT
  of a real input array of doubles.
  This method is half as expensive as computing the FFT of a
  Complex array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of doubles.</dd>
<dd><code>order</code> - The base-2 logarithm of the size of the transform.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of Complex's.</dd>
</dl>
</li>
</ul>
<a id="FFTImagOut(ptolemy.math.Complex[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FFTImagOut</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;FFTImagOut&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x)</pre>
<div class="block">Return a new array of doubles which is the imaginary part of the
  FFT of an input array of Complex's.
  This method automatically computes the order of the transform
  based on the length of the input array, and calls
  FFTImagOut(x, order).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of Complex's.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="FFTImagOut(ptolemy.math.Complex[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FFTImagOut</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;FFTImagOut&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x,
                                        int&nbsp;order)</pre>
<div class="block">Return a new array of doubles which is the imaginary part of the
  FFT of an input array of Complex's.
  This method is half as expensive as computing both the real and
  imaginary parts of an FFT on a array of Complex's. It is especially
  useful when the output is known to be purely imaginary.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of Complex's.</dd>
<dd><code>order</code> - The base-2 logarithm of the size of the transform.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="FFTImagOut(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FFTImagOut</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;FFTImagOut&#8203;(double[]&nbsp;x)</pre>
<div class="block">Return a new array of doubles that is the imaginary part of the FFT
  of the real input array of doubles.
  This method is half as expensive as computing both the real and
  imaginary parts of a FFT on a real array. It is especially useful when
  the output is known to be purely imaginary (input is odd).
  This method automatically computes the order of the transform
  based on the length of the input array, and calls:
  FFTImagOut(x, order)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of doubles.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="FFTImagOut(double[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FFTImagOut</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;FFTImagOut&#8203;(double[]&nbsp;x,
                                        int&nbsp;order)</pre>
<div class="block">Return a new array of doubles that is the imaginary part of the FFT
  of the real input array of doubles.
  This method is half as expensive as computing both the real and
  imaginary parts of a FFT on a real array. It is especially useful when
  the output is known to be purely imaginary (input is odd).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of doubles.</dd>
<dd><code>order</code> - The base-2 logarithm of the size of the transform.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="FFTRealOut(ptolemy.math.Complex[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FFTRealOut</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;FFTRealOut&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x)</pre>
<div class="block">Return a new array of doubles which is the real part of the
  forward FFT of an input array of Complex's.
  This method automatically computes the order of the transform
  based on the length of the input array, and calls :
  FFTRealOut(x, order)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of Complex's.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="FFTRealOut(ptolemy.math.Complex[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FFTRealOut</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;FFTRealOut&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x,
                                        int&nbsp;order)</pre>
<div class="block">Return a new array of doubles which is the real part of the
  forward FFT of an input array of Complex's.
  This method is half as expensive as computing both the real and
  imaginary parts of an FFT on a array of Complex's. It is especially
  useful when the output is known to be purely real.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of Complex's.</dd>
<dd><code>order</code> - The base-2 logarithm of the size of the transform.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="FFTRealOut(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FFTRealOut</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;FFTRealOut&#8203;(double[]&nbsp;x)</pre>
<div class="block">Return a new array of doubles that is the real part of the FFT of
  the real input array of doubles.
  This method automatically computes the order of the transform
  based on the length of the input array, and calls :
  FFTRealOut(x, order).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of doubles.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="FFTRealOut(double[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FFTRealOut</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;FFTRealOut&#8203;(double[]&nbsp;x,
                                        int&nbsp;order)</pre>
<div class="block">Return a new array of doubles that is the real part of the FFT of
  the real input array of doubles.
  This method is half as expensive as computing both the real and
  imaginary parts of an FFT on a real array. It is especially useful
  when the output is known to be purely real (input is even).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of doubles.</dd>
<dd><code>order</code> - The base-2 logarithm of the size of the transform</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="IDCT(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>IDCT</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;IDCT&#8203;(double[]&nbsp;x)</pre>
<div class="block">Return a new array of doubles that is the inverse, normalized
  DCT of the input array of doubles.
  This method automatically computes the order of the transform
  based on the length of the input array. It is equivalent to
  IDCT(x, order, DCT_TYPE_NORMALIZED), where 2^order is the
  next power of two larger than or equal to the length of the
  specified array.  The returned array has length 2^order.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of doubles.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles with length 2^order.</dd>
</dl>
</li>
</ul>
<a id="IDCT(double[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>IDCT</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;IDCT&#8203;(double[]&nbsp;x,
                                  int&nbsp;order)</pre>
<div class="block">Return a new array of doubles that is the inverse, normalized
  DCT of the input array of doubles, using the specified order.
  The length of the DCT is 2^<i>order</i>.  This is equivalent to
  IDCT(x, order, DCT_TYPE_NORMALIZED).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of doubles.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles with length 2^order.</dd>
</dl>
</li>
</ul>
<a id="IDCT(double[],int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>IDCT</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;IDCT&#8203;(double[]&nbsp;x,
                                  int&nbsp;order,
                                  int&nbsp;type)</pre>
<div class="block">Return a new array of doubles that is the inverse DCT of the
  input array of doubles.
  See the DCT_TYPE_XXX constants for documentation of the
  exact formula, which depends on the type.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of doubles.</dd>
<dd><code>order</code> - The base-2 logarithm of the size of the transform.</dd>
<dd><code>type</code> - The type of IDCT, which is one of DCT_TYPE_NORMALIZED,
   DCT_TYPE_UNNORMALIZED, or DCT_TYPE_ORTHONORMAL.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles with length 2^order.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#DCT_TYPE_NORMALIZED"><code>DCT_TYPE_NORMALIZED</code></a>, 
<a href="#DCT_TYPE_UNNORMALIZED"><code>DCT_TYPE_UNNORMALIZED</code></a>, 
<a href="#DCT_TYPE_ORTHONORMAL"><code>DCT_TYPE_ORTHONORMAL</code></a></dd>
</dl>
</li>
</ul>
<a id="IFFT(ptolemy.math.Complex[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>IFFT</h4>
<pre class="methodSignature">public static final&nbsp;<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;IFFT&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x)</pre>
<div class="block">Return a new array of complex numbers which is the inverse FFT
  of an input array of complex numbers.  The length of the result
  is the next power of two greater than the length of the argument.
  The input is zero-padded if it does not match this length.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of complex numbers.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The inverse FFT of the argument.</dd>
</dl>
</li>
</ul>
<a id="IFFT(ptolemy.math.Complex[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>IFFT</h4>
<pre class="methodSignature">public static final&nbsp;<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;IFFT&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x,
                                   int&nbsp;order)</pre>
<div class="block">Return a new array of complex numbers which is the inverse FFT
  of an input array of complex numbers.
  The input is zero-padded if it does not match this length.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of complex numbers.</dd>
<dd><code>order</code> - The log base 2 of the length of the FFT.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The inverse FFT of the argument.</dd>
</dl>
</li>
</ul>
<a id="IFFTComplexOut(ptolemy.math.Complex[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>IFFTComplexOut</h4>
<pre class="methodSignature">public static final&nbsp;<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;IFFTComplexOut&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x)</pre>
<div class="block">Return a new array of Complex's which is the inverse FFT
  of an input array of Complex's.
  This method automatically computes the order of the transform
  based on the length of the input array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of Complex's.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of Complex's.</dd>
</dl>
</li>
</ul>
<a id="IFFTComplexOut(ptolemy.math.Complex[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>IFFTComplexOut</h4>
<pre class="methodSignature">public static final&nbsp;<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;IFFTComplexOut&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x,
                                             int&nbsp;order)</pre>
<div class="block">Return a new array of Complex's which is the forward FFT
  of an input array of Complex's.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of Complex's.</dd>
<dd><code>order</code> - The base-2 logarithm of the size of the transform.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of Complex's.</dd>
</dl>
</li>
</ul>
<a id="IFFTRealOut(ptolemy.math.Complex[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>IFFTRealOut</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;IFFTRealOut&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x)</pre>
<div class="block">Return a new array of doubles which is the real part of the inverse
  FFT of an input array of Complex's.
  This is less than half as expensive as computing both the real and
  imaginary parts. It is especially useful when it is known that the
  output is purely real.
  This method automatically computes the order of the transform
  based on the length of the input array, and calls :
  IFFTRealOut(x, order)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of Complex's.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="IFFTRealOut(ptolemy.math.Complex[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>IFFTRealOut</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;IFFTRealOut&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;x,
                                         int&nbsp;order)</pre>
<div class="block">Return a new array of doubles which is the real part of the inverse
  FFT of an input array of Complex's.
  This method is less than half as expensive as computing both the
  real and imaginary parts of an IFFT of an array of Complex's. It is
  especially useful when it is known that the output is purely real.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of Complex's.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="IFFTRealOut(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>IFFTRealOut</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;IFFTRealOut&#8203;(double[]&nbsp;x)</pre>
<div class="block">Return a new array of doubles which is the real part of the inverse
  FFT of an input array of doubles.
  This method automatically computes the order of the transform
  based on the length of the input array, and calls :
  IFFTRealOut(x, order)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of doubles.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="IFFTRealOut(double[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>IFFTRealOut</h4>
<pre class="methodSignature">public static&nbsp;double[]&nbsp;IFFTRealOut&#8203;(double[]&nbsp;x,
                                   int&nbsp;order)</pre>
<div class="block">Return a new array of doubles which is the real part of the inverse
  FFT of an input array of doubles. This method is less than half
  as expensive as computing the real part of an IFFT of an array of
  Complex's. It is especially useful when both the input and output
  are known to be purely real.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - An array of doubles.</dd>
<dd><code>order</code> - The base-2 logarithm of the size of the transform.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="generateBartlettWindow(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generateBartlettWindow</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;generateBartlettWindow&#8203;(int&nbsp;length)</pre>
<div class="block">Return a new array that is filled with samples of a Bartlett
  window of a specified length. Throw an IllegalArgumentException
  if the length is less than 1 or the window type is unknown.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>length</code> - The length of the window to be generated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="generateBlackmanWindow(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generateBlackmanWindow</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;generateBlackmanWindow&#8203;(int&nbsp;length)</pre>
<div class="block">Return a new array that is filled with samples of a Blackman
  window of a specified length. Throw an IllegalArgumentException
  if the length is less than 1 or the window type is unknown.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>length</code> - The length of the window to be generated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="generateBlackmanHarrisWindow(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generateBlackmanHarrisWindow</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;generateBlackmanHarrisWindow&#8203;(int&nbsp;length)</pre>
<div class="block">Return a new array that is filled with samples of a Blackman Harris
  window of a specified length. Throw an IllegalArgumentException
  if the length is less than 1 or the window type is unknown.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>length</code> - The length of the window to be generated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="generateGaussianCurve(double,double,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generateGaussianCurve</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;generateGaussianCurve&#8203;(double&nbsp;standardDeviation,
                                                   double&nbsp;extent,
                                                   int&nbsp;length)</pre>
<div class="block">Return an array with samples the Gaussian curve (the "bell curve").
  The returned array is symmetric.  E.g., to get a Gaussian curve
  that extends out to "four sigma," then the <i>extent</i> argument
  should be 4.0.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>standardDeviation</code> - The standard deviation.</dd>
<dd><code>extent</code> - The multiple of the standard deviation out to
   which the curve is plotted.</dd>
<dd><code>length</code> - The length of the returned array.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An array that contains samples of the Gaussian curve.</dd>
</dl>
</li>
</ul>
<a id="generateHammingWindow(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generateHammingWindow</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;generateHammingWindow&#8203;(int&nbsp;length)</pre>
<div class="block">Return a new array that is filled with samples of a Hamming
  window of a specified length. Throw an IllegalArgumentException
  if the length is less than 1 or the window type is unknown.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>length</code> - The length of the window to be generated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="generateHanningWindow(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generateHanningWindow</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;generateHanningWindow&#8203;(int&nbsp;length)</pre>
<div class="block">Return a new array that is filled with samples of a Hanning
  window of a specified length. Throw an IllegalArgumentException
  if the length is less than 1 or the window type is unknown.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>length</code> - The length of the window to be generated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="generatePolynomialCurve(double[],double,double,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generatePolynomialCurve</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;generatePolynomialCurve&#8203;(double[]&nbsp;polynomial,
                                                     double&nbsp;start,
                                                     double&nbsp;step,
                                                     int&nbsp;length)</pre>
<div class="block">Return an array with samples a polynomial curve.
  The first argument is an array giving the coefficients
  of the polynomial, starting with the constant term, followed
  by the linear term, followed by the quadratic term, etc.
  The remaining coefficients determine the points at which
  the polynomial curve is sampled. That is, they determine
  the values of the polynomial variable at which the polynomial
  is evaluated.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>polynomial</code> - An array with polynomial coefficients.</dd>
<dd><code>start</code> - The point of the first sample.</dd>
<dd><code>step</code> - The step size between samples.</dd>
<dd><code>length</code> - The length of the returned array.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An array that contains samples of a polynomial curve.</dd>
</dl>
</li>
</ul>
<a id="generateRaisedCosinePulse(double,double,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generateRaisedCosinePulse</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;generateRaisedCosinePulse&#8203;(double&nbsp;excessBandwidth,
                                                       double&nbsp;firstZeroCrossing,
                                                       int&nbsp;length)</pre>
<div class="block">Return an array containing a symmetric raised-cosine pulse.
  This pulse is widely used in communication systems, and is called
  a "raised cosine pulse" because the magnitude its Fourier transform
  has a shape that ranges from rectangular (if the excess bandwidth
  is zero) to a cosine curved that has been raised to be non-negative
  (for excess bandwidth of 1.0).  The elements of the returned array
  are samples of the function:
  <pre>
         sin(PI t/T)   cos(x PI t/T)
  h(t) = ----------- * -----------------
          PI t/T      1-(2 x t/T)<sup>2</sup>
  </pre>
  where x is the excess bandwidth and T is the number of samples
  from the center of the pulse to the first zero crossing.
  The samples are taken with a
  sampling interval of 1.0, and the returned array is symmetric.
  With an excessBandwidth of 0.0, this pulse is a sinc pulse.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>excessBandwidth</code> - The excess bandwidth.</dd>
<dd><code>firstZeroCrossing</code> - The number of samples from the center of the
   pulse to the first zero crossing.</dd>
<dd><code>length</code> - The length of the returned array.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An array containing a symmetric raised-cosine pulse.</dd>
</dl>
</li>
</ul>
<a id="generateRectangularWindow(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generateRectangularWindow</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;generateRectangularWindow&#8203;(int&nbsp;length)</pre>
<div class="block">Return a new array that is filled with samples of a rectangular
  window of a specified length. Throw an IllegalArgumentException
  if the length is less than 1 or the window type is unknown.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>length</code> - The length of the window to be generated.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="generateSqrtRaisedCosinePulse(double,double,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generateSqrtRaisedCosinePulse</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;generateSqrtRaisedCosinePulse&#8203;(double&nbsp;excessBandwidth,
                                                           double&nbsp;firstZeroCrossing,
                                                           int&nbsp;length)</pre>
<div class="block">Return an array containing a symmetric raised-cosine pulse.
  This pulse is widely used in communication systems, and is called
  a "raised cosine pulse" because the magnitude its Fourier transform
  has a shape that ranges from rectangular (if the excess bandwidth
  is zero) to a cosine curved that has been raised to be non-negative
  (for excess bandwidth of 1.0).  The elements of the returned array
  are samples of the function:
  <pre>
           4 x(cos((1+x)PI t/T) + T sin((1-x)PI t/T)/(4x t/T))
  h(t) =  ---------------------------------------------------
                PI sqrt(T)(1-(4 x t/T)<sup>2</sup>)
  </pre>
  <p>
  where <i>x</i> is the the excess bandwidth.
  This pulse convolved with itself will, in principle, be equal
  to a raised cosine pulse.  However, because the pulse decays rather
  slowly for low excess bandwidth, this ideal is not
  closely approximated by short finite approximations of the pulse.
  The samples are taken with a
  sampling interval of 1.0, and the returned array is symmetric.
  With an excessBandwidth of 0.0, this pulse is a scaled sinc pulse.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>excessBandwidth</code> - The excess bandwidth.</dd>
<dd><code>firstZeroCrossing</code> - The number of samples from the center of the
   pulse to the first zero crossing.</dd>
<dd><code>length</code> - The length of the returned array.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array containing a square-root raised-cosine pulse.</dd>
</dl>
</li>
</ul>
<a id="generateWindow(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generateWindow</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;generateWindow&#8203;(int&nbsp;length,
                                            int&nbsp;windowType)</pre>
<div class="block">Return a new array that is filled with samples of a window of a
  specified length and type. Throw an IllegalArgumentException
  if the length is less than 1 or the window type is unknown.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>length</code> - The length of the window to be generated.</dd>
<dd><code>windowType</code> - The type of window to generate.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
</dl>
</li>
</ul>
<a id="nextPowerOfTwo(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nextPowerOfTwo</h4>
<pre class="methodSignature">public static final&nbsp;int&nbsp;nextPowerOfTwo&#8203;(double&nbsp;x)</pre>
<div class="block">Return the next power of two larger than the argument.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - A positive real number.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If the argument is less than
   or equal to zero.</dd>
</dl>
</li>
</ul>
<a id="order(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>order</h4>
<pre class="methodSignature">public static final&nbsp;int&nbsp;order&#8203;(int&nbsp;size)</pre>
<div class="block">Return the "order" of a transform size, i.e. the base-2 logarithm
  of the size. The order will be rounded up to the nearest integer.
  If the size is zero or negative, throw an IllegalArgumentException.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>size</code> - The size of the transform.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The order of the transform.</dd>
</dl>
</li>
</ul>
<a id="poleZeroToFrequency(ptolemy.math.Complex[],ptolemy.math.Complex[],ptolemy.math.Complex,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>poleZeroToFrequency</h4>
<pre class="methodSignature">public static final&nbsp;<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;poleZeroToFrequency&#8203;(<a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;poles,
                                                  <a href="Complex.html" title="class in ptolemy.math">Complex</a>[]&nbsp;zeros,
                                                  <a href="Complex.html" title="class in ptolemy.math">Complex</a>&nbsp;gain,
                                                  int&nbsp;numSteps)</pre>
<div class="block">Given an array of pole locations, an array of zero locations, and a
  gain term, return frequency response specified by these.
  This is calculated by walking around the unit circle and forming
  the product of the distances to the zeros, dividing by the product
  of the distances to the poles, and multiplying by the gain.
  The length of the returned array is <i>numSteps</i>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>poles</code> - An array of pole locations.</dd>
<dd><code>zeros</code> - An array of zero locations.</dd>
<dd><code>gain</code> - A complex gain.</dd>
<dd><code>numSteps</code> - The number of samples in the returned
  frequency response.</dd>
</dl>
</li>
</ul>
<a id="sampleWave(int,double,double,ptolemy.math.DoubleUnaryOperation)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sampleWave</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;sampleWave&#8203;(int&nbsp;length,
                                        double&nbsp;startTime,
                                        double&nbsp;interval,
                                        <a href="DoubleUnaryOperation.html" title="interface in ptolemy.math">DoubleUnaryOperation</a>&nbsp;sampleGen)</pre>
<div class="block">Return a new array that is filled with samples of a waveform of a
  specified length. The waveform is sampled with starting at startTime,
  at a sampling period of interval.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>length</code> - The number of samples to generate.</dd>
<dd><code>startTime</code> - The corresponding time for the first sample.</dd>
<dd><code>interval</code> - The time between successive samples. This may
  be negative if the waveform is to be reversed, or zero if the
  array is to be filled with a constant.</dd>
<dd><code>sampleGen</code> - A DoubleUnaryOperation.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="DoubleUnaryOperation.html" title="interface in ptolemy.math"><code>DoubleUnaryOperation</code></a></dd>
</dl>
</li>
</ul>
<a id="sawtooth(double,double,double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sawtooth</h4>
<pre class="methodSignature">public static&nbsp;double&nbsp;sawtooth&#8203;(double&nbsp;period,
                              double&nbsp;phase,
                              double&nbsp;time)</pre>
<div class="block">Return a sample of a sawtooth wave with the specified period and
  phase at the specified time.  The returned value ranges between
  -1.0 and 1.0.  The phase is given as a fraction of a cycle,
  typically ranging from 0.0 to 1.0.  If the phase is 0.0 or 1.0,
  the wave begins at zero with a rising slope.  If it is 0.5, it
  begins at the falling edge with value -1.0.
  If it is 0.25, it begins at +0.5.

  Throw an exception if the period is less than or equal to 0.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>period</code> - The period of the sawtooth wave.</dd>
<dd><code>phase</code> - The phase of the sawtooth wave.</dd>
<dd><code>time</code> - The time of the sample.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A double in the range -1.0 to +1.0.</dd>
</dl>
</li>
</ul>
<a id="sinc(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sinc</h4>
<pre class="methodSignature">public static final&nbsp;double&nbsp;sinc&#8203;(double&nbsp;x)</pre>
<div class="block">Return sin(x)/x, the so-called sinc function.
  If the argument is very close to zero, significant quantization
  errors may result (exactly 0.0 is OK, since this just returns 1.0).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - A number.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The sinc function.</dd>
</dl>
</li>
</ul>
<a id="square(double,double,double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>square</h4>
<pre class="methodSignature">public static&nbsp;double&nbsp;square&#8203;(double&nbsp;period,
                            double&nbsp;phase,
                            double&nbsp;time)</pre>
<div class="block">Return a sample of a square wave with the specified period and
  phase at the specified time.  The returned value is 1 or -1.
  A sample that falls on the rising edge of the square wave is
  assigned value +1.  A sample that falls on the falling edge is
  assigned value -1.  The phase is given as a fraction of a
  cycle, typically ranging from 0.0 to 1.0.  If the phase is 0.0
  or 1.0, the square wave begins at the start of the +1.0 phase.
  If it is 0.5, it begins at the start of the -1.0 phase. If it
  is 0.25, it begins halfway through the +1.0 portion of the
  wave.

  Throw an exception if the period is less than or equal to 0.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>period</code> - The period of the square wave.</dd>
<dd><code>phase</code> - The phase of the square wave.</dd>
<dd><code>time</code> - The time of the sample.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>+1.0 or -1.0.</dd>
</dl>
</li>
</ul>
<a id="triangle(double,double,double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>triangle</h4>
<pre class="methodSignature">public static&nbsp;double&nbsp;triangle&#8203;(double&nbsp;period,
                              double&nbsp;phase,
                              double&nbsp;time)</pre>
<div class="block">Return a sample of a triangle wave with the specified period and
  phase at the specified time.  The returned value ranges between
  -1.0 and 1.0.  The phase is given as a fraction of a cycle,
  typically ranging from 0.0 to 1.0.  If the phase is 0.0 or 1.0,
  the wave begins at zero with a rising slope.  If it is 0.5, it
  begins at zero with a falling slope. If it is 0.25, it begins at +1.0.

  Throw an exception if the period is less than or equal to 0.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>period</code> - The period of the triangle wave.</dd>
<dd><code>phase</code> - The phase of the triangle wave.</dd>
<dd><code>time</code> - The time of the sample.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A number in the range -1.0 to +1.0.</dd>
</dl>
</li>
</ul>
<a id="toDecibels(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toDecibels</h4>
<pre class="methodSignature">public static final&nbsp;double&nbsp;toDecibels&#8203;(double&nbsp;value)</pre>
<div class="block">Return the value of the argument
  in decibels, which is defined to be 20*log<sub>10</sub>(<em>z</em>),
  where <em>z</em> is the argument.
  Note that if the input represents power, which is proportional to a
  magnitude squared, then this should be divided
  by two to get 10*log<sub>10</sub>(<em>z</em>).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The value to convert to decibels.</dd>
</dl>
</li>
</ul>
<a id="unwrap(double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unwrap</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;unwrap&#8203;(double[]&nbsp;angles)</pre>
<div class="block">Return a new array that is constructed from the specified
  array by unwrapping the angles.  That is, if
  the difference between successive values is greater than
  <em>PI</em> in magnitude, then the second value is modified by
  multiples of 2<em>PI</em> until the difference is less than
  or equal to <em>PI</em>.
  In addition, the first element is modified so that its
  difference from zero is less than or equal to <em>PI</em> in
  magnitude.  This method is used for generating more meaningful
  phase plots.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>angles</code> - An array of angles.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of phase-unwrapped angles.</dd>
</dl>
</li>
</ul>
<a id="upsample(double[],int)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>upsample</h4>
<pre class="methodSignature">public static final&nbsp;double[]&nbsp;upsample&#8203;(double[]&nbsp;x,
                                      int&nbsp;n)</pre>
<div class="block">Return a new array that is the result of inserting (n-1) zeroes
  between each successive sample in the input array, resulting in an
  array of length n * L, where L is the length of the original array.
  Throw an exception for n &le; 0.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - The input array of doubles.</dd>
<dd><code>n</code> - An integer specifying the upsampling factor.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new array of doubles.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If the second argument is not
   strictly positive.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
