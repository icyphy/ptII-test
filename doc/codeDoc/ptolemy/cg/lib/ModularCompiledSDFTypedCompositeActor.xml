<?xml version="1.0" standalone="yes"?>
<!DOCTYPE doc PUBLIC "-//UC Berkeley//DTD DocML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/DocML_1.dtd">
<doc name="ModularCompiledSDFTypedCompositeActor" class="ptolemy.cg.lib.ModularCompiledSDFTypedCompositeActor">
  <description>
An aggregation of typed actors with lazy evaluation. The contents of&#10;this actor can be created in the usual way via visual editor by dragging&#10;in other actors and ports and connecting them. When it exports a MoML&#10;description of itself, it describes its ports and parameters in the&#10;usual way, but contained actors, relations, and their interconnections&#10;are exported within &amp;lt;configure&amp;gt; &amp;lt;/configure&amp;gt; tags.&#10;When reloading the MoML description, evaluation of the MoML&#10;within the configure tags is deferred until there is an explicit&#10;request for the contents. This behavior is useful for large&#10;complicated models where the time it takes to instantiate the&#10;entire model is large. It permits opening and browsing the model&#10;without a long wait. However, the cost comes typically when&#10;running the model. The instantiation time will be added to&#10;the time it takes to preinitialize the model.&#10;&lt;p&gt;&#10;The lazy contents of this composite are specified via the configure()&#10;method, which is called by the MoML parser and passed MoML code.&#10;The MoML is evaluated lazily; i.e. it is not actually evaluated&#10;until there is a request for its contents, via a call to&#10;getEntity(), numEntities(), entityList(), relationList(),&#10;or any related method. You can also force evaluation&#10;of the MoML by calling populate(). Accessing the attributes&#10;or ports of this composite does not trigger a populate() call,&#10;so a visual editor can interact with the actor from the outside&#10;in the usual way, enabling connections to its ports, editing&#10;of its parameters, and rendering of its custom icon, if any.&#10;&lt;p&gt;&#10;The configure method can be passed a URL or MoML text or both.&#10;If it is given MoML text, that text will normally be wrapped in a&#10;processing instruction, as follows:&#10;&lt;pre&gt;&#10;&amp;lt;?moml&#10;&amp;lt;group&amp;gt;&#10;... &lt;i&gt;MoML elements giving library contents&lt;/i&gt; ...&#10;&amp;lt;/group&amp;gt;&#10;?&amp;gt;&#10;&lt;/pre&gt;&#10;The processing instruction, which is enclosed in &quot;&amp;lt;?&quot; and &quot;?&amp;gt;&quot;&#10;prevents premature evaluation of the MoML.  The processing instruction&#10;has a &lt;i&gt;target&lt;/i&gt;, &quot;moml&quot;, which specifies that it contains MoML code.&#10;The keyword &quot;moml&quot; in the processing instruction must&#10;be exactly as above, or the entire processing instruction will&#10;be ignored.  The populate() method&#10;strips off the processing instruction and evaluates the MoML elements.&#10;The group element allows the library contents to be given as a set&#10;of elements (the MoML parser requires that there always be a single&#10;top-level element, which in this case will be the group element).&#10;&lt;p&gt;&#10;One subtlety in using this class arises because of a problem typical&#10;of lazy evaluation.  A number of exceptions may be thrown because of&#10;errors in the MoML code when the MoML code is evaluated.  However,&#10;since that code is evaluated lazily, it is evaluated in a context&#10;where these exceptions are not expected.  There is no completely&#10;clean solution to this problem; our solution is to translate all&#10;exceptions to runtime exceptions in the populate() method.&#10;This method, therefore, violates the condition for using runtime&#10;exceptions in that the condition that causes these exceptions to&#10;be thrown is not a testable precondition.&#10;&lt;p&gt;&#10;A second subtlety involves cloning.  When this class is cloned,&#10;if the configure MoML text has not yet been evaluated, then the clone&#10;is created with the same (unevaluated) MoML text, rather than being&#10;populated with the contents specified by that text.  If the object&#10;is cloned after being populated, the clone will also be populated.&#10;Cloning is used in actor-oriented classes to create subclasses&#10;or instances of a class.  When a LazyTypedCompositeActor contained&#10;by a subclass or an instance is populated, it delegates to the&#10;instance in the class definition. When that instance is populated,&#10;all of the derived instances in subclasses and instances of the&#10;class will also be populated as a side effect.&#10;&lt;p&gt;&#10;A third subtlety is that parameters of this actor cannot refer to&#10;contained entities or relations, nor to attributes contained by&#10;those. This is a rather esoteric use of expressions, so&#10;this limitation may not be onerous. You probably didn't know&#10;you could do that anyway.  An attempt to make such references&#10;will simply result in the expression failing to evaluate.  </description>
  <author>Dai Bui</author>
  <version>$Id$</version>
  <since>Ptolemy II 10.0</since>
  <Pt.ProposedRating>Red (rodiers)</Pt.ProposedRating>
  <Pt.AcceptedRating>Red (rodiers)</Pt.AcceptedRating>
</doc>
