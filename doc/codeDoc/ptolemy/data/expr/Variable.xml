<?xml version="1.0" standalone="yes"?>
<!DOCTYPE doc PUBLIC "-//UC Berkeley//DTD DocML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/DocML_1.dtd">
<doc name="Variable" class="ptolemy.data.expr.Variable">
  <description>
A Variable is an Attribute that contains a token, and can be set by an&#10; expression that can refer to other variables.&#10; &lt;p&gt;&#10; A variable can be given a token or an expression as its value. To create&#10; a variable with a token, either call the appropriate constructor, or create&#10; the variable with the appropriate container and name, and then call&#10; setToken(). To set the value from an expression, call setExpression().&#10; The expression is not actually evaluated until you call getToken(),&#10; getType(). By default, it is also evaluated when you call validate(),&#10; unless you have called setLazy(true), in which case it will only&#10; be evaluated if there are other variables that depend on it and those&#10; have not had setLazy(true) called.&#10; &lt;p&gt;&#10; Consider for example the sequence:&#10; &lt;pre&gt;&#10; Variable v3 = new Variable(container,&quot;v3&quot;);&#10; Variable v2 = new Variable(container,&quot;v2&quot;);&#10; Variable v1 = new Variable(container,&quot;v1&quot;);&#10; v3.setExpression(&quot;v1 + v2&quot;);&#10; v2.setExpression(&quot;1.0&quot;);&#10; v1.setExpression(&quot;2.0&quot;);&#10; v3.getToken();&#10; &lt;/pre&gt;&#10; Notice that the expression for &lt;code&gt;v3&lt;/code&gt; cannot be evaluated&#10; when it is set because &lt;code&gt;v2&lt;/code&gt; and &lt;code&gt;v1&lt;/code&gt; do not&#10; yet have values.  But there is no problem because the expression&#10; is not evaluated until getToken() is called.  Equivalently, we&#10; could have called, for example,&#10; &lt;pre&gt;&#10; v3.validate();&#10; &lt;/pre&gt;&#10; This will force &lt;code&gt;v3&lt;/code&gt; to be evaluated,&#10; and also &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt;&#10; to be evaluated.&#10; &lt;p&gt;&#10; There is a potentially confusing subtlety.  In the above code,&#10; before the last line is executed, the expression for &lt;code&gt;v3&lt;/code&gt;&#10; has not been evaluated, so the dependence that &lt;code&gt;v3&lt;/code&gt; has&#10; on &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; has not been recorded.&#10; Thus, if we call&#10; &lt;pre&gt;&#10; v1.validate();&#10; &lt;/pre&gt;&#10; before &lt;code&gt;v3&lt;/code&gt; has ever been evaluated, then it will &lt;i&gt;not&lt;/i&gt;&#10; trigger an evaluation of &lt;code&gt;v3&lt;/code&gt;.  Because of this, we recommend&#10; that user code call validate() immediately after calling&#10; setExpression().&#10; &lt;p&gt;&#10; If the expression string is null or empty,&#10; or if no value has been specified, then getToken() will return null.&#10; &lt;p&gt;&#10; The expression can reference variables that are in scope before the&#10; expression is evaluated (i.e., before getToken() or validate() is called).&#10; Otherwise, getToken() will throw an exception. All variables&#10; contained by the same container, and those contained by the container's&#10; container, are in the scope of this variable. Thus, in the above,&#10; all three variables are in each other's scope because they belong&#10; to the same container. If there are variables in the scope with the&#10; same name, then those lower in the hierarchy shadow those that are higher.&#10; An instance of ScopeExtendingAttribute can also be used to&#10; aggregate a set of variables and add them to the scope.&#10; &lt;p&gt;&#10; If a variable is referred&#10; to by expressions of other variables, then the name of the variable must be a&#10; valid identifier as defined by the Ptolemy II expression language syntax.&#10; A valid identifier starts with a letter or underscore, and contains&#10; letters, underscores, numerals, dollar signs ($),&#10; at signs (@), or pound signs (#).&#10; &lt;p&gt;&#10; A variable is a Typeable object. Constraints on its type can be&#10; specified relative to other Typeable objects (as inequalities on the types),&#10; or relative to specific types.  The former are called &lt;i&gt;dynamic type&#10; constraints&lt;/i&gt;, and the latter are called &lt;i&gt;static type constraints&lt;/i&gt;.&#10; Static type constraints are specified by the methods:&#10; &lt;ul&gt;&#10; &lt;li&gt; setTypeEquals()&#10; &lt;li&gt; setTypeAtMost()&#10; &lt;/ul&gt;&#10; whereas dynamic type constraints are given by&#10; &lt;ul&gt;&#10; &lt;li&gt; setTypeAtLeast()&#10; &lt;li&gt; setTypeSameAs()&#10; &lt;/ul&gt;&#10; Static type constraints are enforced in this class, meaning that:&#10; &lt;ul&gt;&#10; &lt;li&gt; If the variable already has a value (set by setToken() or&#10; setExpression()) when you set the static type constraint, then&#10; the value must satisfy the type constraint; and&#10; &lt;li&gt; If after setting a static type constraint you give the token&#10; a value, then the value must satisfy the constraints.&#10; &lt;/ul&gt;&#10; A violation will cause an exception (either when setToken() is called&#10; or when the expression is evaluated).&#10; &lt;p&gt;&#10; The dynamic type constraints are not enforced in this class, but merely&#10; reported by the typeConstraints() method.  They must be enforced at a&#10; higher level (by a type system) since they involve a network of variables&#10; and other typeable objects.  In fact, if the variable does not yet have&#10; a value, then a type system may use these constraints to infer what the&#10; type of the variable needs to be, and then call setTypeEquals().&#10; &lt;p&gt;&#10; The token returned by getToken() is always an instance of the class given&#10; by the getType() method.  This is not necessarily the same as the class&#10; of the token that was inserted via setToken().  It might be a distinct&#10; type if the token given by setToken() can be converted losslessly into one&#10; of the type given by setTypeEquals().&#10; &lt;p&gt;&#10; A variable by default has no MoML description (MoML is an XML modeling markup&#10; language).  Thus, a variable contained by a named object is not&#10; persistent, in that if the object is exported to a MoML file, the&#10; variable will not be represented.  If you prefer that the variable&#10; be represented, then you should use the derived class Parameter instead.&#10; &lt;p&gt;&#10; A variable is also normally not settable by casual users from the user&#10; interface.  This is because, by default, getVisibility() returns EXPERT.&#10; The derived class Parameter is fully visible by default.&#10; &lt;p&gt;&#10; In addition, this class provides as a convenience a &quot;string mode.&quot;&#10; If the variable is in string mode, then when setting the value of&#10; this variable, the string that you pass to setExpression(String)&#10; is taken to be literally the value of the instance of StringToken&#10; that represents the value of this parameter. It is not necessary&#10; to enclose it in quotation marks (and indeed, if you do, the quotation&#10; marks will become part of the value of the string).  In addition,&#10; the type of this parameter will be set to string. In addition,&#10; getToken() will never return null; if the value of the string&#10; has never been set, then an instance of StringToken is returned&#10; that has an empty string as its value. A parameter is&#10; in string mode if either setStringMode(true) has been called or&#10; it contains an attribute named &quot;_stringMode&quot;.&#10; &lt;p&gt;&#10; In string mode, the value passed to setExpression(String) may contain&#10; references to other variables in scope using the syntax $id,&#10; ${id} or $(id).  The first case only works if the id consists&#10; only of alphanumeric characters and/or underscore, and if the&#10; character immediately following the id is not one of these.&#10; To get a simple dollar sign, use $$.  In string mode, to set the&#10; value to be the empty string, create a Parameter in the container&#10; that has the value &lt;code&gt;&quot;&quot;&lt;/code&gt; and then set the string mode&#10; parameter to the &lt;code&gt;$&lt;i&gt;nameOfTheParameter&lt;/i&gt;&lt;/code&gt;.  For example,&#10; the parameter might be named &lt;code&gt;myEmptyParameter&lt;/code&gt; and have&#10; a value &lt;code&gt;&quot;&quot;&lt;/code&gt;; the value for the string mode parameter would&#10; be &lt;code&gt;$myEmptyParameter&lt;/code&gt;.  </description>
  <author>Neil Smyth, Xiaojun Liu, Edward A. Lee, Yuhong Xiong, contributor: Daniel Crawl.</author>
  <version>$Id$</version>
  <since>Ptolemy II 0.2</since>
  <Pt.ProposedRating>Red (neuendor)</Pt.ProposedRating>
  <Pt.AcceptedRating>Red (cxh)</Pt.AcceptedRating>
</doc>
