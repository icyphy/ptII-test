<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: ptolemy/actor/lib/jjs/modules/deterministicTemporalSemantics.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: ptolemy/actor/lib/jjs/modules/deterministicTemporalSemantics.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>//
// Copyright (c) 2015-2019 The Regents of the University of California.
// All rights reserved.
//
// Permission is hereby granted, without written agreement and without
// license or royalty fees, to use, copy, modify, and distribute this
// software and its documentation for any purpose, provided that the above
// copyright notice and the following two paragraphs appear in all copies
// of this software.
//
// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
// ENHANCEMENTS, OR MODIFICATIONS.
//

/** This is the implementation of another deterministic temporal semantics.
 * 
 *  This module provides Accessors with deterministic temporal semantics, 
 *  that are aligned with Cape Code's semantics. This module is to be explored 
 *  by commonHost, so that any swarmlet host will enjoy these features.
 *  For this, accessors calls to setTimeout() or setInterval() are binded, 
 *  respectively, to this module's setTioumetDet() and setIntervalDet(). It is 
 *  guaranteed that only one timeout (function provided by the host) is pending  
 *  at any time and that callbacks will be executing with respect to their  
 *  logical clock domains and their relative priority and/or arrival time.
 *  
 *  For this implementation, we assume that there is the physical time line, 
 *  together with many logical time lines. All time lines do not advance the same 
 *  way. Physical time is continuous and has the same rate, while logical time is 
 *  updated at particular instances.
 *  
 *  Each logical time line is associated with a 'labeled logical clock domains'
 *  (LLCD). This allows for defining and implementing logical simultaneity of 
 *  callbacks execution. 
 *
 *  The basic idea is to define each delayed callback with an LLCD. Two delayed 
 *  callbacks with the same LLCD share the same logical time line. If they have
 *  the same logical time execution, then they will execute atomically one after 
 *  another, such that their arrival order is respected. That is, if the instruction
 *  setInterval(F, T, 'A') was called before setInterval(G, T, 'A'), and no other
 *  action involving the LLCD 'A' has happened in between, then when F executes, it 
 *  will be immediately followed by G.  
 *  
 *  When a call to the binded setTimeout or setInterval occurs, then scheduling the 
 *  execution will depend on the LLCD. If it is a new one, then a new LLCD is created
 *  and its current logical time is set to the current physical time. However, if the 
 *  LLCD is already defined, then the current logical time of that clock domain is 
 *  used. In either cases, the callback will execute at its LLCD logical current time 
 *  plus the timeout. 

 *  Labeled logical clock domain are strings. However, if the programmer unintentionally
 *  or intentionally do not provide one, then a new anonymous clock domain is created 
 *  with its logical time origin set to the current real time (approximately). The new
 *  anonymous clock domain is unique and is generated by incrementing defaultLabelIndex.
 *  An exception is that if llcd is not given and timeout is zero, then a single shared 
 *  zero-delay clock domain is used.
 *  This exception is used to request an execution as soon as possible, before any
 *  callbacks in other clock domains are invoked. If there are multiple such zero-timeout
 *  anonymous llcd callbacks, then the order of their invocation will be determined by
 *  their priority, if one is given, and by the order of the request, if no priority
 *  is given or if a priority matches another priority.   
 *
 *  This implementation was preceded by a another one that adopts a slightly different
 *  semantics for the execution. In the previous version, any two callbacks with the 
 *  same label execute starting from the same reference point in time. In addition,
 *  there are only two time lines: the physical one and the logical one. Therefore,
 *  delayed callbacks execute only with respect to the logical one. This way, the inter
 *  execution time is always respected. The drawback is that additional delays are 
 *  added.
 *  
 *  For the purpose of implementing temporal semantics, we record all delayed callBacks
 *  in the 'delayedCallbacks' object. This object is accessed by label. Within a 
 *  labeled object, we record the current logical execution time, and the group of 
 *  delayed callbacks having the same label. A new delayedCallback object is added 
 *  to delayedCallbacks, given its label. In addition, each new object is uniquely 
 *  identified by a number (generated by automatically incrementing cbIdentifier). 
 *  Consequently, the identifier reflects the order in which the calls to setTimeout 
 *  or setInterval occurred. This number is returned and is to be used for clearing 
 *  the corresponding timer. This happens each time setTimeoutDet() or seIntervalDet() 
 *  is called. 
 *  
 *  For the sake of any system that may need to define execution order based on 
 *  predefined/precomputed priorities, it is possible to pass the priority 
 *  as an argument to setTimeout or setInterval. Consequently, the third level of
 *  delayed callbacks ordering will be, first, based on priorities, then on arrival
 *  time (reflected by the identifiers). For the case of Accessors, the priority will
 *  be inherited from the accessor's priority (if defined).
 *  
 *  
 *  In order to make the process fast, the list 'callbackQueue' keeps an incremental 
 *  next execution time sorted list of pointers to the delayed callbacks. Pointers
 *  are objects with two attributes: the labeled clock domain and the identifier.
 *  This list, has three levels of sorting. The first one is obviously the execution
 *  time. If two or more callbacks have the same execution time, they are ordered by 
 *  their labels origin. This is the second level of sorting. Finally, the third one is 
 *  the callbacks ordering, reflected by the identifiers. 
 *  
 *  A delayed callback has the following attributes: 
 *   *  callbackFunction: the callback function, which will be invoked once or periodically,
 *      depending on the value of the repeat parameter.
 *   *  interval: The time until the first (or only) execution of the callback.
 *      This is a non-negative number interpreted as milliseconds
 *      (a negative number will be treated as zero).
 *      This is a logical time, relative to the current logical time of the llcd.
 *      If the llcd is null or has never before been created, then a new llcd will be
 *      created and its logical time will be set to (approximately) the current physical time.
 *   *  periodic: if set to true, the callback needs to execute every interval time,
 *      otherwise, it executes only once. A boolean specifying whether the callback should 
 *      be invoked just once (with value false) or repeatedly, periodically, until stopped 
 *      (with value true).
 *   *  nextExecutionTime: records the next time at which the callback should be
 *      executed.
 *   *  priority is an optional attribute for the priority over other delayed callbacks
 *      that use the same llcd and are scheduled to occur at the same logical time.
 *      This is either null or an integer, where a lower value means higher priority.
 *      If two priorities match, then the order of invocation matches the order in which
 *      requests are made (by calling this function).
 *   *  errorCallback is an optional attribute that provides a callback to execute in case
 *      the delayed callback's execution throws an error. If no callback is specified, then
 *      if the delayed callback throws an error, then the error message and stack trace
 *      will be printed to the console and execution will continue.
 *   *  doneCallback is an optional attribute that provides the callback to execute after 
 *      the delayed callback has executed successfully. If repeat is true, then this callback
 *      will be invoked after each successful invocation of of the callback argument function.
 *        
 *  Proof: Done! Using Real-Time Maude :-)
 *  
 *  @module @accessors-hosts/common/deterministicTemporalSemantics
 *  @author Chadlia Jerad and Edward A. Lee
 *  @version $$Id: deterministicTemporalSemantics.js 2017-05-03 11:11:30Z chadlia.jerad $$   
 */

// Save the default engine's setTimeout, setInterval, clearTimeout and clearInterval 
// in other variables, so that they can be redefined later (see end of the file)
// var originalSetTimeout = setTimeout;
// var originalSetInterval = setInterval;
// var originalClearTimeout = clearTimeout;
// var originalClearInterval = clearInterval;

// This variable keeps track of all delayedCallback objects. These objects are accessed
// by the labeled logical clock domain and their unique identifier
var delayedCallbacks;

// A sorted list of (label/id) objects are in this variable. This enables fast
// execution, so that the implementation scales
var callbackQueue = [];

// Record the time of the next scheduled tick
var nextScheduledTick = Infinity;

// This variable uniquely identifies calls to setInterval and setTimeout
var cbIdentifier = 0;

// This variable identifies the physical setTimeout call point. This is useful for
// updating the next tick 
var tick;

// Default label index
var defaultLabelIndex = 0;

/** This function is to be binded to clearInterval() function. It clears the 
 *  periodic timer which identifier is given as parameter, by calling
 *  clearTick().
 *  
 *  @param cbId this parameter is required. It is the cbIndentifier.
 */
function clearIntervalDet(cbId){
    clearTick(cbId, true);
}

/** clearTick() parses delayedCallbacks in order to remove the one with the passed 
 *  id and periodicity. It is also deleted from callbackQueue.
 *  If the first argument, that is the identifier, is not a number, than no 
 *  need to parse.    
 *   
 *  @param cbId this parameter contains the callback identifier
 *  @param periodic boolean value: true if periodic (called from clearIntervalDet), 
 *          false otherwise
 */
function clearTick(cbId, periodic) {
    if (!delayedCallbacks || (callbackQueue.length === 0)) {
        return;
    }
    
    var label;
    var indexInCbQueue = -1;
    
    // Parse for the index in callbackQueue, and deduce the label
    for(var i = 0 ; i &lt; callbackQueue.length ; i++) {
        if (callbackQueue[i].id === cbId) {
            indexInCbQueue = i;
            label = callbackQueue[i].label ;
            break;
        }
    }
    
    if (indexInCbQueue !== -1) {
        // console.log('index of id: ' + cbId + ' in callback queue is: ' +
        //      indexInCbQueue + ' label is: ' + label + ' del callbacks: ' + 
        //      delayedCallbacks[label][cbId]);

        // Delete from delayedCallbacks, if the same periodic value
        if (delayedCallbacks[label][cbId].periodic === periodic) {
            delete delayedCallbacks[label][cbId];
            
            // Delete from callbackQueue
            callbackQueue.splice(indexInCbQueue , 1);
            
            // Clean up delayedCallbacks
            if ((Object.size(delayedCallbacks[label]) === 2)) {
                delete(delayedCallbacks[label]);
                // Check if there are still callbacks in the list
                if (Object.size(delayedCallbacks) === 0) {
                    reset();
                }
            }
        }
    }
    
    // If no delayed callback to remove, then this is not an error! It may happen, for instance,
    // that a timer (call to this.setTimeout) has expired before calling clear. It may happen 
    // also to call clearTimeout or clearInterval with wrong arguments.
}

/** This function is to be binded to clearTimeout() function. It clears the 
 *  timeout timer which identifier is given as parameter, by calling
 *  clearTick().
 *  
 *  @param cbId this parameter is required. It is the callback indentifier of the one time delayed
 *   callback to clear.
 */
function clearTimeoutDet(cbId){
    clearTick(cbId, false);
}

/** Compute the next execution time to be scheduled. Since callbacks are sorted
 *  in callbackQueue in order of their next execution time, the next execution time 
 *  of the one on then the top of the list is returned. 
 *  
 *  @return the next execution time of the first callback in the sorted list
 */ 
function computeNextSceduledTick() {
    // Get the label and id of the first element in the sorted list
    var label = callbackQueue[0].label;
    var id = callbackQueue[0].id;
    
    return (delayedCallbacks[label][id].nextExecutionTime);
}

/** This function implements callbacks execution and update. It is called only by the
 *  host's setTimeout function. 
 *  All delayed callbacks with next execution time less than the current time will be 
 *  executing. Consequently, in case the system has accumulated some delay due, or example,
 *  to an over running program, all late callbacks will execute, but with respect to the 
 *  order and atomicity set by the definitions.
 *  Next, the list is cleaned from no-more triggerable callbacks. 
 *  And finally, the next tick is set.
 */
var executeAndSetNextTick = function() {
    // Handling a corner case: if somehow it happens that delayedCallbacks is empty
    if (!delayedCallbacks || (callbackQueue.length === 0)) {
        reset();
        return;
    }
    
    var currentTime = Date.now();
    
    while (nextScheduledTick &lt;= currentTime) {
        
        // console.log('-------Execute: At logical time: ' + nextScheduledTick % 100000 
        //        + ' At real time: ' + Date.now() % 1000000 + ' size of queue: '+callbackQueue.length );
        
        // Execute callbacks
        executeCallbacks();
        
        // Check that there are still callbacks in the list
        if (!delayedCallbacks || (callbackQueue.length === 0)) {
            reset();
            return;
        }
        
        // Update the next scheduled tick 
        nextScheduledTick = computeNextSceduledTick();
        
        // Update current time
        currentTime = Date.now();
    }
    
    // Handling a corner case: if somehow it happens that delayedCallbacks is empty
    if (!delayedCallbacks || (callbackQueue.length === 0)) {
        reset();
        return;
    }
    
    // Set the next Tick
    // tick = originalSetTimeout(executeAndSetNextTick, Math.max(nextScheduledTick - Date.now(), 0));
    tick = setTimeout(executeAndSetNextTick, Math.max(nextScheduledTick - Date.now(), 0));
};

/** This function executes delayed callback such that their next execution time
 *  is equal to the nextScheduledTick.
 *  It then updates the next execution time if the callback is periodic, and remove it 
 *  if not periodic. Labels are also deleted if the corresponding array is empty.
 */
function executeCallbacks() {
    var done = false;
    do {
        var key = callbackQueue[0].label;
        var id = callbackQueue[0].id;
        
        if (delayedCallbacks[key][id].nextExecutionTime === nextScheduledTick) {
            // console.dir(callbackQueue);
            // console.dir(delayedCallbacks);
            callbackQueue.splice (0, 1);

            // Update the current logical time of an LLCD 
            delayedCallbacks[key].currentLogicalTime = nextScheduledTick;
            
            // Call the callback function
            try {
                // console.log('--- execution delCB['+key+']['+id+']');
                
                delayedCallbacks[key][id].cbFunction.call();
                            
                // then reinitialize the remainingTime to the interval value.
                if (delayedCallbacks) {
                    if (delayedCallbacks[key]) {
                        if (delayedCallbacks[key][id]) {
                            // If doneCallback is defined, execute what should be done after a callback execution succeeds
                            if (delayedCallbacks[key][id].doneCallback) {
                                delayedCallbacks[key][id].doneCallback.call(this, id);
                            }
                            if (delayedCallbacks[key][id].periodic === true) {
                                delayedCallbacks[key][id].nextExecutionTime += delayedCallbacks[key][id].interval;
                                putInCallbackQueue(key, id);
                            } else {
                                // All the executed callbacks that are not periodic, need to be removed from the List.
                                delete(delayedCallbacks[key][id]);
                                
                                // If delayedCallback of the key label is empty, then remove it
                                if (Object.size(delayedCallbacks[key]) === 2) {
                                    delete(delayedCallbacks[key]);
                                    if (Object.size(delayedCallbacks) === 0) {
                                        reset();
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }
            } catch (e) {
                console.log('Error executing delayedCallbacks[' + key + '][' + id + ']...');
                // If an error is catched, then use the errorCallback, if provided, to handle this,
                // otherwise, just print an error message
                if (delayedCallbacks[key][id].errorCallback) {
                    delayedCallbacks[key][id].errorCallback.call(this, e);
                } else {
                    console.error('********************** error stack trace:');
                    var stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '')
                        .replace(/^\s+at\s+/gm, '')
                        .replace(/^Object.&lt;anonymous>\s*\(/gm, '{anonymous}()@')
                        .split('\n');
                    console.error(stack);
                    console.error('**********************');
                }

                delete(delayedCallbacks[key][id]);
                
                // If delayedCallback of the key label is empty, then remove it
                if (Object.size(delayedCallbacks[key]) === 2) {
                    delete(delayedCallbacks[key]);
                    if (Object.size(delayedCallbacks) === 0) {
                        reset();
                        return;
                    }
                }
            }
        } else if (delayedCallbacks[key][id].nextExecutionTime > nextScheduledTick) {
            done = true;
        } else {
            throw new Error('executeCallbacks(): Callbacks are not sorted!');
        }
    } while(!done &amp;&amp; callbackQueue.length !== 0); 

    // Check if there are callbacks in the list
    if (Object.size(delayedCallbacks) === 0) {
        reset();
    }
}

/** callbackQueue variable keeps track of an ordered list of callbacks.
 *  This variable contains pointers to delayed callbacks, which are objects with two 
 *  attributes: the label and the id.
 *  
 *  This function performs a sorted insertion, given three levels of sorting. 
 *  The first one is the 'nextExecutionTime'. Then, when two or more callbacks have the 
 *  same nextExecutionTime,  other levels of sorting are considered:
 *   *  Second level of sorting: ascending order of labels (using the value of "origin")
 *   *  Third level: within the same label, delayed callbacks are ordered by priorities first,
 *      then by an ascending order of the callback identifiers. 
 *  
 *  @param label the labeled clock domain of the delayedCallback to add
 *  @param id the unique id of  of the delayedCallback to add
 */
function putInCallbackQueue(label, id) {
    // FIXME: The sorted insertion can be further improved for a more efficient execution, 
    // in terms of time.
    
    // Construct the object to add to the list
    var obj = {"label": label, "id": id};
    
    // Case if the list is already empty
    if (callbackQueue.length === 0) {
        callbackQueue.push(obj);
        return;
    }
    
    var index = 0;
    var labelInList, idInList;
    
    // Parse callbackQueue array looking for the index of insertion
    for (index = 0 ; index &lt; callbackQueue.length ; index++) {
        labelInList = callbackQueue[index].label;
        idInList = callbackQueue[index].id;
        
        // Control point for consistency check between delayedCallbacks and callbackQueue
        if (delayedCallbacks[labelInList][idInList] === undefined) {
            throw new Error('putInCallbackQueue(' + label + ', ' + id +
                            '): delayedCallbacks[' + labelInList + '][' +
                            idInList + '] is undefined?  index was: ' + index);
        } 
        
        // First level of sorting: nextExecutionTime
        if (delayedCallbacks[labelInList][idInList].nextExecutionTime &lt; delayedCallbacks[label][id].nextExecutionTime) {
            // Go to next element of array, until we reach the same nextExecutionTime or greater
            continue;
        } else if (delayedCallbacks[labelInList][idInList].nextExecutionTime > delayedCallbacks[label][id].nextExecutionTime) {
            // Case where delayedCallbacks[labelInList][idInList].nextExecutionTime > delayedCallbacks[label][id].nextExecutionTime
            // Then break the execution and add at that position
            break;
        } else {
            // This means that delayedCallbacks[labelInList][idInList].nextExecutionTime === delayedCallbacks[label][id].nextExecutionTime
            // Second level of sorting: LLCD's origin
            
            // If there is already callbacks with the same next execution time
            // Check first a sorted insertion w.r.t the label
            if (labelInList === label) {
                // Third level of sorting: 
                // Use of priorities and callback ids, except for the case of 'zeroTimeoutLabel'

                // For 'zeroTimeoutLabel', use identifiers
                if (label === 'zeroTimeoutLabel') {
                    // Don't use priority, but use identifiers
                    if (id &lt; idInList) {
                        break;
                    } else {
                        // Continue parsing until the position is found.
                        continue;
                    }
                }

                // For non 'zeroTimeoutLabel', use priorities and callback ids
                if (typeof delayedCallbacks[label][id].priority !== "undefined") {
                    // The callback to insert has priority (priority can be equal to 0. Then it is not undefined)
                    if (typeof delayedCallbacks[labelInList][idInList].priority !== "undefined") {
                        if (delayedCallbacks[label][id].priority === delayedCallbacks[labelInList][idInList].priority) {
                            // In case of identical priorities, use the identifiers to get the order
                            if (id &lt; idInList) {
                                break;
                            } else {
                                // Continue parsing until the position is found.
                                continue;
                            }
                        } else if (delayedCallbacks[label][id].priority &lt; delayedCallbacks[labelInList][idInList].priority) {
                            break;
                        } else {
                            continue;
                        }
                    } else {
                        break;
                    }
                } else {
                    // The callback has no priority 
                    if (typeof delayedCallbacks[labelInList][idInList].priority !== "undefined") {
                        // Callbacks that has priority attribute has more priority compared to
                        // those which do not have one
                        continue;
                    } else if (id &lt; idInList) {
                        // If both callbacks do not have priority, then sort given the id
                        break;
                    } else {
                        // Continue parsing until the position is found.
                        continue;
                    }
                }
            } else if (delayedCallbacks[labelInList].origin &lt; delayedCallbacks[label].origin) {
                // Go to next element of array, until we reach the same currentLogicalTime or greater
                continue;
            } else {
                // delayedCallbacks[labelInList].currentLogicalTime > delayedCallbacks[label].currentLogicalTime
                // Case where the label is not already scheduled at that time, and 
                // it must execute prior to the current one
                break;
            }
        }
    }
    
    callbackQueue.splice(index, 0, obj);
}

/** In case there are no more delayedCallbacks (that is when callbackQueue becomes
 *  empty or delayedCallbacks has no more callbacks, then reset all counter, identifiers,
 *  objects and lists. 
 */
function reset() {
    // Clear tick
    // originalClearTimeout(tick);
    clearTimeout(tick);
    
    // Make sure delayedCallbacks and callbackQueue are reset
    delayedCallbacks = null;
    callbackQueue = [];
    
    // Set initial values for nextScheduledTick, cbIdentifier and defaultLabelIndex 
    nextScheduledTick = Infinity;
    cbIdentifier = 0;
    defaultLabelIndex = 0;
}

/** Both, setIntervalDet and setTimeoutDet create a new delayed callback, compute the next
 *  execution time, add it to delayedCallbacks and to callbackQueue, and possibly update  
 *  the next tick. The only difference if that the first one creates a new delayed callback
 *  such that periodic attribute is set to true, while the second creates one with periodic 
 *  attribute set to false. The following function implements the core common behavior, 
 *  while setting periodic to the value it should be. Therefore, setIntervalDet and 
 *  setTimeoutDet just call this function with the right parameters.
 *  
 *  @param callback The callback function, which will be invoked once or periodically,
 *   depending on the value of the repeat parameter.
 *  @param timeout The time until the first (or only) execution of the callback.
 *   This is a non-negative number interpreted as milliseconds
 *   (a negative number will be treated as zero).
 *   This is a logical time, relative to the current logical time of the llcd.
 *   If the llcd is null or has never before been created, then a new llcd will be
 *   created and its logical time will be set to (approximately) the current physical time.
 *  @param repeat A boolean specifying whether the callback should be invoked just once
 *   (with value false) or repeatedly, periodically, until stopped (with value true).
 *   To stop it, call clearTick(), passing the returned handle.
 *  @param llcd An optional argument giving the labeled logical clock domain
 *   label as a string. If no llcd argument is given (the argument is null or undefined),
 *   then a new anonymous clock domain is created with its logical time origin set to the
 *   current real time (approximately). An exception is that if llcd is not given and
 *   timeout is zero, then a single shared zero-delay clock domain is used.
 *   This exception is used to request an execution as soon as possible, before any
 *   callbacks in other clock domains are invoked. If there are multiple such zero-timeout
 *   anonymous llcd callbacks, then the order of their invocation will be determined by
 *   their priority, if one is given, and by the order of the request, if no priority
 *   is given or if a priority matches another priority.
 *  @param priority An optional argument for the priority over other delayed callbacks
 *   that use the same llcd and are scheduled to occur at the same logical time.
 *   This is either null or an integer, where a lower value means higher priority.
 *   If two priorities match, then the order of invocation matches the order in which
 *   requests are made (by calling this function).
 *  @param errorCallback An optional argument that provides a callback to execute in case
 *   the delayed callback's execution throws an error. If no callback is specified, then
 *   if the delayed callback throws an error, then the error message and stack trace
 *   will be printed to the console and execution will continue.
 *  @param doneCallback An optional argument that provides the callback to execute after 
 *   the delayed callback has executed successfully. If repeat is true, then this callback
 *   will be invoked after each successful invocation of of the callback argument function.
 *  @return An integer that is the unique ID of the new delayed callback.
 */
function setDelayedCallback(callback, timeout, repeat, llcd, priority, errorCallback, doneCallback) {
    // Construct a new object
    var newDelayedCallback = {};
    newDelayedCallback.cbFunction = callback;
    newDelayedCallback.interval = timeout;
    newDelayedCallback.periodic = repeat;
    
    // FIXME: Set a control step for the last 4 parameters
    
    // Check if a labeled clock domain has been provided, otherwise use the default one
    var label;
    if (!llcd || llcd == null || typeof(llcd) !== 'string') {
        if (timeout === 0) {
            // Default LLCD for any delayed callback with timeout 0 that is given without
            // an explicitly different LLCD
            label = 'zeroTimeoutLabel';
        } else {
            label = ++defaultLabelIndex;
        }
    } else {
        label = llcd;
    }

    // Possibly set the priority, errorCallback and doneCallback
    if (priority !== null &amp;&amp; typeof(priority) == 'number') {
        newDelayedCallback.priority = priority;
    }
    if (errorCallback &amp;&amp; typeof(errorCallback) == 'function') {
        newDelayedCallback.errorCallback = errorCallback;  
    }
    if (doneCallback &amp;&amp; typeof(doneCallback) == 'function') {
        newDelayedCallback.doneCallback = doneCallback;  
    }

    // Generate a new identifier
    cbIdentifier++;
    
    // If the delayedCallbacks object was empty, then create the object
    if (!delayedCallbacks) {
        delayedCallbacks = {};
    }
    
    // If this is a new label, then create a new LLCD and set the current logical time to the 
    // current physical time
    if (!delayedCallbacks[label]) {
        delayedCallbacks[label] = {};
        if (label == 'zeroTimeoutLabel') {
            delayedCallbacks[label].currentLogicalTime = 0;
            delayedCallbacks[label].origin = 0;               
        } else {
            delayedCallbacks[label].currentLogicalTime = Date.now();
            delayedCallbacks[label].origin = delayedCallbacks[label].currentLogicalTime;
        }
    }
    
    // Set the next execution time of the new callback to the current logical time of the LLCD 
    // and add the timeout
    newDelayedCallback.nextExecutionTime = delayedCallbacks[label].currentLogicalTime + timeout;
    
    // Add the new delayed callback 
    delayedCallbacks[label][cbIdentifier] = newDelayedCallback;
    
    // Schedule the new delayed callback
    putInCallbackQueue(label, cbIdentifier);
    
    // Update the next tick if necessary
    if (nextScheduledTick > newDelayedCallback.nextExecutionTime) {
        // originalClearTimeout(tick);
        clearTimeout(tick);
        nextScheduledTick = newDelayedCallback.nextExecutionTime;
        // tick = originalSetTimeout(executeAndSetNextTick, Math.max(nextScheduledTick - Date.now(), 0));
        tick = setTimeout(executeAndSetNextTick, Math.max(nextScheduledTick - Date.now(), 0));
    }
    
    // return the callback identifier, useful for clearInterval
    return cbIdentifier;
}

/** This function is to be binded to setInterval() function. It calls setDelayedCallback
 *  since the core function is the same as SetTimeoutDet. After the new delayedCallback 
 *  is constructed, it is added to delayedCallbacks and to callbackQueue. If needed, the 
 *  next tick is updated. The returned value is the unique id of the delayed callback.
 *      
 *  @param callback The callback function, which will be invoked once or periodically,
 *   depending on the value of the repeat parameter.
 *  @param timeout The time until the first (or only) execution of the callback.
 *   This is a non-negative number interpreted as milliseconds
 *   (a negative number will be treated as zero).
 *   This is a logical time, relative to the current logical time of the llcd.
 *   If the llcd is null or has never before been created, then a new llcd will be
 *   created and its logical time will be set to (approximately) the current physical time.
 *  @param llcd An optional argument giving the labeled logical clock domain
 *   label as a string. If no llcd argument is given (the argument is null or undefined),
 *   then a new anonymous clock domain is created with its logical time origin set to the
 *   current real time (approximately). An exception is that if llcd is not given and
 *   timeout is zero, then a single shared zero-delay clock domain is used.
 *   This exception is used to request an execution as soon as possible, before any
 *   callbacks in other clock domains are invoked. If there are multiple such zero-timeout
 *   anonymous llcd callbacks, then the order of their invocation will be determined by
 *   their priority, if one is given, and by the order of the request, if no priority
 *   is given or if a priority matches another priority.
 *  @param priority An optional argument for the priority over other delayed callbacks
 *   that use the same llcd and are scheduled to occur at the same logical time.
 *   This is either null or an integer, where a lower value means higher priority.
 *   If two priorities match, then the order of invocation matches the order in which
 *   requests are made (by calling this function).
 *  @param errorCallback An optional argument that provides a callback to execute in case
 *   the delayed callback's execution throws an error. If no callback is specified, then
 *   if the delayed callback throws an error, then the error message and stack trace
 *   will be printed to the console and execution will continue.
 *  @param doneCallback An optional argument that provides the callback to execute after 
 *   the delayed callback has executed successfully. If repeat is true, then this callback
 *   will be invoked after each successful invocation of of the callback argument function.
 *  @return An integer that is the unique ID of the new delayed callback
 */
 function setIntervalDet(callback, timeout, llcd, priority, errorCallback, doneCallback) {
    // Throw an error if setInterval is called with timeout 0
    // Since this may lead to a dangerous behavior
    if (timeout === 0) {
        throw new Error('setInterval(): timeout zero is not allowed!');
    }
    return setDelayedCallback(callback, timeout, true, llcd, priority, errorCallback, doneCallback);
}

/** This function is to be binded to setTimeout() function. It calls setDelayedCallback
 *  since the core function is the same as SetIntervalDet. After the new delayedCallback 
 *  is constructed, it is added to delayedCallbacks and to callbackQueue. If needed, the 
 *  next tick is updated. The returned value is the unique id of the delayed callback.  
 *    
 *  @param callback The callback function, which will be invoked once or periodically,
 *   depending on the value of the repeat parameter.
 *  @param timeout The time until the first (or only) execution of the callback.
 *   This is a non-negative number interpreted as milliseconds
 *   (a negative number will be treated as zero).
 *   This is a logical time, relative to the current logical time of the llcd.
 *   If the llcd is null or has never before been created, then a new llcd will be
 *   created and its logical time will be set to (approximately) the current physical time.
 *  @param repeat A boolean specifying whether the callback should be invoked just once
 *   (with value false) or repeatedly, periodically, until stopped (with value true).
 *   To stop it, call clearTick(), passing the returned handle.
 *  @param llcd An optional argument giving the labeled logical clock domain
 *   label as a string. If no llcd argument is given (the argument is null or undefined),
 *   then a new anonymous clock domain is created with its logical time origin set to the
 *   current real time (approximately). An exception is that if llcd is not given and
 *   timeout is zero, then a single shared zero-delay clock domain is used.
 *   This exception is used to request an execution as soon as possible, before any
 *   callbacks in other clock domains are invoked. If there are multiple such zero-timeout
 *   anonymous llcd callbacks, then the order of their invocation will be determined by
 *   their priority, if one is given, and by the order of the request, if no priority
 *   is given or if a priority matches another priority.
 *  @param priority An optional argument for the priority over other delayed callbacks
 *   that use the same llcd and are scheduled to occur at the same logical time.
 *   This is either null or an integer, where a lower value means higher priority.
 *   If two priorities match, then the order of invocation matches the order in which
 *   requests are made (by calling this function).
 *  @param errorCallback An optional argument that provides a callback to execute in case
 *   the delayed callback's execution throws an error. If no callback is specified, then
 *   if the delayed callback throws an error, then the error message and stack trace
 *   will be printed to the console and execution will continue.
 *  @param doneCallback An optional argument that provides the callback to execute after 
 *   the delayed callback has executed successfully. If repeat is true, then this callback
 *   will be invoked after each successful invocation of of the callback argument function.
 *  @return An integer that is the unique ID of the new one time delayed callback.
 */
function setTimeoutDet(callback, timeout, llcd, priority, errorCallback, doneCallback) {
    // Just call setDelayedCallback and return
    return setDelayedCallback(callback, timeout, false, llcd, priority, errorCallback, doneCallback);
}

/** This function is used to return the number of an object entries.
 *  It is to be used to compute the number of labels in delayedCallbacks.
 *  @param obj the object. In this case: delayedCallbacks
 *  @return size the number of entries in delayedCallbacks
 */
Object.size = function(obj) {
    var size = 0, key;
    
    if (obj === null) {
        return 0;
    }
    
    for (key in obj) {
        if (obj.hasOwnProperty(key)) size++;
    }
    return size;
};

// Redirecting setTimeout, setInterval, clearTimeout, clearInterval to the 
// deterministic ones
// setTimeout = setTimeoutDet;
// setInterval = setIntervalDet;
// clearInterval = clearIntervalDet;
// clearTimeout = clearTimeoutDet;

///////////////////////////////////////////////////////////////////
//// Exports

exports.setTimeoutDet = setTimeoutDet;
exports.clearTimeoutDet = clearTimeoutDet;
exports.setIntervalDet = setIntervalDet;
exports.clearIntervalDet = clearIntervalDet;
exports.reset = reset;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Accessors</h3><ul><li><a href="accessor-adapters_Adapter.html">adapters/Adapter</a></li><li><a href="accessor-adapters_CelsiusToFahrenheit.html">adapters/CelsiusToFahrenheit</a></li><li><a href="accessor-adapters_Identity.html">adapters/Identity</a></li><li><a href="accessor-adapters_KelvinToFahrenheit.html">adapters/KelvinToFahrenheit</a></li><li><a href="accessor-audio_AudioCapture.html">audio/AudioCapture</a></li><li><a href="accessor-audio_AudioPlayer.html">audio/AudioPlayer</a></li><li><a href="accessor-audio_ClipPlayer.html">audio/ClipPlayer</a></li><li><a href="accessor-audioIo_AudioIoCapture.html">audioIo/AudioIoCapture</a></li><li><a href="accessor-audioIo_AudioIoPlay.html">audioIo/AudioIoPlay</a></li><li><a href="accessor-audioIo_AudioIoWavFile.html">audioIo/AudioIoWavFile</a></li><li><a href="accessor-cameras_Camera.html">cameras/Camera</a></li><li><a href="accessor-cameras_Foscam.html">cameras/Foscam</a></li><li><a href="accessor-contextAware_contextAware.html">contextAware/contextAware</a></li><li><a href="accessor-contextAware_contextAwareTest.html">contextAware/contextAwareTest</a></li><li><a href="accessor-dashboard_GraphComponent.html">dashboard/GraphComponent</a></li><li><a href="accessor-dashboard_RestaurantComponent.html">dashboard/RestaurantComponent</a></li><li><a href="accessor-dashboard_RoutingWebSocketServer.html">dashboard/RoutingWebSocketServer</a></li><li><a href="accessor-dashboard_SpeedometerComponent.html">dashboard/SpeedometerComponent</a></li><li><a href="accessor-dashboard_UIComponent.html">dashboard/UIComponent</a></li><li><a href="accessor-dashboard_VideoComponent.html">dashboard/VideoComponent</a></li><li><a href="accessor-deterministicTemporalSemantics_SpontaneousAperiodic.html">deterministicTemporalSemantics/SpontaneousAperiodic</a></li><li><a href="accessor-deterministicTemporalSemantics_SpontaneousPeriodic.html">deterministicTemporalSemantics/SpontaneousPeriodic</a></li><li><a href="accessor-devices_AdsB.html">devices/AdsB</a></li><li><a href="accessor-devices_DrDose.html">devices/DrDose</a></li><li><a href="accessor-devices_EcSensor.html">devices/EcSensor</a></li><li><a href="accessor-devices_Hue.html">devices/Hue</a></li><li><a href="accessor-devices_Lifx.html">devices/Lifx</a></li><li><a href="accessor-devices_Moto360SensorListener.html">devices/Moto360SensorListener</a></li><li><a href="accessor-devices_PhSensor.html">devices/PhSensor</a></li><li><a href="accessor-geodesy_Lla2Ecef.html">geodesy/Lla2Ecef</a></li><li><a href="accessor-geodesy_LlaDist.html">geodesy/LlaDist</a></li><li><a href="accessor-HandlerWithSuppress.html">HandlerWithSuppress</a></li><li><a href="accessor-Hello.html">Hello</a></li><li><a href="accessor-image_AprilTags.html">image/AprilTags</a></li><li><a href="accessor-image_CharacterDetection.html">image/CharacterDetection</a></li><li><a href="accessor-image_ComputerVision.html">image/ComputerVision</a></li><li><a href="accessor-image_demo_TextFromCamera.html">image/demo/TextFromCamera</a></li><li><a href="accessor-image_FaceDetector.html">image/FaceDetector</a></li><li><a href="accessor-image_ImageAnnotate.html">image/ImageAnnotate</a></li><li><a href="accessor-image_ImageDisplay.html">image/ImageDisplay</a></li><li><a href="accessor-image_ImageFilter.html">image/ImageFilter</a></li><li><a href="accessor-image_MotionDetector.html">image/MotionDetector</a></li><li><a href="accessor-LifxAccessorTemplate.html">LifxAccessorTemplate</a></li><li><a href="accessor-localization_Location.html">localization/Location</a></li><li><a href="accessor-localization_mapRepo.html">localization/mapRepo</a></li><li><a href="accessor-mutable_MutableTestGain.html">mutable/MutableTestGain</a></li><li><a href="accessor-mutable_TestGain1.html">mutable/TestGain1</a></li><li><a href="accessor-mutable_TestGain2.html">mutable/TestGain2</a></li><li><a href="accessor-net_Discovery.html">net/Discovery</a></li><li><a href="accessor-net_IPAddress.html">net/IPAddress</a></li><li><a href="accessor-net_KeyValueStore.html">net/KeyValueStore</a></li><li><a href="accessor-net_MQTTPublisher.html">net/MQTTPublisher</a></li><li><a href="accessor-net_MQTTSubscriber.html">net/MQTTSubscriber</a></li><li><a href="accessor-net_REST.html">net/REST</a></li><li><a href="accessor-net_SecureCommClient.html">net/SecureCommClient</a></li><li><a href="accessor-net_SecureCommServer.html">net/SecureCommServer</a></li><li><a href="accessor-net_SecurePublisher.html">net/SecurePublisher</a></li><li><a href="accessor-net_SecureSubscriber.html">net/SecureSubscriber</a></li><li><a href="accessor-net_SerialPort.html">net/SerialPort</a></li><li><a href="accessor-net_TCPSocketClient.html">net/TCPSocketClient</a></li><li><a href="accessor-net_TCPSocketServer.html">net/TCPSocketServer</a></li><li><a href="accessor-net_UDPSocketListener.html">net/UDPSocketListener</a></li><li><a href="accessor-net_UDPSocketSender.html">net/UDPSocketSender</a></li><li><a href="accessor-net_VertxPublish.html">net/VertxPublish</a></li><li><a href="accessor-net_VertxSubscribe.html">net/VertxSubscribe</a></li><li><a href="accessor-net_WebServer.html">net/WebServer</a></li><li><a href="accessor-net_WebSocketClient.html">net/WebSocketClient</a></li><li><a href="accessor-net_WebSocketServer.html">net/WebSocketServer</a></li><li><a href="accessor-net_XBee.html">net/XBee</a></li><li><a href="accessor-PressureSensor.html">PressureSensor</a></li><li><a href="accessor-robotics_DroneLocation.html">robotics/DroneLocation</a></li><li><a href="accessor-robotics_GlobalPosition2LatLonAlt.html">robotics/GlobalPosition2LatLonAlt</a></li><li><a href="accessor-robotics_LocationRosPublisher.html">robotics/LocationRosPublisher</a></li><li><a href="accessor-robotics_RosPublisher.html">robotics/RosPublisher</a></li><li><a href="accessor-robotics_RosSubscriber.html">robotics/RosSubscriber</a></li><li><a href="accessor-robotics_Scarab.html">robotics/Scarab</a></li><li><a href="accessor-RosCommand.html">RosCommand</a></li><li><a href="accessor-ROSTeleoperation.html">ROSTeleoperation</a></li><li><a href="accessor-services_FFT.html">services/FFT</a></li><li><a href="accessor-services_FINDLocation.html">services/FINDLocation</a></li><li><a href="accessor-services_FINDTracker.html">services/FINDTracker</a></li><li><a href="accessor-services_GeoCoder.html">services/GeoCoder</a></li><li><a href="accessor-services_GeoLocation.html">services/GeoLocation</a></li><li><a href="accessor-services_Heartbeat.html">services/Heartbeat</a></li><li><a href="accessor-services_HostCompatability.html">services/HostCompatability</a></li><li><a href="accessor-services_NaturalLanguage.html">services/NaturalLanguage</a></li><li><a href="accessor-services_RedPinLocation.html">services/RedPinLocation</a></li><li><a href="accessor-services_ReverseGeoCoder.html">services/ReverseGeoCoder</a></li><li><a href="accessor-services_SemanticRepositoryQuery.html">services/SemanticRepositoryQuery</a></li><li><a href="accessor-services_SemanticRepositoryUpdate.html">services/SemanticRepositoryUpdate</a></li><li><a href="accessor-services_SemanticYelpSearch.html">services/SemanticYelpSearch</a></li><li><a href="accessor-services_SpeechRecognition.html">services/SpeechRecognition</a></li><li><a href="accessor-services_Weather.html">services/Weather</a></li><li><a href="accessor-services_WiFiScan.html">services/WiFiScan</a></li><li><a href="accessor-services_YelpSearch.html">services/YelpSearch</a></li><li><a href="accessor-SoundActuator.html">SoundActuator</a></li><li><a href="accessor-TemperatureSensor.html">TemperatureSensor</a></li><li><a href="accessor-test_Test.html">test/Test</a></li><li><a href="accessor-test_TestAccessor.html">test/TestAccessor</a></li><li><a href="accessor-test_TestAdder.html">test/TestAdder</a></li><li><a href="accessor-test_TestBaseC.html">test/TestBaseC</a></li><li><a href="accessor-test_TestComposite.html">test/TestComposite</a></li><li><a href="accessor-test_TestCompositeSpontaneous.html">test/TestCompositeSpontaneous</a></li><li><a href="accessor-test_TestDerivedAgainA.html">test/TestDerivedAgainA</a></li><li><a href="accessor-test_TestDerivedC.html">test/TestDerivedC</a></li><li><a href="accessor-test_TestFunctions.html">test/TestFunctions</a></li><li><a href="accessor-test_TestGain.html">test/TestGain</a></li><li><a href="accessor-test_TestImplement.html">test/TestImplement</a></li><li><a href="accessor-test_TestInheritance.html">test/TestInheritance</a></li><li><a href="accessor-test_TestRequire.html">test/TestRequire</a></li><li><a href="accessor-test_TestSpontaneous.html">test/TestSpontaneous</a></li><li><a href="accessor-test_TestSpontaneousOnce.html">test/TestSpontaneousOnce</a></li><li><a href="accessor-test_TestWebSocketClient.html">test/TestWebSocketClient</a></li><li><a href="accessor-test_TrainableTest.html">test/TrainableTest</a></li><li><a href="accessor-TestDerivedC.html">TestDerivedC</a></li><li><a href="accessor-TrafficLight.html">TrafficLight</a></li><li><a href="accessor-trusted_AccessorStatus.html">trusted/AccessorStatus</a></li><li><a href="accessor-tutorial_Hello.html">tutorial/Hello</a></li><li><a href="accessor-util_GetResource.html">util/GetResource</a></li><li><a href="accessor-utilities_Clock.html">utilities/Clock</a></li><li><a href="accessor-utilities_Cron.html">utilities/Cron</a></li><li><a href="accessor-utilities_Exec.html">utilities/Exec</a></li><li><a href="accessor-utilities_GetAccessor.html">utilities/GetAccessor</a></li><li><a href="accessor-utilities_LocalStorage.html">utilities/LocalStorage</a></li><li><a href="accessor-utilities_MutableBase.html">utilities/MutableBase</a></li><li><a href="accessor-utilities_Stop.html">utilities/Stop</a></li><li><a href="accessor-utilities_TextDisplay.html">utilities/TextDisplay</a></li><li><a href="accessor-utility_HostName.html">utility/HostName</a></li><li><a href="accessor-VibrationSensor.html">VibrationSensor</a></li><li><a href="MessageBoard.accessor_js.html">js</a></li><li><a href="utilities_UserInterface.accessor_js.html">js</a></li></ul><h3>Modules</h3><ul><li><a href="module-@accessor-hosts_browser.html">@accessor-hosts/browser</a></li><li><a href="module-@accessors-hosts_browser_demo_tutorial.html">@accessors-hosts/browser/demo/tutorial</a></li><li><a href="module-@accessors-hosts_browser_test_regressionTestScript.html">@accessors-hosts/browser/test/regressionTestScript</a></li><li><a href="module-@accessors-hosts_common_deterministicTemporalSemantics.html">@accessors-hosts/common/deterministicTemporalSemantics</a></li><li><a href="module-@accessors-hosts_common_modules_hostHelper.html">@accessors-hosts/common/modules/hostHelper</a></li><li><a href="module-@accessors-hosts_common_modules_ontology.html">@accessors-hosts/common/modules/ontology</a></li><li><a href="module-@accessors-hosts_common_modules_util.html">@accessors-hosts/common/modules/util</a></li><li><a href="module-@accessors-hosts_common_sync-atom.html">@accessors-hosts/common/sync-atom</a></li><li><a href="module-@accessors-hosts_commonHost.html">@accessors-hosts/commonHost</a></li><li><a href="module-@accessors-hosts_duktapeHost.html">@accessors-hosts/duktapeHost</a></li><li><a href="module-@accessors-hosts_node_nodeHostInvoke.html">@accessors-hosts/node/nodeHostInvoke</a></li><li><a href="module-@accessors-hosts_node_nodeHostShell.html">@accessors-hosts/node/nodeHostShell</a></li><li><a href="module-@accessors-hosts_node_test_mocha_testNodeAllAuto.html">@accessors-hosts/node/test/mocha/testNodeAllAuto</a></li><li><a href="module-@accessors-hosts_node_test_testNodeAuto.html">@accessors-hosts/node/test/testNodeAuto</a></li><li><a href="module-@accessors-hosts_nodeHost.html">@accessors-hosts/nodeHost</a></li><li><a href="module-@accessors-modules_cameras.html">@accessors-modules/cameras</a></li><li><a href="module-@accessors-modules_discovery.html">@accessors-modules/discovery</a></li><li><a href="module-@accessors-modules_http-client.html">@accessors-modules/http-client</a></li><li><a href="module-@accessors-modules_http-server.html">@accessors-modules/http-server</a></li><li><a href="module-@accessors-modules_image-display.html">@accessors-modules/image-display</a></li><li><a href="module-@accessors-modules_iot-auth.html">@accessors-modules/iot-auth</a></li><li><a href="module-@accessors-modules_local-storage.html">@accessors-modules/local-storage</a></li><li><a href="module-@accessors-modules_serial.html">@accessors-modules/serial</a></li><li><a href="module-@accessors-modules_socket.html">@accessors-modules/socket</a></li><li><a href="module-@accessors-modules_text-display.html">@accessors-modules/text-display</a></li><li><a href="module-@accessors-modules_udp-socket.html">@accessors-modules/udp-socket</a></li><li><a href="module-@accessors-modules_web-socket-client.html">@accessors-modules/web-socket-client</a></li><li><a href="module-@accessors-modules_web-socket-server.html">@accessors-modules/web-socket-server</a></li><li><a href="module-accessorMap.html">accessorMap</a></li><li><a href="module-accessorMapCapeCode.html">accessorMapCapeCode</a></li><li><a href="module-aprilTags.html">aprilTags</a></li><li><a href="module-audio.html">audio</a></li><li><a href="module-ble.html">ble</a></li><li><a href="module-buffer.html">buffer</a></li><li><a href="module-camera.html">camera</a></li><li><a href="module-capeCodeHost.html">capeCodeHost</a></li><li><a href="module-computerVision.html">computerVision</a></li><li><a href="module-console.html">console</a></li><li><a href="module-contextAware.html">contextAware</a></li><li><a href="module-cordova_modules_util.html">cordova/modules/util</a></li><li><a href="module-cordovaHost.html">cordovaHost</a></li><li><a href="module-crypto.html">crypto</a></li><li><a href="module-dataConverter.html">dataConverter</a></li><li><a href="module-discovery.html">discovery</a></li><li><a href="module-dsp.html">dsp</a></li><li><a href="module-duktape_modules_util.html">duktape/modules/util</a></li><li><a href="module-eventbus.html">eventbus</a></li><li><a href="module-faceDetector.html">faceDetector</a></li><li><a href="module-geolocation.html">geolocation</a></li><li><a href="module-http-client.html">http-client</a></li><li><a href="module-httpServer.html">httpServer</a></li><li><a href="module-imageDisplay.html">imageDisplay</a></li><li><a href="module-imageFilters.html">imageFilters</a></li><li><a href="module-IMUSensor.html">IMUSensor</a></li><li><a href="module-iotAuth.html">iotAuth</a></li><li><a href="module-lib_interfaces_common.html">lib/interfaces/common</a></li><li><a href="module-localFunctions.html">localFunctions</a></li><li><a href="module-localStorage.html">localStorage</a></li><li><a href="module-motionDetector.html">motionDetector</a></li><li><a href="module-mqtt.html">mqtt</a></li><li><a href="module-nashornHost.html">nashornHost</a></li><li><a href="module-objectAssign.html">objectAssign</a></li><li><a href="module-os.html">os</a></li><li><a href="module-sampleStatus.html">sampleStatus</a></li><li><a href="module-serial.html">serial</a></li><li><a href="module-shell.html">shell</a></li><li><a href="module-simpleMutable.html">simpleMutable</a></li><li><a href="module-socket.html">socket</a></li><li><a href="module-speechRecognition.html">speechRecognition</a></li><li><a href="module-status.html">status</a></li><li><a href="module-textDisplay.html">textDisplay</a></li><li><a href="module-udpSocket.html">udpSocket</a></li><li><a href="module-userInterface.html">userInterface</a></li><li><a href="module-web-socket-server.html">web-socket-server</a></li><li><a href="module-webSocket.html">webSocket</a></li><li><a href="module-webSocketClient.html">webSocketClient</a></li><li><a href="module-webSocketServer.html">webSocketServer</a></li><li><a href="module-wifiScanner.html">wifiScanner</a></li><li><a href="module-xbee.html">xbee</a></li><li><a href="swarmlet.module_js.html">js</a></li></ul><h3>Classes</h3><ul><li><a href="CoordinateSystem.html">CoordinateSystem</a></li><li><a href="Entity.html">Entity</a></li><li><a href="Map.html">Map</a></li><li><a href="MapSource.html">MapSource</a></li><li><a href="module-eventbus-VertxBus.html">VertxBus</a></li><li><a href="module-http-client-ClientRequest.html">ClientRequest</a></li><li><a href="module-http-client-IncomingMessage.html">IncomingMessage</a></li><li><a href="ObservationMetadata.html">ObservationMetadata</a></li><li><a href="Occupancy.html">Occupancy</a></li><li><a href="Placement.html">Placement</a></li><li><a href="Quaternion.html">Quaternion</a></li><li><a href="URL.html">URL</a></li></ul><h3>Namespaces</h3><ul><li><a href="addChainableMethod.html">addChainableMethod</a></li><li><a href="addMethod.html">addMethod</a></li><li><a href="addProperty.html">addProperty</a></li><li><a href="Assert.html">Assert</a></li><li><a href="BDD.html">BDD</a></li><li><a href="Expect.html">Expect</a></li><li><a href="expectTypes.html">expectTypes</a></li><li><a href="flag.html">flag</a></li><li><a href="getActual.html">getActual</a></li><li><a href="getEnumerableProperties.html">getEnumerableProperties</a></li><li><a href="getMessage.html">getMessage</a></li><li><a href="getName.html">getName</a></li><li><a href="getPathInfo.html">getPathInfo</a></li><li><a href="getPathValue.html">getPathValue</a></li><li><a href="getProperties.html">getProperties</a></li><li><a href="inspect.html">inspect</a></li><li><a href="overwriteChainableMethod.html">overwriteChainableMethod</a></li><li><a href="overwriteMethod.html">overwriteMethod</a></li><li><a href="overwriteProperty.html">overwriteProperty</a></li><li><a href="Should.html">Should</a></li><li><a href="test.html">test</a></li><li><a href="transferFlags.html">transferFlags</a></li><li><a href="Utils.html">Utils</a></li></ul><h3>Global</h3><ul><li><a href="global.html"></a></li><li><a href="global.html#addObserver">addObserver</a></li><li><a href="global.html#assert">assert</a></li><li><a href="global.html#clearRepo">clearRepo</a></li><li><a href="global.html#coordinateTransformationsToJSONString">coordinateTransformationsToJSONString</a></li><li><a href="global.html#coordinateTransformationsToString">coordinateTransformationsToString</a></li><li><a href="global.html#createApplication">createApplication</a></li><li><a href="global.html#createApplicationDeprecated">createApplicationDeprecated</a></li><li><a href="global.html#createApplicationNew">createApplicationNew</a></li><li><a href="global.html#decode">decode</a></li><li><a href="global.html#drawMap">drawMap</a></li><li><a href="global.html#entitiesToJSONString">entitiesToJSONString</a></li><li><a href="global.html#entitiesToString">entitiesToString</a></li><li><a href="global.html#EventEmitter">EventEmitter</a></li><li><a href="global.html#express">express</a></li><li><a href="global.html#extractProtocol">extractProtocol</a></li><li><a href="global.html#findSignpost">findSignpost</a></li><li><a href="global.html#getCoordinateTransformation">getCoordinateTransformation</a></li><li><a href="global.html#getResource">getResource</a></li><li><a href="global.html#getSignposts">getSignposts</a></li><li><a href="global.html#httpClient">httpClient</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#localRepoToJSONString">localRepoToJSONString</a></li><li><a href="global.html#lolcation">lolcation</a></li><li><a href="global.html#mapsToJSONString">mapsToJSONString</a></li><li><a href="global.html#mapsToString">mapsToString</a></li><li><a href="global.html#nodeHost">nodeHost</a></li><li><a href="global.html#parseDataAudio">parseDataAudio</a></li><li><a href="global.html#publish">publish</a></li><li><a href="global.html#query">query</a></li><li><a href="global.html#querystring">querystring</a></li><li><a href="global.html#querystringify">querystringify</a></li><li><a href="global.html#registerAndReact">registerAndReact</a></li><li><a href="global.html#registerCoordinateTransformation">registerCoordinateTransformation</a></li><li><a href="global.html#registerEntity">registerEntity</a></li><li><a href="global.html#registerMap">registerMap</a></li><li><a href="global.html#replaceRepo">replaceRepo</a></li><li><a href="global.html#resolve">resolve</a></li><li><a href="global.html#rules">rules</a></li><li><a href="global.html#set">set</a></li><li><a href="global.html#setup">setup</a></li><li><a href="global.html#SpaceTypeEnum">SpaceTypeEnum</a></li><li><a href="global.html#startEddystoneURLBeacon">startEddystoneURLBeacon</a></li><li><a href="global.html#stop">stop</a></li><li><a href="global.html#stopAll">stopAll</a></li><li><a href="global.html">stringify</a></li><li><a href="global.html#subscribe">subscribe</a></li><li><a href="global.html#Testing">Testing</a></li><li><a href="global.html#toString">toString</a></li><li><a href="global.html#unpublish">unpublish</a></li><li><a href="global.html#unsubscribe">unsubscribe</a></li><li><a href="global.html#useSampleAudioData">useSampleAudioData</a></li><li><a href="global.html#useSampleRFData">useSampleRFData</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.1-dev</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
